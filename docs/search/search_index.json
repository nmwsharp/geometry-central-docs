{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to Geometry Central","text":"<p>Geometry-central is a modern C++ library of data structures and algorithms for geometry processing, with a particular focus on surface meshes.</p> <p> </p> <p>Features include:</p> <ul> <li>A polished surface mesh class, with efficient support for mesh modification, and a system of containers for associating data with mesh elements.</li> <li>Implementations of canonical geometric quantities on surfaces, ranging from normals and curvatures to tangent vector bases to operators from discrete differential geometry.</li> <li>A suite of powerful algorithms, including computing distances on surface, generating direction fields, and manipulating intrinsic Delaunay triangulations.</li> <li>A coherent set of sparse linear algebra tools, based on Eigen and augmented to automatically utilize better solvers if available on your system.</li> </ul> <p>Sample:</p> <pre><code>// Load a mesh\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readSurfaceMesh(\"spot.obj\"); // Compute vertex areas\nVertexData&lt;double&gt; vertexAreas(*mesh);\n\ngeometry-&gt;requireFaceAreas();\nfor(Vertex v : mesh-&gt;vertices()) {\ndouble A = 0.;\nfor(Face f : v.adjacentFaces()) {\nA += geometry-&gt;faceAreas[f] / v.degree();\n}\nvertexAreas[v] = A;\n}\n</code></pre> <p>For more, see the tutorials. To get started with the code, see building. Use the sample project to get started with a build system and a gui.</p> <p>A introductory talk on geometry-central was given at SGP 2020, check it out to get started: www.youtube.com/watch?v=mw5Xz9CFZ7A</p> <p>Bindings &amp; Plugins:</p> <ul> <li>Python: Potpourri3d</li> <li>Grasshopper/Rhino: Lionfish by Math Whittaker</li> </ul> <p>If you\u2019re interested in creating additional bindings/plugins, feel free to reach out!</p> <p>Related alternatives: CGAL, libIGL, OpenMesh, Polygon Mesh Processing Library, CinoLib</p> <p>Credits</p> <p>Geometry-central is developed by Nicholas Sharp, with many contributions from  Keenan Crane,  Yousuf Soliman, Mark Gillespie, Rohan Sawhney,  Chris Yu, and many others.</p> <p>If geometry-central contributes to an academic publication, cite it as: <pre><code>@article{geometrycentral,\ntitle={GeometryCentral: A modern C++ library of data structures and algorithms for geometry processing},\nauthor={Nicholas Sharp and Keenan Crane and others},\nhowpublished=\"\\url{https://geometry-central.net/}\",\nyear={2019}\n}\n</code></pre></p> <p>Development of this software was funded in part by NSF Award 1717320, an NSF graduate research fellowship, and gifts from Adobe Research and Autodesk, Inc.</p>"},{"location":"build/building/","title":"Building","text":"<p>geometry-central uses CMake for to configure the build system. The basic workflow for downloading and compiling geometry-central via a terminal is:</p> <pre><code>git clone --recurse-submodules https://github.com/nmwsharp/geometry-central.git\ncd geometry-central\nmkdir build &amp;&amp; cd build\ncmake -DCMAKE_BUILD_TYPE=Release ..\nmake -j4\n</code></pre> <p>However, since geometry-central is just a library, this does not build any executables, it merely compiles the library.</p> <p>You can add geometry-central to an existing project\u2019s <code>CMakeLists.txt</code> like</p> <pre><code>add_subdirectory(\"path/to/geometry-central\") # wherever you put it\ntarget_link_libraries(your-project-target geometry-central)\n</code></pre>"},{"location":"build/building/#example","title":"Example","text":"<p>For a simple example project using geometry-central (with Polyscope for visualization), see gc-polyscope-project-template. This is a good starting point for new projects using geometry-central.</p>"},{"location":"build/building/#on-windows","title":"On Windows","text":"<p>When using Visual Studio on Windows, CMake can be used (either via the terminal or gui) to generate Visual Studio project and solution files. The project has been verified to compile out of the box with Visual Studio 2017 &amp; 2019 (older versions not tested).</p>"},{"location":"build/building/#compile-flags-options","title":"Compile flags &amp; options","text":"<p>The library includes a few optional safety checks which are performed at runtime, even in release mode. Such checks are generally very cheap yet quite useful. Nonetheless, adding the <code>NGC_SAFETY_CHECKS</code> define will disable all optional safety checks, for a very small increase in performance.</p>"},{"location":"build/dependencies/","title":"Dependencies","text":"<p>geometry-central manages its dependenices via a mix of git submodules, configure-time downloading, and system libraries. However, the build system is explicitly set up such that cloning and building should immediately work on any vaguely reasonable machine, without chasing down dependencies.</p> <p>Remember, clone with: <pre><code>git clone --recurse-submodules https://github.com/nmwsharp/geometry-central.git\n</code></pre></p> <p>to ensure you resolve git submodules. If you cloned without submodules, you can get them afterwards with:</p> <pre><code>git submodule update --init --recursive\n</code></pre>"},{"location":"build/dependencies/#eigen","title":"Eigen","text":"<p>Eigen is used for linear algebra within geometry-central. Eigen presents a bit of a special challenge as a dependency because many programmers already have Eigen in the project or system, and intermingling multiple copies of Eigen can be problematic.</p> <p>As such, the build system uses the following strategies in order to resolve Eigen:</p> <ol> <li>The target <code>Eigen3::Eigen</code> is already defined somewhere. Use the predefined target over any hints from the user</li> <li>Using Eigen in any directory passed via the <code>GC_EIGEN_LOCATION</code> CMake cache variable (empty by default, see note below)</li> <li>Using Eigen from your system libraries, as resolved via <code>find_package(Eigen3 3.3)</code></li> <li>Downloading a copy of Eigen in to the <code>deps/downloads/</code> directory</li> </ol> <p>For instance, if your project already has a copy of Eigen in its source tree, you can use it with (2) by setting <code>GC_EIGEN_LOCATION</code>. If not, many programmers have installed Eigen, which will be found in (3). Finally, as a last resort the build system will download a copy of Eigen as in (4).</p> <p>Set <code>GC_ALWAYS_DOWNLOAD_EIGEN=TRUE</code> to cause CMake to always prefer option (4) above, and prefer downloading a new copy of Eigen over using a system copy.</p> <p>geometry-central is known to work with version 3.3.8 of Eigen; other versions have not been tested (but recent versions probably work).</p> setting <code>GC_EIGEN_LOCATION</code> <p>The joys of CMake: if you are trying to set <code>GC_EIGEN_LOCATION</code> from some higher-level CMake script, you need to set it as a cache variable, which are different from \u2018normal\u2019 variables in CMake. As an example:</p> <pre><code>set(GC_EIGEN_LOCATION \"full/path/to/eigen\" CACHE PATH \"my path\")\nadd_subdirectory(geometry-central)\n</code></pre>"},{"location":"build/dependencies/#suitesparse","title":"Suitesparse","text":"<p>Suitesparse is an optional dependency which improves the performance and robustness of geometry-central\u2019s sparse linear solver routines. If Suitesparse is detected at configure time, linear solves will automatically use Suitesparse under the hood, and otherwise they will default to Eigen\u2019s solvers. The output of the CMake script will indicate whether or not Suitesparse was found.</p> <p>At any time, setting the <code>SUITESPARSE</code> CMake variable to false will stop the build system from using Suitesparse, even if it is availble.</p> <p>Installing suitesparse is up to the user. If using homebrew on OSX, <code>brew install suitesparse</code> should be sufficient. On Ubuntu, try <code>apt-get install libsuitesparse-dev</code>. Suitesparse is notoriously difficult to install on Windows\u2014if you find a good method, let us know!</p>"},{"location":"build/tests/","title":"Tests","text":""},{"location":"build/tests/#building-and-running-tests","title":"Building and running tests","text":"<p>Compile and run the tests with: <pre><code>cd test\nmkdir build &amp;&amp; cd build\ncmake -DCMAKE_BUILD_TYPE=Debug ..\nmake -j12 &amp;&amp; ./bin/geometry-central-test\n</code></pre></p>"},{"location":"build/tests/#tests-organization","title":"Tests organization","text":"<p>All tests are stored in the <code>test/</code> subdirectory, which is not touched by the usual build system.</p>"},{"location":"build/tests/#googletest","title":"googletest","text":"<p>We use googletest as a testing framework. Most users do not need the tests, so rather than packing it as a git submodule which would unavoidably be cloned, the build system downloads a binary of the googletest when the tests are built\u2014a consequence is that you must have a network connection to build tests for the first time (TODO: enable using a system install of googletest).</p>"},{"location":"build/tests/#assets","title":"Assets","text":"<p>The <code>tests/assets/</code> directory contains a handful of input files for various tests. The absolute paths to these files are baked in to the test executable by the build system, so moving this directory after compiling tests may cause problems. The disk footprint of assets should be kept as small as possible since they are stored in the library repository.</p>"},{"location":"build/versions/","title":"Versions","text":""},{"location":"build/versions/#changes-in-main-branch-since-last-version","title":"Changes in main branch since last version","text":"<ul> <li>Change the semantics of <code>MeshData&lt;&gt;::size()</code> to match what <code>size()</code> usually means</li> </ul>"},{"location":"build/versions/#july-3-2020","title":"July 3, 2020","text":"<p>This version:</p> <ul> <li>Generalize the main halfedge mesh type to support nonmanifold meshes in routines where they make sense. The old <code>HalfedgeMesh</code> is now <code>ManifoldSurfaceMesh</code>, which is a subclass of the new more general <code>SurfaceMesh</code>, offering many of the same operations. The header <code>halfedge_mesh.h</code> typedef\u2019s <code>HalfedgeMesh</code> as <code>ManifoldSurfaceMesh</code> so existing code will mostly still work.</li> <li>Renamed <code>PolygonSoupMesh</code> to <code>SimplePolygonMesh</code>, and simplified some methods of this class. For now, the old type <code>PolygonSoupMesh</code> is typedef\u2019d to <code>SimplePolygonMesh</code>, and the header <code>polygon_soup_mesh.h</code> includes <code>simple_polygon_mesh.h</code> so existing code should work. Please use <code>SimplePolygonMesh</code> in any new code.</li> <li>Renamed <code>PlyHalfedgeMeshData</code> to <code>RichSurfaceMeshData</code>, and changed its workings to apply to more general meshes.</li> <li>Changed underlying storage of <code>MeshData&lt;&gt;</code> containers from <code>std::vector&lt;&gt;</code> to <code>Eigen::VectorX_</code>.</li> <li>Moved <code>halfedge_containers.h</code> to <code>utilities/mesh_data.h</code>, along with reorganizing various mesh element headers (you shouldn\u2019t need to include any of these headers in user code anyway, just including <code>surface_mesh.h</code> is sufficient)</li> </ul>"},{"location":"numerical/linear_algebra_utilities/","title":"Linear algebra utilities","text":""},{"location":"numerical/linear_algebra_utilities/#construct-and-convert","title":"Construct and convert","text":"<code>SparseMatrix&lt;T&gt; identityMatrix(size_t N)</code> <p>Construct and <code>N x N</code> identity matrix of the requested type.</p> <code>void shiftDiagonal(SparseMatrix&lt;T&gt;&amp; m, T shiftAmount = 1e-4)</code> <p>Shift the diagonal of matrix, by adding <code>A + shiftDiagonal * identityMatrix()</code>.</p> <code>SparseMatrix&lt;T&gt; verticalStack(const std::vector&lt;SparseMatrix&lt;T&gt;&gt;&amp; mats)</code> <p>Vertically stack sparse matrices like</p>  A,B,C \\to \\begin{bmatrix} A \\\\ B \\\\ C \\end{bmatrix}  <p>all matrices must have the same number of columns.</p> <p>Example: <pre><code>SparseMatrix&lt;double&gt; matA = /* 35 x N */\nSparseMatrix&lt;double&gt; matB = /* 10 x N */\nSparseMatrix&lt;double&gt; matC = /* 2 x N */\nSparseMatrix&lt;double&gt; stacked = verticalStack&lt;double&gt;({matA, matB, matC});\n</code></pre></p> <code>SparseMatrix&lt;T&gt; horizontalStack(const std::vector&lt;SparseMatrix&lt;T&gt;&gt;&amp; mats)</code> <p>Vertically stack sparse matrices like</p>  A,B,C \\to \\begin{bmatrix} A &amp; B &amp; C \\end{bmatrix}   A,B,C \\to \\begin{bmatrix} A &amp; B &amp; C \\end{bmatrix}  <p>all matrices must have the same number of rows..</p> <p>Example: <pre><code>SparseMatrix&lt;double&gt; matA = /* N x 35 */\nSparseMatrix&lt;double&gt; matB = /* N x 10 */\nSparseMatrix&lt;double&gt; matC = /* N x 2 */\nSparseMatrix&lt;double&gt; stacked = horizontalStack&lt;double&gt;({matA, matB, matC});\n</code></pre></p> <code>SparseMatrix&lt;double&gt; complexToReal(const SparseMatrix&lt;std::complex&lt;double&gt;&gt;&amp; m)</code> <p>Convert an <code>N x M</code> complex matrix to a <code>2N x 2M</code> real matrix, expanding each complex component in to a <code>2 x 2</code> block to evaluate the complex product.</p> <code>Vector&lt;double&gt; complexToReal(const Vector&lt;std::complex&lt;double&gt;&gt;&amp; v)</code> <p>Convert an length <code>N</code> complex vector to a length <code>2N</code> real vector, expanding each complex component in to consecutive real and imaginary components.</p>"},{"location":"numerical/linear_algebra_utilities/#validate-matrix-properties","title":"Validate matrix properties","text":"<code>void checkFinite(const Eigen::Matrix&lt;&gt;&amp; m)</code> <p>Verify that all entries in an matrix are finite, throwing if not. Defined for all Eigen matrix, vector, and sparse matrix types.</p> <code>void checkSymmetric(const Eigen::SparseMatrix&lt;&gt;&amp; m, double absoluteEPS=-1.)</code> <p>Verify that a matrix is symmetric, throwing if not. Defined for all Eigen sparse matrix types.</p> <p><code>absoluteEPS</code> is an epsilon to use for the element-wise comparison test. If the default value of <code>-1</code> is given, a reasonable epsilon is automatically computed from the matrix entries.</p> <code>void checkHermitian(const Eigen::SparseMatrix&lt;&gt;&amp; m, double absoluteEPS=-1.)</code> <p>Verify that a matrix is Hermitian, throwing if not. Defined for all Eigen sparse matrix types.</p> <p>For real matrices, identical to check symmetric.</p> <p><code>absoluteEPS</code> is an epsilon to use for the element-wise comparison test. If the default value of <code>-1</code> is given, a reasonable epsilon is automatically computed from the matrix entries.</p>"},{"location":"numerical/linear_algebra_utilities/#block-decomposition","title":"Block decomposition","text":"<p>These routines assist with decomposing a square matrix in to interleaved submatrix blocks, where the blocks might not necessarily be contiguous. One common usage is extracting boundary components of a finite element matrix to apply boundary conditions, as in the example below.</p> <p>Example usage: <pre><code>// Hypothetical input data\nSparseMatrix&lt;double&gt; mat = /* your square matrix */;\nsize_t N = mat.rows();\nsize_t NBoundary = /* ... */;\nVector&lt;double&gt; rhsVals = Vector&lt;double&gt;::Zero(N);        // rhs for the system\nVector&lt;double&gt; bcVals = Vector&lt;double&gt;::Ones(NBoundary); // boundary values at\n// some nodes\n\n// Build the membership vector, which indicates which entries should be separated\n// in to set \"A\" (others are in \"B\")\nVector&lt;bool&gt; setAMembership(N);\nfor(size_t i = 0; i &lt; N; i++) {\nif(/* element i is boundary */) {\nsetAMembership(i) = true;\n} else {\nsetAMembership(i) = false;\n}\n}\n\n// Construct the decomposition \nBlockDecompositionResult&lt;double&gt; decomp = blockDecomposeSquare(mat, setAMembership, true);\n\n// The four sub-blocks of the matrix are now in\n// decomp.AA, decomp.AB, decomp.BA, decomp.BB\n\n// Split up the rhs vector\nVector&lt;double&gt; rhsValsA, rhsValsB;\ndecomposeVector(decomp, rhsVals, rhsValsA, rhsValsB);\n\n// Solve problem\nVector&lt;double&gt; combinedRHS = rhsValsA - decomp.AB * bcVals;\nVector&lt;double&gt; Aresult = solve(decomp.AA, combinedRHS);\n\n// Combine the two boundary conditions and interior solution to a full vector\nVector&lt;double&gt; result = reassembleVector(decomp, Aresult, bcVals);\n</code></pre></p> <code>BlockDecompositionResult&lt;T&gt; blockDecomposeSquare(const SparseMatrix&lt;T&gt;&amp; m, const Vector&lt;bool&gt;&amp; Aset, bool buildBuildBside = true)</code> <p>Build a block decomposition of a matrix.</p> <code>void decomposeVector(BlockDecompositionResult&lt;T&gt;&amp; decomp, const Vector&lt;T&gt;&amp; vec, Vector&lt;T&gt;&amp; vecAOut, Vector&lt;T&gt;&amp; vecBOut)</code> <p>Use an existing block decomposition to partition a vector.</p> <code>Vector&lt;T&gt; reassembleVector(BlockDecompositionResult&lt;T&gt;&amp; decomp, const Vector&lt;T&gt;&amp; vecA, const Vector&lt;T&gt;&amp; vecB)</code> <p>Use an existing block decomposition to build a vector from partitioned pieces.</p>"},{"location":"numerical/linear_algebra_utilities/#saving-and-loading-matrices","title":"Saving and loading matrices","text":"<p>These routines save and load matrices from ASCII files.</p> <p>Example <pre><code>SparseMatrix&lt;double&gt; spMat = loadSparseMatrix&lt;double&gt;(sparseFilename);\nDenseMatrix&lt;int&gt; dMat = loadDenseMatrix&lt;int&gt;(denseFilename);\n\n/* do something with matrices */\n\nsaveSparseMatrix(newSparseFilename, spMat);\nsaveDenseMatrix(newDenseFilename, dMat);\n</code></pre></p>"},{"location":"numerical/linear_algebra_utilities/#sparse-matrices","title":"Sparse matrices","text":"<p>Sparse matrices are represented as ASCII files. Each line gives the row, column, and value of an entry in the matrix. The rows and columns are 1-indexed, following the matlab convention, and can be loaded into matlab via spconvert. Each file starts with a comment of the form <code># sparse rows cols</code> giving the matrix dimensions.</p> Sparse matrices are 1-indexed <p>Example file <pre><code># sparse 1858 1858\n1 1 3.969412682295582\n2 1 -1.010447934542366\n3 1 -0.5162236467210192\n...\n</code></pre></p> <code>void saveSparseMatrix(std::string filename, SparseMatrix&lt;T&gt;&amp; matrix);</code> <p>Writes <code>matrix</code> to the file <code>filename</code>.</p> <code>void saveSparseMatrix(std::ostream&amp; out, SparseMatrix&lt;T&gt;&amp; matrix);</code> <p>Writes <code>matrix</code> to the stream <code>out</code>.</p> <code>SparseMatrix&lt;T&gt; loadSparseMatrix(std::string filename);</code> <p>Read a sparse matrix from file <code>filename</code>.</p> <code>SparseMatrix&lt;T&gt; loadSparseMatrix(std::istream&amp; in);</code> <p>Read a sparse matrix from the stream <code>in</code>.</p>"},{"location":"numerical/linear_algebra_utilities/#dense-matrices","title":"Dense matrices","text":"<p>Dense matrices are represented as ASCII files with one row per matrix row. Each file starts with a comment of the form <code># dense rows cols</code> giving the matrix dimensions.</p> <p>Example file <pre><code># dense 1858 3\n-0.095724 -0.9734159999999999 -0.244313\n-0.105421 -0.984621 -0.301998\n-0.003629 -0.979971 -0.245996\n...\n</code></pre></p> <code>void saveDenseMatrix(std::string filename, DenseMatrix&lt;T&gt;&amp; matrix);</code> <p>Writes <code>matrix</code> to the file <code>filename</code>.</p> <code>void saveDenseMatrix(std::ostream&amp; out, DenseMatrix&lt;T&gt;&amp; matrix);</code> <p>Writes <code>matrix</code> to the stream <code>out</code>.</p> <code>DenseMatrix&lt;T&gt; loadDenseMatrix(std::string filename);</code> <p>Read a dense matrix from file <code>filename</code>.</p> <code>DenseMatrix&lt;T&gt; loadDenseMatrix(std::istream&amp; in);</code> <p>Read a dense matrix from the stream <code>in</code>.</p>"},{"location":"numerical/linear_solvers/","title":"Linear Solvers","text":"<p>This section covers the solvers available in geometry central for sparse linear algebra problems.</p> <p>All solvers support real and complex matrices, and can be templated on a <code>float</code>, <code>double</code>, or <code>std::complex&lt;double&gt;</code>.</p> <p><code>#include \"geometrycentral/numerical/linear_solvers.h\"</code></p>"},{"location":"numerical/linear_solvers/#direct-solvers","title":"Direct solvers","text":"<p>These solvers provide a simple interface for solving sparse linear Ax = b. </p> <p>A key feature is that these solvers abstract over the underlying numerical library. In their most basic form, Eigen\u2019s sparse solvers will be used, and are always available. However, if present, the more-powerful Suitesprase solvers will be used intead. See the dependencies section for instruction to build with Suitesparse support.</p> <p>As always, be sure to compile with optimizations (i.e. set <code>CMAKE_BUILD_TYPE</code> to <code>Release</code>) for meaningful performance. In particular, Eigen\u2019s built-in solvers will be very slow in debug mode (though the Eigen QR solver is always slow).</p>"},{"location":"numerical/linear_solvers/#quick-solves","title":"Quick solves","text":"<p>These are one-off routines for quick solves.</p> <code>Vector&lt;T&gt; solve(SparseMatrix&lt;T&gt;&amp; matrix, const Vector&lt;T&gt;&amp; rhs)</code> <p>Solve a system with a general matrix. Uses a QR decomposition interally.</p> <p>Warning: The Eigen built-in sparse QR solver is very inefficient for many problems. Also, it doesn\u2019t work well for underdetermined systems.</p> <code>Vector&lt;T&gt; solveSquare(SparseMatrix&lt;T&gt;&amp; matrix, const Vector&lt;T&gt;&amp; rhs)</code> <p>Solve a system with a square matrix. Uses an LU decomposition interally.</p> <code>Vector&lt;T&gt; solvePositiveDefinite(SparseMatrix&lt;T&gt;&amp; matrix, const Vector&lt;T&gt;&amp; rhs)</code> <p>Solve a system with a symmetric positive (semi-)definite matrix. Uses an LDLT decomposition interally.</p>"},{"location":"numerical/linear_solvers/#retain-factorizations","title":"Retain factorizations","text":"<p>When solving many linear systems Ax=bAx=b with the same matrix AA but different bb, it is dramatically more efficient to retain and reuse the factorization of AA. The following solver classes are stateful, storing the factorization to be re-used for may solves.</p> <pre><code>SparseMatrix&lt;double&gt; A = /* ... some matrix ... */;\n\n// Build the solver\nSolver&lt;double&gt; solver(A);\n\n// Solve a problem\nVector&lt;double&gt; rhs1 = /* ... */;\nVector&lt;double&gt; sol = solver.solve(rhs1);\n\n// Solve another problem\nVector&lt;double&gt; rhs2 = /* ... */;\nVector&lt;double&gt; sol2 = solver.solve(rhs2);\n\n// Can place solution in existing vector\nVector&lt;double&gt; rhs3 = /* ... */;\nsolver.solve(sol, rhs3);\n\n// Some solvers have extra powers.\n// Solver&lt;&gt; can compute matrix rank, since it uses QR under the hood.\nstd::cout &lt;&lt; \"matrix rank is \" &lt;&lt; solver.rank() &lt;&lt; std::endl;\n</code></pre> <code>template &lt;typename&lt;T&gt;&gt; class Solver</code> <p>Solve a system with a general matrix. Uses a QR decomposition interally.</p> <p>Supports methods:</p> <ul> <li><code>Sovler::Solver(SparseMatrix&lt;T&gt;&amp; mat)</code> construct from  a matrix</li> <li><code>Vector&lt;T&gt; Sovler::solve(const Vector&lt;T&gt;&amp; rhs)</code> solve and return result in new vector</li> <li><code>void Sovler::solve(Vector&lt;T&gt;&amp; result, const Vector&lt;T&gt;&amp; rhs)</code> solve and place result in existing vector</li> <li><code>size_t Sovler::rank()</code> report the rank of the matrix. Some solvers may give only an approximate rank.</li> </ul> <p>Warning: The Eigen built-in sparse QR solver is very inefficient for many problems. Also, it doesn\u2019t work well for underdetermined systems.</p> <code>template &lt;typename&lt;T&gt;&gt; class SquareSolver</code> <p>Solve a system with a square matrix. Uses an LU decomposition interally.</p> <p>Supports methods:</p> <ul> <li><code>SquareSovler::Solver(SparseMatrix&lt;T&gt;&amp; mat)</code> construct from  a matrix</li> <li><code>Vector&lt;T&gt; SquareSovler::solve(const Vector&lt;T&gt;&amp; rhs)</code> solve and return result in new vector</li> <li><code>void SquareSovler::solve(Vector&lt;T&gt;&amp; result, const Vector&lt;T&gt;&amp; rhs)</code> solve and place result in existing vector</li> </ul> <code>template &lt;typename&lt;T&gt;&gt; class PositiveDefiniteSolver</code> <p>Supports methods:</p> <ul> <li><code>PositiveDefiniteSolver::Solver(SparseMatrix&lt;T&gt;&amp; mat)</code> construct from  a matrix</li> <li><code>Vector&lt;T&gt; PositiveDefiniteSolver::solve(const Vector&lt;T&gt;&amp; rhs)</code> solve and return result in new vector</li> <li><code>void PositiveDefiniteSolver::solve(Vector&lt;T&gt;&amp; result, const Vector&lt;T&gt;&amp; rhs)</code> solve and place result in existing vector</li> </ul> <p>Solve a system with a symmetric positive (semi-)definite matrix. Uses an LDLT decomposition interally.</p>"},{"location":"numerical/linear_solvers/#eigenproblem-solvers","title":"Eigenproblem solvers","text":"<p>These routines build on top of the direct solvers to solve eigenvalue problems using power methods.</p> <code>Vector&lt;T&gt; smallestEigenvectorPositiveDefinite(SparseMatrix&lt;T&gt;&amp; energyMatrix, SparseMatrix&lt;T&gt;&amp; massMatrix, size_t nIterations = 50)</code> <p>Solves the eigenvector problem A x = \\lambda M xA x = \\lambda M x for the smallest-eigenvalue\u2019d nontrivial eigenvector xx of a positive definite sparse matrix AA.</p> <code>std::vector&lt;Vector&lt;T&gt;&gt; smallestKEigenvectorsPositiveDefinite(SparseMatrix&lt;T&gt;&amp; energyMatrix, SparseMatrix&lt;T&gt;&amp; massMatrix, size_t kEigenvalues, size_t nIterations = 50)</code> <p>Solves the eigenvector problem A x = \\lambda M xA x = \\lambda M x for the first kk smallest-eigenvalue\u2019d nontrivial eigenvectors xx of a positive definite sparse matrix AA.</p> <code>Vector&lt;T&gt; smallestEigenvectorSquare(SparseMatrix&lt;T&gt;&amp; energyMatrix, SparseMatrix&lt;T&gt;&amp; massMatrix, size_t nIterations = 50)</code> <p>Solves the eigenvector problem A x = \\lambda M xA x = \\lambda M x for the smallest-eigenvalue\u2019d nontrivial eigenvector xx of a square matrix AA.</p> <code>Vector&lt;T&gt; largestEigenvector(SparseMatrix&lt;T&gt;&amp; energyMatrix, SparseMatrix&lt;T&gt;&amp; massMatrix, size_t nIterations = 50)</code> <p>Solves the eigenvector problem A x = \\lambda M xA x = \\lambda M x for the largest-eigenvalue\u2019d nontrivial eigenvector xx of a square matrix AA.</p>"},{"location":"numerical/linear_solvers/#utilities","title":"Utilities","text":"<code>double residual(const SparseMatrix&lt;T&gt;&amp; matrix, const Vector&lt;T&gt;&amp; lhs, const Vector&lt;T&gt;&amp; rhs)</code> <p>Measure the L2 residual of a linear system as ||Ax - b||_2||Ax - b||_2.</p>"},{"location":"numerical/matrix_types/","title":"Matrix Types","text":""},{"location":"numerical/matrix_types/#eigen","title":"Eigen","text":"<p>Generally, geometry central uses Eigen for all matrix types. Though we build additional solvers and utilities on top of Eigen.  See the Eigen section of dependencies for instructions about getting Eigen and integrating with existing build systems.</p> <p>Note that the Vector2 and Vector3 low-dimensional scalar types are entirely separate from these high-dimensional linear algebra types; <code>Vector2</code> and <code>Vector3</code> do not use Eigen, and they cannot participate in arithmetic expressions with Eigen types.</p> <p>Two typedefs are used extensively throughout geometry central to make the default Eigen types slightly less verbose. Both are defined in <code>linear_algebra_utilities.h</code>.</p> <p><code>#include \"geometrycentral/numerical/linear_algebra_utilities.h\"</code></p> <code>Vector&lt;T&gt;</code> <p>A templated vector typedef, to Eigen\u2019s vector type. <pre><code>template &lt;typename T&gt;\nusing Vector = Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt;;\n</code></pre></p> <p>Use like <code>Vector&lt;double&gt;</code> or <code>Vector&lt;bool&gt;</code>.</p> <code>SparseMatrix&lt;T&gt;</code> <p>A templated sparse matrix typedef, to Eigen\u2019s sparse matrix type. <pre><code>template &lt;typename T&gt;\nusing SparseMatrix = Eigen::SparseMatrix&lt;T&gt;;\n</code></pre></p> <p>Use like <code>SparseMatrix&lt;double&gt;</code> or <code>SparseMatrix&lt;int&gt;</code>.</p>"},{"location":"numerical/matrix_types/#gotchas","title":"Gotchas","text":"<p>Be wary, Eigen\u2019s alignment rules make it efficient, but also impose requirements which can lead to hard-to-debug memory errors. A few particularly common pitfalls are:</p> <ul> <li> <p>Avoid intermingling different versions of Eigen in the same program. Suppose some part of you codebase uses one version of Eigen, and a dependency uses a different version. Linking a function which returns an Eigen vector between these versions can lead to segfaults, because different alignment policies were used. </p> </li> <li> <p>Similar to the previous, linking Eigen programs compiled with different preprocessor directives and optimization flags can yield binary incompatibility. Be sure that all parts of your codebase using Eigen receive the same build options.</p> </li> <li> <p>Fixed-sized Eigen types (like <code>Eigen::Vector4d</code>, but not our <code>Vector&lt;T&gt;</code> or <code>SparseMatrix&lt;T&gt;</code>) may not be passed by value to functions. The same applies transitively to classes which have Eigen types as members. See this (opinionated) note.</p> </li> </ul>"},{"location":"pointcloud/basics/","title":"Basics","text":"<p>The <code>PointCloud</code> class is the main data structure for representing point clouds in geometry-central. It mimics the design of <code>SurfaceMesh</code> for the sake of consistency, though it is generally much simpler. The <code>PointCloud</code> class is simply a logical object referring to an abstract collection of points.  Geometric data (aka point positions) are stored separately in the <code>PointPositionGeometry</code> class (or related subclasses).</p> <p><code>#include \"geometrycentral/pointcloud/point_cloud.h\"</code></p> <p>Point clouds are in beta</p> <p>The current point cloud API in geometry-central is preliminary, and may change in future versions.</p> <p>Example: A tour of basic point cloud functionality. <pre><code>#include \"geometrycentral/pointcloud/point_cloud.h\"\n#include \"geometrycentral/pointcloud/point_position_geometry.h\"\n\nsize_t nPts = 5000;\n\n// create a new cloud\nPointCloud cloud(nPts); // access properties of the cloud\nstd::cout &lt;&lt; \"cloud has \" &lt;&lt; cloud.nPoints() &lt;&lt; \" points.\\n\";\n// Prints \"cloud has 5000 points\"\n\n// iterate through the points in the cloud\nfor(Point p : cloud.points()) {\nstd::cout &lt;&lt; \"Hi, I'm point \" &lt;&lt; p &lt;&lt; \"\\n\";\n// Prints \"Hi, I'm point p_245\" (etc)\n}\n\n// store data on a point cloud\nPointData&lt;int&gt; values(cloud);\nfor(Point p : cloud.points()) {\nvalues[p] = 7;\n}\n\n// associate 3D positions with the point cloud\n// compute geometric data using the geomety object\nPointData&lt;Vector3&gt; positions = /* some positions */;\nPointPositionGeometry geom(*cloud, positions);\n\n// for example, compute normals\ngeom.requireNormals();\nfor(Point p : cloud.points()) {\nstd::cout &lt;&lt; \"normal for point \" &lt;&lt; p &lt;&lt; \" is \" &lt;&lt; geom.normals[p] &lt;&lt; \"\\n\";\n}\n</code></pre></p> <code>PointCloud::PointCloud(size_t nPts)</code> <p>Constructs a new point cloud with the desired number of points.</p> <p>See the IO routines for higher-level constructors to simultaneously construct a point cloud and its geometry, or read from file, etc.</p> <code>/*iterator type*/ PointCloud::points()</code> <p>Iterate through the points in a point cloud, like</p> <pre><code>for(Point p : cloud.points()) {\n// do science\n}\n</code></pre> <code>Point PointCloud::point(size_t iP)</code> <p>Return a handle to the i\u2019th point.</p> <code>size_t PointCloud::nPoints() const</code> <p>Returns the number of points. </p> <code>std::unique_ptr&lt;PointCloud&gt; PointCloud::copy() const</code> <p>Returns the number of points. </p> <p>Mutating point clouds</p> <p>TODO The <code>PointCloud</code> class contains the groundwork for efficiently adding/removing points from the cloud while updating containers (etc) similar to <code>SurfaceMesh</code>. However, this functionality is not fleshed out, tested, or documented yet.</p>"},{"location":"pointcloud/geometry/","title":"Geometry","text":"<p>The geometry classes associates 3D positions with the points in a point cloud, and can compute various derived quantities.  These use the same paradigm of \u201crequiring quantities\u201d as the surface mesh geometry interface, see additional documentation there.  </p> <p><code>#include \"geometrycentral/pointcloud/point_position_geometry.h\"</code></p> <p>Point clouds are in beta</p> <p>The current point cloud API in geometry-central is preliminary, and may change in future versions.</p> <p>The geometry classes manage buffers of geometric quantities which can be computed, as well as a dependency graph relationship between these quantities. For instance, calling <code>geom.requireNormals()</code> will ensure the <code>geom.normals</code> buffer is populated with normals, additionally computing &amp; caching any preceding quantities which are needed (here: neighborhoods).  Derived classes can be used to extend with more features, specify additional input data, or override the computation of particular quantities.</p> <p>Example: Basic use of quantities <pre><code>#include \"geometrycentral/pointcloud/point_cloud.h\"\n#include \"geometrycentral/pointcloud/point_position_geometry.h\"\n\n// create a new cloud &amp; geometry object\nsize_t nPts = 5000;\nPointCloud cloud(nPts); PointData&lt;Vector3&gt; positions = /* some positions */;\nPointPositionGeometry geom(*cloud, positions);\n\n// Per-point normals\ngeom.requireNormals();\nfor(Point p : cloud.points()) {\nstd::cout &lt;&lt; \"normal for point \" &lt;&lt; p &lt;&lt; \" is \" &lt;&lt; geom.normals[p] &lt;&lt; \"\\n\";\n}\n\n// Point cloud Laplace matrix \ngeom.requireLaplacian();\nEigen::SparseMatrix&lt;double&gt; L = geom.laplacian;\n</code></pre></p>"},{"location":"pointcloud/geometry/#point-position-geometry","title":"Point Position Geometry","text":"<p>This is the most basic core geometry, corresponding to a 3D position associated with each vertex.</p> <p>Remember, for each quantity YYY, call <code>requireYYY()</code> to ensure it has been computed, then access it at <code>geom.YYYs</code>.</p>"},{"location":"pointcloud/geometry/#construction","title":"Construction","text":"<code>PointPositionGeometry::PointPositionGeometry(PointCloud&amp; cloud)</code> <p>Constructs a new unitialized point position geometry on the cloud.</p> <p>You should immediately set positions like</p> <pre><code>PointPositionGeometry goem(*cloud);\nfor(Point p : cloud-&gt;points()) {\ngeom.positions[p] = /* some Vector3 position */;\n}\n</code></pre> <code>PointPositionGeometry::PointPositionGeometry(PointCloud&amp; cloud, const PointData&lt;Vector3&gt;&amp; positions)</code> <p>Constructs a new point position geometry with specified positions.</p> <p>The given positions will be copied to the <code>geom.positions</code> field.</p>"},{"location":"pointcloud/geometry/#quantities","title":"Quantities","text":"neighbors normals tangent basis neighborhood tangent coordinates neighborhood tangent transport tufted triangulation Laplacian connection Laplacian gradient"},{"location":"pointcloud/geometry/#neighbors","title":"neighbors","text":"<p>A collection of <code>k</code>-nearest neighbors for each point. Represented via a <code>Neighborhoods</code> object, which encapsulates the functionality.</p> <p>Set the number of neighbors by assigning to <code>PointPositionGeometry::kNeighborSize</code>. The default is 30. If you\u2019re going to change it, do so before requiring any quantities that involve neighbors (most of them).</p> <p>Iterate over neighbors like:</p> <pre><code>geom.requireNeighbors();\nfor (Point p : cloud-&gt;points()) {\nstd::vector&lt;Point&gt;&amp; neigh = geom.neighbors-&gt;neighbors[p];\nsize_t M = neigh.size();\nfor (size_t iN = 0; iN &lt; M; iN++) {\nPoint pN = neigh[iN];\nstd::cout &lt;&lt; \"Point \" &lt;&lt; p &lt;&lt; \" has neighbor \" &lt;&lt; pN &lt;&lt; std::endl;\n}\n}\n</code></pre> <ul> <li>member: <code>std::unique_ptr&lt;Neighborhoods&gt; PointPositionGeometry::neighbors</code></li> <li>require: <code>void PointPositionGeometry::requireNeighbors()</code></li> </ul> <p>Changes coming</p> <p>A future update will replace this nested <code>std::vector&lt;&gt;</code> interface with a flat list and fancy iterators.</p>"},{"location":"pointcloud/geometry/#normals","title":"normals","text":"<p>A 3D unit normal at each point.</p> <p>Normals are comptuted via PCA over neighbors. By default, nothing is done to orient normals, so orientations will be arbitrary.</p> <ul> <li>member: <code>PointData&lt;Vector3&gt; PointPositionGeometry::normals</code></li> <li>require: <code>void PointPositionGeometry::requireNormals()</code></li> </ul>"},{"location":"pointcloud/geometry/#tangent-basis","title":"tangent basis","text":"<p>A pair of X-Y tangent basis axes at each point. Guaranteed to form an orthonormal right-handed coordinate frame with the normal vector.</p> <ul> <li>member: <code>PointData&lt;std::array&lt;Vector3,2&gt;&gt; PointPositionGeometry::tangentBasis</code></li> <li>require: <code>void PointPositionGeometry::requireTangentBasis()</code></li> </ul>"},{"location":"pointcloud/geometry/#tangent-coordinates","title":"tangent coordinates","text":"<p>Local 2D tangent coordinates associated with each neighboring point, corresponding to projection in to the axes in <code>geom.tangentBasis</code>.</p> <ul> <li>member: <code>PointData&lt;std::vector&lt;Vector2&gt;&gt; PointPositionGeometry::tangentCoordinates</code></li> <li>require: <code>void PointPositionGeometry::requireTangentCoordinates()</code></li> </ul>"},{"location":"pointcloud/geometry/#tangent-transport","title":"tangent transport","text":"<p>Parallel transport coefficients to rotate tangent vectors between neighboring frames.<code>tangentTransport[i][j]</code> holds the rotation which maps a vector in the tangent space of i to that of j.</p> <ul> <li>member: <code>PointData&lt;std::vector&lt;Vector2&gt;&gt; PointPositionGeometry::tangentTransport</code></li> <li>require: <code>void PointPositionGeometry::requireTangentTransport()</code></li> </ul>"},{"location":"pointcloud/geometry/#tufted-triangulation","title":"tufted triangulation","text":"<p>A tufted intrinsic triangulation associated with the point cloud. Intuitively this is a special triangulation atop the points in the pointcloud, represented only by its connectivity and edge lengths. It is a very effective numerical data structure to compute downstream quantities, like a highly-quality Laplace matrix. To be clear, this is not a \u201cnice\u201d triangulation like you might get from 3D reconstruction; instead it is a crazy nonmanifold triangulation which happens to have a very useful structure for subsequent numerical computations.  See the publication \u201cA Laplacian for Nonmanifold Triangle Meshes\u201d for formal details.</p> <p>Intuitively, </p> <ul> <li>member: <code>PointData&lt;std::unique_ptr&lt;surface::SurfaceMesh&gt;&gt; PointPositionGeometry::tuftedMesh</code></li> <li>member: <code>PointData&lt;std::unique_ptr&lt;surface::EdgeLengthGeometry&gt;&gt; PointPositionGeometry::tuftedGeom</code></li> <li>require: <code>void PointPositionGeometry::requireTuftedTriangulation()</code></li> </ul>"},{"location":"pointcloud/geometry/#laplacian","title":"Laplacian","text":"<p>A Laplace matrix for the point cloud. Computed internally using the tufted triangulation as described in A Laplacian for Nonmanifold Triangle Meshes\u201d.</p> <ul> <li>member: <code>Eigen::SparseMatrix&lt;double&gt; PointPositionGeometry::laplacian</code></li> <li>require: <code>void PointPositionGeometry::requireLaplacian()</code></li> </ul>"},{"location":"pointcloud/geometry/#connection-laplacian","title":"connection Laplacian","text":"<p>A connection Laplace matrix for the point cloud, which is similar to normal scalar Laplacian, but operates on tangent vectors at each point rather than on scalar values. See \u201cThe Vector Heat Method\u201d for a detailed introduction to connection Laplacians.</p> <p>Note: This connection Laplacian includes an orientation flip to handle inconsistent normals. Rather than a complex matrix, it builds a <code>2N x 2N</code> expanded real matrix, with sign flips on imaginary elements to conjugate (a necessary trick, because conjugation is not a complex-linear operation). This allows us to apply the connection even when normal orientations are inconsistent.</p> <ul> <li>member: <code>Eigen::SparseMatrix&lt;double&gt; PointPositionGeometry::connectionLaplacian</code></li> <li>require: <code>void PointPositionGeometry::requireConnectionLaplacian()</code></li> </ul>"},{"location":"pointcloud/geometry/#gradient","title":"gradient","text":"<p>A gradient operator <code>G</code> for the point cloud. Given a vector <code>v</code> of scalar values at each point in the point cloud, multiplying <code>G*v</code> yields a tanget vector at each point (as a complex number), representing the spatial gradient of <code>v</code> at that point.</p> <p>Constructed via a least-squares approximation in the neighborhood tangent coordinate space at each point.</p> <ul> <li>member: <code>Eigen::SparseMatrix&lt;std::complex&lt;double&gt;&gt; PointPositionGeometry::gradient</code></li> <li>require: <code>void PointPositionGeometry::requireGradient()</code></li> </ul>"},{"location":"pointcloud/geometry/#point-position-normal-geometry","title":"Point Position &amp; Normal Geometry","text":"<p>The class <code>PointPositionNormalGeometry</code> extends the basic <code>PointPositionGeometry</code> class to manually specify a set of known normals at points. These normals will be used for all computations, rather than computing normals from scratch.</p> <p>The <code>PointPositionNormalGeometry</code> is-a <code>PointPositionGeometry</code> via inheritance, so you can directly pass it anywhere a <code>PointPositionGeometry</code> is expected.</p> <p><code>#include \"geometrycentral/pointcloud/point_position_normal_geometry.h\"</code></p> <p>Example: <pre><code>std::unique_ptr&lt;PointCloud&gt; cloud; // your cloud\nPointData&lt;Vector3&gt; positions(*cloud); // populate with your positions\nPointData&lt;Vector3&gt; knownNormals(*cloud); // populate with your normals\n\nPointPositionNormalGeometry geom(*cloud, positions, knownNormals);\n\n// we can now use this just like a `PointPositionGeometry` as above\n</code></pre></p> <code>PointPositionNormalGeometry::PointPositionNormalGeometry(PointCloud&amp; cloud, const PointData&lt;Vector3&gt;&amp; positions, const PointData&lt;Vector3&gt;&amp; normals)</code> <p>Constructs a new point position geometry with specified normals.</p> <p>The given normals will be copied to the <code>geom.normals</code> field.</p>"},{"location":"pointcloud/geometry/#point-position-tangent-basis-geometry","title":"Point Position &amp; Tangent Basis Geometry","text":"<p>The class <code>PointPositionFrameGeometry</code> extends the basic <code>PointPositionGeometry</code> class to manually specify a set of known normals and tangent frames at points. These frames / normals will be used for all computations, rather than computing frames / normals from scratch.</p> <p>The input frames are specified via three vectors at each point <code>std::array&lt;Vector3, 3&gt;</code>. These vectors should form a right-handed, orthonormal basis at each vertex, with the two vectors forming the X/Y tangent basis, and the third as the normal direction.</p> <p>The <code>PointPositionFrameGeometry</code> is-a <code>PointPositionGeometry</code> via inheritance, so you can directly pass it anywhere a <code>PointPositionGeometry</code> is expected.</p> <p><code>#include \"geometrycentral/pointcloud/point_position_frame_geometry.h\"</code></p> <p>Example: <pre><code>std::unique_ptr&lt;PointCloud&gt; cloud; // your cloud\nPointData&lt;Vector3&gt; positions(*cloud); // populate with your positions\n// your {tangent-X, tangent-Y, normal} at each vertex\nPointData&lt;std::array&lt;Vector3, 3&gt;&gt; knownFrames(*cloud); PointPositionFrameGeometrygeom(*cloud, positions, knownNormals);\n\n// we can now use this just like a `PointPositionGeometry` as above\n</code></pre></p> <code>PointPositionFrameGeometry::PointPositionFrameGeometry(PointCloud&amp; cloud, const PointData&lt;Vector3&gt;&amp; positions, const PointData&lt;std::array&lt;Vector3, 3&gt;&gt;&amp; frames)</code> <p>Constructs a new point position geometry with specified normals.</p> <p>The given tangent bases and normals will be copied to the <code>geom.normals</code> and <code>geom.tangentBasis</code> fields.</p>"},{"location":"pointcloud/algorithms/heat_solver/","title":"Heat distance, transport, &amp; logarithmic map on point clouds","text":"<p>Compute geodesic distance, transport tangent vectors, and generate a special parameterization called the logarithmic map using fast solvers based on short-time heat flow.</p> <p></p> <p>These routines implement point cloud versions of the algorithms from:</p> <ul> <li>The Heat Method for Distance Computation (distance)</li> <li>The Vector Heat Method (parallel transport and log map)</li> <li>A Laplacian for Nonmanifold Triangle Meshes (used to build point cloud Laplacian for both)</li> </ul> <p>All computation is encapsulated by the <code>PointCloudHeatSolver</code> class, which maintains prefactored linear systems for the various methods. Some setup work is performed both on construction, and after the first query. Subsequent queries, even with different source points, will be fast.</p> <p><code>#include \"geometrycentral/pointcloud/point_cloud_heat_solver.h\"</code></p> <p>Example: Basic usage</p> <pre><code>#include \"geometrycentral/pointcloud/point_cloud.h\"\n#include \"geometrycentral/pointcloud/point_position_geometry.h\"\n#include \"geometrycentral/pointcloud/point_cloud_heat_solver.h\"\n#include \"geometrycentral/pointcloud/point_cloud_io.h\"\n\nusing namespace geometrycentral;\nusing namespace geometrycentral::pointcloud;\n\n// Read in a point cloud\nstd::unique_ptr&lt;PointCloud&gt; cloud;\nstd::unique_ptr&lt;PointPositionGeometry&gt; geom;\nstd::tie(cloud, geom) = readPointCloud(\"my_cloud.ply\");\n\n// Create the solver\nPointCloudHeatSolver solver(*cloud, *geom);\n\n// Pick a source point or two\nPoint pSource = cloud-&gt;point(7);\nPoint pSource2 = cloud-&gt;point(8);\n\n// Compute geodesic distance\nPointData&lt;double&gt; distance = solver.computeDistance(pSource);\n\n// Compute scalar extension\nPointData&lt;double&gt; extended = solver.extendScalars({{pSource,  3.},\n{pSource2, -5.}});\n\n// Compute parallel transport\nVector2 sourceVec{1, 2};\nPointData&lt;Vector2&gt; transport = solver.transportTangentVector(pSource, sourceVec);\n\n// Compute the logarithmic map\nPointData&lt;Vector2&gt; logmap = solver.computeLogMap(pSource);\n</code></pre>"},{"location":"pointcloud/algorithms/heat_solver/#constructor","title":"Constructor","text":"<code>PointCloudHeatSolver::PointCloudHeatSolver(PointCloud&amp; cloud, PointPositionGeometry&amp; geom, double tCoef = 1.0)</code> <p>Create a new solver for the heat methods. Precomputation is performed at startup and lazily as needed.</p> <ul> <li><code>cloud</code> is the point cloud to operate on.</li> <li> <p><code>geom</code> is the geometry (e.g., vertex positions) for the cloud. Note that nearly any point cloud geometry object can be passed here. For instance, use a <code>PointPositionFrameGeometry</code> if you want to represent tangent-valued data in tangent bases of your own choosing.</p> </li> <li> <p><code>tCoef</code> is the time to use for short time heat flow, as a factor <code>m * h^2</code>, where <code>h</code> is the mean between-point spacing. The default value of <code>1.0</code> is almost always sufficient.</p> </li> </ul> <p>Algorithm options (like <code>tCoef</code>) cannot be changed after construction; create a new solver object with the new settings.</p>"},{"location":"pointcloud/algorithms/heat_solver/#geodesic-distance","title":"Geodesic distance","text":"<p>Geodesic distance is the distance from a given source along the surface represented by the point cloud. Specifying multiple source points yields the distance to the nearest source.</p> <code>PointData&lt;double&gt; PointCloudHeatSolver::computeDistance(const Point&amp; sourcePoint)</code> <p>Compute the geodesic distance from <code>sourcePoint</code> to all other points.</p> <code>PointData&lt;double&gt; PointCloudHeatSolver::computeDistance(const std::vector&lt;Point&gt;&amp; sourcePoints)</code> <p>Like above, but for multiple source points.</p>"},{"location":"pointcloud/algorithms/heat_solver/#scalar-extension","title":"Scalar extension","text":"<p>Given scalar values defined at isolated points in the cloud, extend it to a scalar field on all points. Each point will take the value from the nearest source point, in the sense of geodesic distance. Note that the fast diffusion algorithm means the result is a slightly smoothed-out field.</p> <code>PointData&lt;double&gt; PointCloudHeatSolver::extendScalars(const std::vector&lt;std::tuple&lt;Point, double&gt;&gt;&amp; sources)</code> <p>Given a collection of source points and scalars at those points, extends the scalar field to the whole cloud as a nearest-geodesic-neighbor interpolant.</p>"},{"location":"pointcloud/algorithms/heat_solver/#vector-extension","title":"Vector extension","text":"<p>Given tangent vectors defined at one or more isolated source locations on a surface, extend transport the vectors across the entire domain according to parallel transport. Each point on the domain will take the value of the nearest source point.  Note that the fast diffusion algorithm means the result is a slightly smoothed-out field.</p> <p>Despite operating on tangent-valued data, these routines work as expected even on a point cloud with inconsistent normal orientations. See connection Laplacian for more details.</p> <code>PointData&lt;Vector2&gt; PointCloudHeatSolver::transportTangentVector(const Point&amp; sourcePoint, const Vector2&amp; sourceVector)</code> <p>Shorthand for the general version below when there is just one vector.</p> <p>Computes parallel transport of the given vector along shortest geodesics to the rest of the cloud.</p> <p>Polar directions are defined in each point\u2019s tangent space. See <code>PointPositionGeometry::tangentBasis</code>.</p> <code>PointData&lt;Vector2&gt; PointCloudHeatSolver::transportTangentVectors(const std::vector&lt;std::tuple&lt;Point, Vector2&gt;&gt;&amp; sources)</code> <p>Given a collection of source points and tangent vectors at those points, extends the vector field to the whole cloud as a nearest-geodesic-neighbor interpolant via parallel transport along shortest geodesics.</p> <p>Polar directions are defined in each point\u2019s tangent space. See <code>PointPositionGeometry::tangentBasis</code>.</p>"},{"location":"pointcloud/algorithms/heat_solver/#logarithmic-map","title":"Logarithmic Map","text":"<p>The logarithmic map is a very special 2D local parameterization of a surface about a point, where for each point on the surface the magnitude of the log map gives the geodesic distance from the source, and the polar coordinate of the log map gives the direction at which a geodesic must leave the source to arrive at the point.</p> <p>Despite operating on tangent-valued data, this routine works as expected even on a point cloud with inconsistent normal orientations. See connection Laplacian for more details.</p> <code>PointData&lt;Vector2&gt; PointCloudHeatSolver::computeLogMap(const Point&amp; sourcePoint)</code> <p>Computes the logarithmic map from the given source point.</p> <p>Polar directions are defined in each point\u2019s tangent space. See <code>PointPositionGeometry::tangentBasis</code>.</p>"},{"location":"pointcloud/utilities/io/","title":"Input &amp; Output","text":"<p>Some basic input/output routines for point clouds.</p>"},{"location":"pointcloud/utilities/io/#input","title":"Input","text":"<p>Example: Read in a point cloud.</p> <pre><code>#include \"geometrycentral/pointcloud/point_cloud.h\"\n#include \"geometrycentral/pointcloud/point_position_geometry.h\"\n#include \"geometrycentral/pointcloud/point_cloud_io.h\"\n\nusing namespace geometrycentral;\nusing namespace geometrycentral::pointcloud;\n\nstd::unique_ptr&lt;PointCloud&gt; cloud;\nstd::unique_ptr&lt;PointPositionGeometry&gt; geom;\nstd::tie(cloud, geom) = readPointCloud(\"my_cloud.ply\");\n\n// do science!\n</code></pre> <code>std::tuple&lt;std::unique_ptr&lt;PointCloud&gt;, std::unique_ptr&lt;PointPositionGeometry&gt;&gt; readPointCloud(std::string filename, std::string type = \"\")</code> <p>Read a point cloud from file, constructing both the cloud and geometry objects.</p> <p>Currently accepted file types: <code>ply</code>, <code>obj</code>. Using the default empty type string will attempt to infer from the filename.</p> <code>std::tuple&lt;std::unique_ptr&lt;PointCloud&gt;, std::unique_ptr&lt;PointPositionGeometry&gt;&gt; readPointCloud(std::istream&amp; in, std::string type)</code> <p>Like above, but reads directly from an <code>istream</code>. The type must be specified explicitly.</p>"},{"location":"pointcloud/utilities/io/#output","title":"Output","text":"<p>Example: Write out a point cloud.</p> <pre><code>#include \"geometrycentral/pointcloud/point_cloud.h\"\n#include \"geometrycentral/pointcloud/point_position_geometry.h\"\n#include \"geometrycentral/pointcloud/point_cloud_io.h\"\n\nusing namespace geometrycentral;\nusing namespace geometrycentral::pointcloud;\n\n// your cloud &amp; point positions, populated somehow\nstd::unique_ptr&lt;PointCloud&gt; cloud;\nstd::unique_ptr&lt;PointPositionGeometry&gt; geom;\n\nwritePointCloud(*cloud, *geom, \"cloud_out.ply\");\n</code></pre> <code>void writePointCloud(PointCloud&amp; cloud, PointPositionGeometry&amp; geometry, std::string filename, std::string type = \"\")</code> <p>Write a point cloud to file.</p> <p>Currently accepted file types: <code>ply</code>, <code>obj</code>. Using the default empty type string will attempt to infer from the filename.</p> <code>void writePointCloud(PointCloud&amp; cloud, PointPositionGeometry&amp; geometry, std::ostream&amp; out, std::string type)</code> <p>Like above, but writes directly to an <code>ostream</code>. The type must be specified explicitly.</p>"},{"location":"pointcloud/utilities/sampling/","title":"Sampling","text":"<p>Sample random point clouds from triangle meshes.</p> <p>Example: Read a triangle mesh from file and uniformly sample points <pre><code>#include \"geometrycentral/pointcloud/point_cloud.h\"\n#include \"geometrycentral/pointcloud/point_position_geometry.h\"\n#include \"geometrycentral/pointcloud/point_cloud_io.h\"\n#include \"geometrycentral/pointcloud/point_cloud.h\"\n#include \"geometrycentral/surface/meshio.h\"\n\nusing namespace geometrycentral;\nusing namespace geometrycentral::surface;\nusing namespace geometrycentral::pointcloud;\n\n// Load a mesh\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; meshGeom;\nstd::tie(mesh, meshGeom) = loadMesh(args::get(inputFilename));\n\n// Sample a point cloud from the mesh\nstd::unique_ptr&lt;PointCloud&gt; cloud;\nPointData&lt;Vector3&gt; pointPos;\nPointData&lt;SurfacePoint&gt; cloudSources;\nsize_t nPts = 5000;\nstd::tie(cloud, pointPos, cloudSources) = uniformlySamplePointsOnSurface(*mesh, *meshGeom, nPts);\n\n// As an example, use the source points to get face normals\nPointData&lt;Vector3&gt; normals(*cloud);\nmeshGeom-&gt;requireFaceNormals();\nfor (Point p : cloud-&gt;points()) {\nnormals[p] = meshGeom-&gt;faceNormals[cloudSources[p].face];\n}\n\n// Construct a geometry object from the positions for subsequent calculations\nPointPositionGeometry cloudGeom(*cloud, pointPos);\n</code></pre></p> <code>std::tuple&lt;std::unique_ptr&lt;PointCloud&gt;, PointData&lt;Vector3&gt;, PointData&lt;surface::SurfacePoint&gt;&gt; uniformlySamplePointsOnSurface(surface::SurfaceMesh&amp; mesh, surface::EmbeddedGeometryInterface&amp; geom, size_t nPts)</code> <p>Sample <code>nPts</code> points from a triangle mesh. Points are sampled uniformly at random from the underlying surface, independent of tesselation.</p> <p>The return tuple holds:</p> <ul> <li>The new <code>PointCloud</code></li> <li>A 3D position for each point</li> <li>A <code>SurfacePoint</code> on the original mesh corresponding to each point</li> </ul> <p>Note that in addition to the cloud and 3D positions, this routine returns a <code>SurfacePoint</code> associated with each point sample. The surface point is a handy class representing a location on the underlying mesh, and makes it easy to do things like interpolate data defined on the source mesh, or grab face normals, etc.</p>"},{"location":"surface/algorithms/direction_fields/","title":"Direction Fields","text":"<p>This section describes routines for computing n-direction fields on a surface. An n-direction field on a surface assigns n evenly-spaced unit tangent vectors to each point on the surface. For example, a 1-direction field is an ordinary direction field, a 2-direction field is a line field, and a 4-direction field is a cross field.</p> <p></p> <p>Most of these routines only depend on the intrinsic geometry of a surface (via the <code>IntrinsicGeometryInterface</code>). Therefore, you can run them on abstract geometric domains as well as traditional surfaces in 3D. However, a surface\u2019s principal curvatures depend on the extrinsic geometry, so you can only compute curvature-aligned fields for surfaces in 3D.</p> <p><code>#include \"geometrycentral/surface/direction_fields.h\"</code></p> How to interpret our symmetric direction fields"},{"location":"surface/algorithms/direction_fields/#interpreting-symmetric-direction-fields","title":"Interpreting symmetric direction fields","text":"<p>In geometry-central we use a \u201cpower\u201d representation for symmetric vector fields (e.g. lines and cross fields, when <code>n &gt; 1</code> in the below algorithms). </p> <p>For instance, in the case of cross fields <code>n=4</code>, there are four different tangent vectors at each point giving the resulting cross v_0, v_1, v_2, v_3. Rather than outputting any one of these vectors, we output a vector raised to the 4th power (where exponentiation is defined in the sense of complex numbers) v = v_0^4 = v_1^4 = v_2^4 = v_3^4v = v_0^4 = v_1^4 = v_2^4 = v_3^4.  This representation makes sense, because after raising to the 4th power maps each of these four cross vectors to the same representative vector.</p> <p>How do I get the cross/line/etc directions?</p> <p>Concretely, to get out the four tangent direction vectors for a cross fields, one could do something like:</p> <pre><code>// Compute a cross field\nint n = 4; VertexData&lt;Vector2&gt; crossValues = computeSmoothestVertexDirectionField(*geometry, n);\n\nfor(Vertex v : mesh-&gt;vertices()) {\n\nVector2 representative = crossValues[v];\nVector2 crossDir = crossDir.pow(representative, 1. / n); // take the n'th root\n\n// loop over the four directions\nfor(int rot = 0; rot &lt; 4; rot++) {\n// crossDir is one of the four cross directions, as a tangent vector\ncrossDir = crossDir.rot90();\n}\n}\n\n(and the same applies when `n = 2` for line fields, etc)\n</code></pre>"},{"location":"surface/algorithms/direction_fields/#smoothest-direction-fields","title":"Smoothest Direction Fields","text":"<p>These routines compute the smoothest possible n-direction field on the input surface. They place singularities automatically. If you need to find out where the singularities are, refer to the Index Computation section below.</p> <p>The two routines are almost identical. The only difference is that one discretizes direction fields using vectors at vertices, and the other uses vectors on faces.</p> <p>Example <pre><code>#include \"geometrycentral/surface/direction_fields.h\"\n#include \"geometrycentral/surface/meshio.h\"\nusing namespace geometrycentral;\nusing namespace surface;\n\n// Load a mesh\nstd::unique_ptr&lt;ManifoldSurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = loadMesh(filename);\n\n// Compute a smooth direction field on vertices\nVertexData&lt;Vector2&gt; directions = computeSmoothestVertexDirectionField(*geometry);\n/* do something useful */\n</code></pre></p> <code>VertexData&lt;Vector2&gt; computeSmoothestVertexDirectionField(IntrinsicGeometryInterface&amp; geometry, int nSym = 1)</code> <p>Compute the smoothest n-direction field on the input surface.</p> <code>FaceData&lt;Vector2&gt; computeSmoothestFaceDirectionField(IntrinsicGeometryInterface&amp; geometry, int nSym = 1)</code> <p>Compute the smoothest n-direction field on the input surface.</p>"},{"location":"surface/algorithms/direction_fields/#smoothest-boundary-aligned-direction-fields","title":"Smoothest Boundary-Aligned Direction Fields","text":"<p>This routine works like the previous ones, except it imposes Dirichlet boundary conditions to force the generated direction field to be aligned with the mesh\u2019s boundary. By default, the direction fields are aligned so that one of the field\u2019s vectors is perpendicular to the boundary at each boundary vertex. If you set <code>normalAlign</code> to <code>false</code> then the direction fields are aligned so that one of the field\u2019s vectors is parallel to the boundary instead.</p>      A direction field aligned with the boundary of the shape.     <code>VertexData&lt;Vector2&gt; computeSmoothestBoundaryAlignedVertexDirectionField(IntrinsicGeometryInterface&amp; geometry, bool normalAlign = true, int nSym = 1)</code> <p>Compute the smoothest n-direction field on the input surface, but ensures that the field is aligned with the surface\u2019s boundary.</p> <code>FaceData&lt;Vector2&gt; computeSmoothestBoundaryAlignedFaceDirectionField(IntrinsicGeometryInterface&amp; geometry, int nSym = 1)</code> <p>Compute the smoothest n-direction field on the input surface, but ensures that the field is aligned with the surface\u2019s boundary.</p>"},{"location":"surface/algorithms/direction_fields/#curvature-aligned-direction-fields","title":"Curvature-Aligned Direction Fields","text":"<p>These routines compute smooth n-direction fields which align to the input surface\u2019s principal curvatures. Since the principal curvatures form a 4-direction field, these methods only generate 2-direction fields and 4-direction fields.</p>      A 4-symmetric, curvature aligned direction field, rendered by tracing streamlines.    <p>Principal directions depend on the extrinsic geometry</p> <p>Unlike the previous routines, <code>computeCurvatureAlignedVertexDirectionField</code> cannot operate using only the intrinsic geometry of its input surface. Since a surface\u2019s principal directions depend on its embedding in 3D, these routines must take in an <code>ExtrinsicGeometryInterface</code>.</p> <p>Curvature-alignment only works for 2- and 4-direction fields</p> <code>VertexData&lt;Vector2&gt; computeCurvatureAlignedVertexDirectionField(ExtrinsicGeometryInterface&amp; geometry, int nSym = 2)</code> <p>Compute a smooth n-direction field on the input surface which is aligned to the surface\u2019s principal curvatures. By default, n = 2.</p> <code>FaceData&lt;Vector2&gt; computeCurvatureAlignedFaceDirectionField(ExtrinsicGeometryInterface&amp; geometry, int nSym = 2)</code> <p>Compute a smooth n-direction field on the input surface which is aligned to the surface\u2019s principal curvatures. By default, n = 2.</p>"},{"location":"surface/algorithms/direction_fields/#index-computation","title":"Index Computation","text":"<p>These methods compute the index of a given n-direction field at every point of the input mesh. If the direction field is represented by vector at vertices, then the singularities live on faces and vice versa.</p> <code>FaceData&lt;int&gt; computeFaceIndex(IntrinsicGeometryInterface&amp; geometry, const VertexData&lt;Vector2&gt;&amp; directionField, int nSym = 1)</code> <p>Compute the singularities in the input n-direction field. Since the direction field is given as vectors at vertices, the singularities are located on faces.</p> <code>VertexData&lt;int&gt; computeVertexIndex(IntrinsicGeometryInterface&amp; geometry, const FaceData&lt;Vector2&gt;&amp; directionField, int nSym = 1)</code> <p>Compute the singularities in the input n-direction field. Since the direction field is given as vectors at faces, the singularities are located on vertices.</p>"},{"location":"surface/algorithms/direction_fields/#citation","title":"Citation","text":"<p>These algorithms are described in Globally Optimal Direction Fields, the appropriate citation is below.  Note: these implementations do not currently exactly match what is described in the paper; they use a simpler \u201cenergy\u201d via the vertex connection Laplacian.</p> <pre><code>@article{knoppel2013globally,\ntitle={Globally optimal direction fields},\nauthor={Kn{\\\"o}ppel, Felix and Crane, Keenan and Pinkall, Ulrich and Schr{\\\"o}der, Peter},\njournal={ACM Transactions on Graphics (ToG)},\nvolume={32},\nnumber={4},\npages={1--10},\nyear={2013},\npublisher={ACM New York, NY, USA}\n}\n</code></pre>"},{"location":"surface/algorithms/flip_geodesics/","title":"Flip Geodesics","text":"<p>This algorithm takes as input a path (or loop/network of paths) along the edges of a triangle mesh, and as output straightens that path to be a geodesic (i.e. a straight line, or equivalently a locally-shortest path along a surface). The procedure runs in milliseconds, is quite robust, comes with a strong guarantee that no new crossings will be created in the path, and as an added benefit also generates a triangulation on the surface which conforms to the geodesic.  Additionally, it even enables the construction of B\u00e9zier curves on a surface.</p> <p></p> <p>See this repo for a demo application which wraps this implementation as a standalone application with a GUI.</p> <p>This is an implementation of the algorithm described in You Can Find Geodesic Paths in Triangle Meshes by Just Flipping Edges.</p> <p><code>#include \"geometrycentral/surface/flip_geodesics.h\"</code></p> <p>Example:</p> <pre><code>#include \"geometrycentral/surface/flip_geodesics.h\"\n#include \"geometrycentral/surface/meshio.h\"\n\nusing namespace geometrycentral;\nusing namespace geometrycentral::surface;\n\n// Load a mesh\nstd::unique_ptr&lt;ManifoldSurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readManifoldSurfaceMesh(\"my_mesh.obj\");\n\n// Create a path network as a Dijkstra path between endpoints\nstd::unique_ptr&lt;FlipEdgeNetwork&gt; edgeNetwork;\nVertex vStart = mesh-&gt;vertex(0);\nVertex vEnd = mesh-&gt;vertex(7);\nedgeNetwork = FlipEdgeNetwork::constructFromDijkstraPath(*mesh, *geometry, vStart, vEnd);\n\n// Make the path a geodesic\nedgeNetwork-&gt;iterativeShorten();\n\n// Extract the result as a polyline along the surface\nedgeNetwork-&gt;posGeom = geometry.get();\nstd::vector&lt;std::vector&lt;Vector3&gt;&gt; polyline = edgeNetwork-&gt;getPathPolyline3D();\n</code></pre>"},{"location":"surface/algorithms/flip_geodesics/#constructing-a-path-network","title":"Constructing a path network","text":"<p>The class stateful class <code>FlipEdgeNetwork</code> encapsulates all functionality in the algorithm; all of the methods below are members functions. This class wraps a <code>SignpostIntrinsicTriangulation</code> (as member <code>FlipEdgeNetwork::tri</code>), and also manages a path network along the edges of that triangulation.</p> <p>The most direct construct takes as input a sequence of halfedges along the surface which comprise the path.</p> <code>FlipEdgeNetwork::FlipEdgeNetwork(ManifoldSurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; inputGeom, const std::vector&lt;std::vector&lt;Halfedge&gt;&gt;&amp; paths, VertexData&lt;bool&gt; extraMarkedVerts = VertexData&lt;bool&gt;())</code> <p>Construct a network of paths along the surface.</p> <ul> <li><code>mesh</code>: the input manifold triangle mesh</li> <li><code>inputGeom</code>: the input geometry (as always, a <code>VertexPositionGeometry</code> is valid input)</li> <li><code>paths</code>: a collection of paths along the surface, each given as an ordered sequence of halfedges</li> <li><code>extraMarkedVerts</code>: if given, boolean vector of vertices where the path is pinned, and should not be straightened</li> </ul> <p>Additionally, several factory methods are provided which assist in constructing a path network from common input data.</p> <code>static std::unique_ptr&lt;FlipEdgeNetwork&gt; FlipEdgeNetwork::constructFromDijkstraPath(ManifoldSurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; geom, Vertex startVert, Vertex endVert)</code> <p>Construct a network consisting of a single path, generated by running Dijkstra\u2019s algorithm between two point.</p> <ul> <li><code>mesh</code>: the input manifold triangle mesh</li> <li><code>inputGeom</code>: the input geometry (as always, a <code>VertexPositionGeometry</code> is valid input)</li> <li><code>startVert</code>, <code>endVert</code>: the source and target vertices from which to initialize a Dijkstra path along edges</li> </ul> <code>static std::unique_ptr&lt;FlipEdgeNetwork&gt; FlipEdgeNetwork::constructFromPiecewiseDijkstraPath(ManifoldSurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; geom, std::vector&lt;Vertex&gt; points, bool closed = false, bool markInterior = false)</code> <p>Construct a network consisting of a single path, generated by running Dijkstra\u2019s algorithm between consecutive pairs of vertices.</p> <ul> <li><code>mesh</code>: the input manifold triangle mesh</li> <li><code>inputGeom</code>: the input geometry (as always, a <code>VertexPositionGeometry</code> is valid input)</li> <li><code>points</code>: the not-necessarily-adjacent vertices from which to initialize the Dijkstra path, by running Dijkstra\u2019s algorithm between each i\u2019th and (i+1)\u2019th points.</li> <li><code>closed</code>: if true, the first point will be connected to the last to create a closed loop</li> <li><code>markInterior</code>: if true, the path will be pinned at the specified <code>points</code> and not shortened there</li> </ul> <code>static std::unique_ptr&lt;FlipEdgeNetwork&gt; FlipEdgeNetwork::constructFromEdgeSet(ManifoldSurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; geom, const EdgeData&lt;bool&gt;&amp; inPath, const VertexData&lt;bool&gt;&amp; extraMarkedVertices)</code> <p>Construct a network from a marked set of edges on the mesh. Endpoints, loops, etc are heuristically inferred (e.g. if a path ends at the same vertex it starts at, it is assumed to be a loop).</p> <ul> <li><code>mesh</code>: the input manifold triangle mesh</li> <li><code>inputGeom</code>: the input geometry (as always, a <code>VertexPositionGeometry</code> is valid input)</li> <li><code>inPath</code>: a boolean array indicating edges which are in the path</li> <li><code>extraMarkedVerts</code>: if given, boolean vector of vertices where the path is pinned, and should not be straightened</li> </ul> <code>FlipEdgeNetwork::reinitializePath(const std::vector&lt;std::vector&lt;Halfedge&gt;&gt;&amp; paths)</code> <p>Re-initialize an existing <code>FlipEdgeNetwork</code> object to hold the paths in <code>paths</code>, just like in the constructor. Useful when used in conjunction with <code>rewind()</code>.</p> <ul> <li><code>paths</code>: a collection of paths along the surface, each given as an ordered sequence of halfedges</li> </ul>"},{"location":"surface/algorithms/flip_geodesics/#manipulating-paths","title":"Manipulating paths","text":"<p>The key routine is <code>FlipEdgeNetwork::iterativeShorten()</code>, which shortens the path until it is a geodesic by flipping edges in the underlying intrinsic triangulation.</p> <code>void FlipEdgeNetwork::iterativeShorten(size_t maxIterations = INVALID_IND, double maxRelativeLengthDecrease = 0.)</code> <p>Shorten the network to be geodesic.</p> <p>Additional termination conditions can be set to potentially stop the process before the path is a geodesic:</p> <ul> <li><code>maxIterations</code> if set to something other than <code>INVALID_IND</code>, limits the number of iterations</li> <li><code>maxRelativeLengthDecrease</code> if set to something other than <code>0</code>, limits the maximum decrease in length for the network. E.g. <code>0.5</code> would mean the resulting network is at at <code>0.5 * L</code>, where <code>L</code> is the initial length.</li> </ul> <p>Importantly, after calling <code>iterativeShorten()</code>, the underlying intrinsic triangulation <code>FlipEdgeNetwork::tri</code> is a triangulation which conforms to the generated geodesics. This triangulation can then be used for subsequent computation, such as solving a PDE which has geodesics as boundary conditions.</p> Shortening many paths <p>After shortening a path to a geodesic, the underlying triangulation has been mutated by edge flips. If you want to shorten another path, you can call <code>rewind()</code> to reset the data structure and prepare it for the next path.</p> <p>For instance, if you wanted to find many point-to-point geodesic paths, you might write something like:</p> <pre><code>std::unique_ptr&lt;FlipEdgeNetwork&gt; flipNetwork(new FlipEdgeNetwork(*mesh, *geometry, {}));\nflipNetwork-&gt;supportRewinding = true;\nflipNetwork-&gt;posGeom = geometry.get();\n\nfor(/* each path to compute */) {\n\nVertex startVert; // populate these somehow\nVertex endVert; // Get an initial dijkstra path\n// (surface/mesh_graph_algorithms.h)\nstd::vector&lt;Halfedge&gt; dijkstraPath = shortestEdgePath(*geom, startVert, endVert);\n\n// Reinitialize the ede network to contain this path\nflipNetwork-&gt;reinitializePath({dijkstraPath});\n\n// Straighten the path to geodesic\nflipNetwork-&gt;iterativeShorten();\n\n// Extract the path and store it in the vector\nstd::vector&lt;Vector3&gt; path3D = flipNetwork-&gt;getPathPolyline3D().front();\n\n// Be kind, rewind\nflipNetwork-&gt;rewind();\n}\n</code></pre>"},{"location":"surface/algorithms/flip_geodesics/#geodesic-bezier-curves","title":"Geodesic B\u00e9zier curves","text":"<p>Once we can shorten curves to geodesics, we can use a de Casteljau-style subdivision scheme to construct geodesic B\u00e9zier curves along a mesh, using a procedure described in \u201cModeling on triangulations with geodesic curves\u201d by Morera et al. (2008).</p> <code>void FlipEdgeNetwork::bezierSubdivide(size_t nRounds)</code> <p>Construct a B\u00e9zier curve from an input control polygon path via iterative subdivision.</p> <ul> <li><code>nRounds</code> specifies the number of subdivision rounds to perform; the curve converges to an exact geodesics as <code>nRounds</code> increases. Setting <code>nRounds=3</code> is often a good initial choice.</li> </ul> <p>Note that the control points of the curve should be marked vertices, as described in the construction section. Additionally, this function should be applied to a network consisting of a single path, not distinct paths between multiple control points.  Calling the factory method <code>FlipEdgeNetwork::constructFromPiecewiseDijkstraPath(mesh, geom, /* vector of constrol vertices */, false, true)</code> above will construct a path ready for B\u00e9zier subdivision.</p> <p>The algorithm used here is essentially the one described in \u201cModeling on triangulations with geodesic curves\u201d by Morera et al. (2008), but using flip-based geodesics to straighten paths.</p>    A geodesic B\u00e9zier curve generated with this method."},{"location":"surface/algorithms/flip_geodesics/#improving-the-triangulation","title":"Improving the triangulation","text":"<p>As noted above, we can additionally generate a triangulation which conforms to geodesic curves, but this triangulation will often contain extremely skinny triangles. Performing Delaunay refinement improves the triangle quality for subsequent computation.</p> <code>void FlipEdgeNetwork::delaunayRefine(double areaThresh = std::numeric_limits&lt;double&gt;::infinity(), size_t maxInsertions = INVALID_IND, double angleBound = 25.)</code> <p>Perform intrinsic Delaunay refinement on the underlying triangulation to improve its numerical quality while preserving the geodesics.</p> <p>Additional arguments are as in <code>SignpostIntrinsicTriangulation::delaunayRefine()</code>.</p>    A geodesic path is introduced, then the triangulation is refined to remove skinny triangles."},{"location":"surface/algorithms/flip_geodesics/#output-and-utilities","title":"Output and utilities","text":"<p>After running <code>iterativeShorten()</code>, the resulting geodesic paths are represented as a collection edges in an updated intrinsic triangulation. The most common operation is to extract the resulting path network as a polyline along the surface. Note that these routines return a double list; the outer list represents the paths/loops in the network, while the inner list are the points in each path/loop.</p> <p>One option is to get the output as a sequence of surface points, where each is a vertex or a point along some edge in the mesh. </p> <code>std::vector&lt;std::vector&lt;SurfacePoint&gt;&gt; FlipEdgeNetwork::getPathPolyline()</code> <p>Get the path network as a sequence of surface points along the input mesh.</p> <code>std::vector&lt;std::vector&lt;SurfacePoint&gt;&gt; FlipEdgeNetwork::getAllEdgePolyline()</code> <p>Get all edges in the underlying triangulation as a sequence of surface points along the input mesh.</p> <p>A simpler approach is to simply extract the path as a sequence of points in 3D space.</p> <p>To use this approach, you must first set your 3D mesh geometry as the <code>posGeom</code> member. This extra step is necessary because in general, the <code>FlipEdgeNetwork</code> can be applied to meshes which have only edge lengths, but extracting 3D points requires your mesh to have 3D positions. (see the example at the top.)</p> <code>std::vector&lt;std::vector&lt;Vector3&gt;&gt; FlipEdgeNetwork::getPathPolyline3D()</code> <p>Get the path network as a sequence of points in 3D space. </p> <p>To use this approach, you must first set your 3D mesh geometry as the <code>posGeom</code> member. </p> <code>std::vector&lt;std::vector&lt;Vector3&gt;&gt; FlipEdgeNetwork::getAllEdgePolyline3D()</code> <p>Get all edges in the underlying intrinsic triangulation as a sequence of points in 3D space. </p> <p>To use this approach, you must first set your 3D mesh geometry as the <code>posGeom</code> member. </p> <p>Additionally, a collection of useful utility functions are provided (see <code>flip_geodesic.h</code> the complete listing).</p> <code>void FlipEdgeNetwork::rewind()</code> <p>Undo any flips which have been performed, resetting the data structure to its initial state.</p> <p>Note that you must set <code>FlipEdgeNetwork::supportRewinding = true</code> right after constructure (before doing any shortening) to be able to use <code>rewind()</code>.</p> <code>bool FlipEdgeNetwork::edgeInPath(Edge e)</code> <p>Test whether a given edge from the intrinsic triangulation appears in the path.</p> <code>bool FlipEdgeNetwork::halfedgeInPath(Halfedge he)</code> <p>Test whether a given halfedge from the intrinsic triangulation appears in the path.</p> <code>double FlipEdgeNetwork::length()</code> <p>Measure the total length of the path network.</p> <code>double FlipEdgeNetwork::minAngleIsotopy()</code> <p>Measure the smallest angle in the path (not blocked by isotopy, aka the constraint that curves do not cross).</p> <code>void FlipEdgeNetwork::savePathOBJLine(std::string filenamePrefix, bool withAll = false)</code> <p>Write the path to file as line entries in an obj file.</p>"},{"location":"surface/algorithms/flip_geodesics/#citation","title":"Citation","text":"<p>If these routines contribute to academic work, please cite:</p> <pre><code>@article{sharp2020you,\ntitle={You can find geodesic paths in triangle meshes by just flipping edges},\nauthor={Sharp, Nicholas and Crane, Keenan},\njournal={ACM Transactions on Graphics (TOG)},\nvolume={39},\nnumber={6},\npages={1--15},\nyear={2020},\npublisher={ACM New York, NY, USA}\n}\n</code></pre>"},{"location":"surface/algorithms/geodesic_distance/","title":"Geodesic Distance","text":"<p>This section describes algorithms for computing distance along a surface, or geodesic distance.</p> <p>Note that distance depends on the intrinsic geometry of a surface (via the <code>IntrinsicGeometryInterface</code>). Therefore, these routines can be run on abstract geometric domains as well as traditional surfaces in 3D.</p>"},{"location":"surface/algorithms/geodesic_distance/#polyhedral-distance","title":"Polyhedral Distance","text":"<p>These routines use Danil Kirsanov\u2019s implementation of the MMP algorithm for exact polyhedral geodesic distance to compute geodesic distance (and geodesic paths) along a surface.</p> <p>This class supports any (possibly-nonmanifold) triangle mesh as input, and requires only intrinsic geometry (aka edge lengths) to function.</p> <p><code>#include \"geometrycentral/surface/exact_geodesics.h\"</code></p>"},{"location":"surface/algorithms/geodesic_distance/#single-solves","title":"Single Solves","text":"<p>Geodesic distance from a single source vertex can be computed via the following utility function. More general source data, queries in the interior of triangles, and geodesic path extraction can be handled using the stateful version below.</p> <p>Example <pre><code>#include \"geometrycentral/surface/exact_geodesics.h\"\n#include \"geometrycentral/surface/meshio.h\"\n\n// Load a mesh\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readSurfaceMesh(filename);\n\n// Pick a vertex\nVertex sourceVert = /* some vertex */\n\n// Compute distance\nVertexData&lt;double&gt; distToSource = exactGeodesicDistance(*mesh, *geometry, sourceVert);\n/* do something useful */\n</code></pre></p> <code>VertexData&lt;double&gt; exactGeodesicDistance(SurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; geom, Vertex v)</code> <p>Compute the distance from the source using MMP. See the stateful class below for further options.</p>"},{"location":"surface/algorithms/geodesic_distance/#advanced-queries","title":"Advanced Queries","text":"<p>The stateful class <code>GeodesicAlgorithmExact</code> runs the MMP algorithm to compute geodesic distance from a given set of source points. The resulting distance field can be queried at any point on the input mesh to find the identity of the nearest source point, the distance to the source point, and the shortest path to the source point.</p> <p>Both the source points and query point are represented as <code>SurfacePoints</code> (see here), i.e. locations on a surface which may be a vertex, a point along an edge, or a point inside a face.</p> <p>Note that unlike the heat method, this precomputation does not speed up future distance computations using different sets of source points.</p> <p>Example: <pre><code>#include \"geometrycentral/surface/exact_geodesics.h\"\n#include \"geometrycentral/surface/meshio.h\"\n\n// Load a mesh\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readSurfaceMesh(filename);\n\n// Create the GeodesicAlgorithmExact\nGeodesicAlgorithmExact mmp(*mesh, *geometry);\n\n// Pick a few points as the source set\nstd::vector&lt;SurfacePoint&gt; sourcePoints;\nVertex v = /* some vertex */\nsourcePoints.push_back(SurfacePoint(v));\n\nEdge e = /* some edge */\ndouble tEdge = /* some coordinate along edge e*/\nsourcePoints.push_back(SurfacePoint(e, tEdge));\n\nFace f =  /* some face */;\nVector3 fBary =  /* some barycentric coords in face f */;\nsourcePoints.push_back(SurfacePoint(f, fBary));\n\n// Run MMP from these source points\nmmp.propagate(sourcePoints);\n\n// Get the distance function at all mesh vertices\nVertexData&lt;double&gt; distToSource = mmp.getDistanceFunction();\n\n// Query the distance function at some point\nSurfacePoint queryPoint = /* some point on the surface */\ndouble dist = mmp.getDistance(queryPoint);\n\n// Get the geodesic path from a query point to the nearest source\nSurfacePoint queryPoint2 = /* some point on the surface */\ndouble pathLength;\nstd::vector&lt;SurfacePoint&gt; path = mmp.traceBack(queryPoint2, pathLength);\n\n// Get the gradient of the distance function at some point\nVector2 gradDist = mmp.getDistanceGradient(queryPoint);\n\n// Find the tangent vector pointing to a query point from the closest source\nVector2 log_base_source_of_query = mmp.getLog(queryPoint);\n</code></pre></p> <code>GeodesicAlgorithmExact::GeodesicAlgorithmExact(SurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; geom)</code> <p>Creates a new solver, but does not do any computation</p> <code>void GeodesicAlgorithmExact::propagate(const std::vector&lt;SurfacePoint&gt;&amp; sources, double max_propagation_distance = GEODESIC_INF, const std::vector&lt;SurfacePoint&gt;&amp; stop_points = {})</code> <p>Compute the distance field from a set of source vertices. This distance field can then be queried by several functions below.</p> <ul> <li> <p><code>sources</code> is a list of points on the surface. The computed distance field gives the distance from any point on the mesh to the closest of these source points.</p> </li> <li> <p><code>max_propagation_distance</code> is a cutoff value. Once <code>propagate</code> identifies all vertices within <code>max_propagation_distance</code> of the source points, it stops. By default, <code>max_propagation_distance</code> is set to infinity so that distances are computed across the whole input surface.</p> </li> <li> <p><code>stop_points</code> is a list of points on the mesh at which we want to know the distance function. By default it is empty. If it is nonempty, then propagate stops once accurate distances at all of the stop points have been computed. This can speed up run time considerably if one is only interested in a small set of points near the source.</p> </li> </ul> <code>void GeodesicAlgorithmExact::propagate(const std::vector&lt;Vertex&gt;&amp; sources, double max_propagation_distance = GEODESIC_INF, const std::vector&lt;Vertex&gt;&amp; stop_points = {})</code> <p>Performs the same computation as the first <code>propagate</code> function, but takes vertices rather than arbitrary surface points for convenience.</p> <code>void GeodesicAlgorithmExact::propagate(const SurfacePoint&amp; source, double max_propagation_distance = GEODESIC_INF, const std::vector&lt;SurfacePoint&gt;&amp; stop_points = {})</code> <p>Performs the same computation as the first <code>propagate</code> function, but takes a single source point for convenience.</p> <code>void GeodesicAlgorithmExact::propagate(const Vertex&amp; source, double max_propagation_distance = GEODESIC_INF, const std::vector&lt;Vertex&gt;&amp; stop_points = {})</code> <p>Performs the same computation as the first <code>propagate</code> function, but takes a single source vertex rather than arbitrary surface points for convenience.</p> <code>std::vector&lt;SurfacePoint&gt; GeodesicAlgorithmExact::traceBack(const SurfacePoint&amp; point, double&amp; pathLength [optional]) const</code> <p>Compute the geodesic path from <code>point</code> to the closest source. This path is encoded as a list of <code>SurfacePoints</code> starting at <code>point</code> and ending at the source. (Optionally also returns the length of the path via the <code>pathLength</code> argument.)</p> <code>std::vector&lt;SurfacePoint&gt; GeodesicAlgorithmExact::traceBack(const Vertex&amp; v, double&amp; pathLength [optional]) const</code> <p>Compute the geodesic path from <code>v</code> to the closest source point. This path is encoded as a list of <code>SurfacePoints</code> starting at <code>v</code> and ending at the source point. (Optionally also returns the length of the path via the <code>pathLength</code> argument.)</p> <code>std::pair&lt;unsigned, double&gt; GeodesicAlgorithmExact::closestSource(const SurfacePoint&amp; point) const</code> <p>Identify the closest source to <code>point</code> and compute the distance to that source. Returns the index of that source in the source list along with the distance.</p> <code>std::pair&lt;unsigned, double&gt; GeodesicAlgorithmExact::closestSource(const Vertex&amp; v) const</code> <p>Identify the closest source to <code>v</code> and compute the distance to that source. Returns the index of that source in the source list along with the distance.</p> <code>double GeodesicAlgorithmExact::getDistance(const SurfacePoint&amp; point) const</code> <p>Returns the distance from <code>point</code> to the closest source.</p> <code>double GeodesicAlgorithmExact::getDistance(const Vertex&amp; v) const</code> <p>Returns the distance from <code>v</code> to the closest source.</p> <code>VertexData&lt;double&gt; GeodesicAlgorithmExact::getDistanceFunction() const</code> <p>Evaluate the distance function at every vertex of the mesh.</p> <code>IntervalList GeodesicAlgorithmExact::getEdgeIntervals(Edge e) const</code> <p>Get the list of windows along edge <code>e</code> that MMP uses to represent the distance function.</p>"},{"location":"surface/algorithms/geodesic_distance/#vector-valued-queries","title":"Vector-valued Queries","text":"<p>Computing exact geodesic paths also allows one to compute exact log maps, as well as the exact gradient of the distance function.</p> <code>Vector2 GeodesicAlgorithmExact::getLog(const SurfacePoint&amp; point) const</code> <p>Returns the log map at the source closest to <code>point</code> (i.e. the tangent vector based at the closest source which points towards <code>point</code> whose magnitude is the distance from the source to <code>point</code>).</p> <code>Vector2 GeodesicAlgorithmExact::getLog(const Vertex&amp; v) const</code> <p>Returns the log map at the source closest to <code>v</code> (i.e. the tangent vector based at the closest source which points towards <code>v</code> whose magnitude is the distance from the source to <code>point</code>).</p> <code>Vector2 GeodesicAlgorithmExact::getDistanceGradient(const SurfacePoint&amp; point) const</code> <p>Returns the gradient of the distance function at <code>point</code> (i.e. the unit tangent vector at <code>point</code> which points away from the closest source)</p> <code>Vector2 GeodesicAlgorithmExact::getDistanceGradient(const Vertex&amp; v) const</code> <p>Returns the gradient of the distance function at <code>v</code> (i.e. the unit tangent vector at <code>v</code> which points away from the closest source)</p>"},{"location":"surface/algorithms/geodesic_distance/#heat-method-for-distance","title":"Heat Method for Distance","text":"<p>These routines implement the Heat Method for Geodesic Distance. This algorithm uses short time heat flow to compute distance on surfaces. Because the main burden is simply solving linear systems of equations, it tends to be faster than polyhedral schemes, especially when computing distance multiple times on the same surface.  In the computational geometry sense, this method is an approximation, as the result is not precisely equal to the polyhedral distance on the surface; nonetheless it is fast and well-suited for many applications.</p> <p>This class also supports any (possibly-nonmanifold) triangle mesh as input, and requires only intrinsic geometry (aka edge lengths) to function. Furthermore, it can optionally use robust operators internally to improve performance on low-quality meshes.</p> <p><code>#include \"geometrycentral/surface/heat_method_distance.h\"</code></p>"},{"location":"surface/algorithms/geodesic_distance/#single-solves_1","title":"Single Solves","text":"<p>A one-off utility function is provided which computes the distance from a source vertex using the heat method. Repeated solves or more general source data should use the stateful version below.</p> <p>Example <pre><code>#include \"geometrycentral/surface/heat_method_distance.h\"\n#include \"geometrycentral/surface/meshio.h\"\n\n// Load a mesh\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = loadMesh(filename);\n\n// Pick a vertex\nVertex sourceVert = /* some vertex */\n\n// Compute distance\nVertexData&lt;double&gt; distToSource = heatMethodDistance(*geometry, sourceVert);\n/* do something useful */\n</code></pre></p> <code>VertexData&lt;double&gt; heatMethodDistance(IntrinsicGeometryInterface&amp; geom, Vertex v)</code> <p>Compute the distance from the source using the heat method. See the stateful class below for further options.</p>"},{"location":"surface/algorithms/geodesic_distance/#repeated-solves","title":"Repeated Solves","text":"<p>The stateful class <code>HeatMethodDistanceSolver</code> does precomputation when constructed, then allows many distance solves from different source locations to be performed efficiently. This class also exposes options, like changing the internal short-time parameter, or using a robust operators.</p> <p>The <code>computeDistance()</code> method in <code>HeatMethodDistanceSolver</code> can also take <code>SurfacePoint</code>(s) as the source location(s). A <code>SurfacePoint</code> (see here) is a location on a surface, which may be a vertex, a point along an edge, or a point inside a face.</p> <p>Example: <pre><code>#include \"geometrycentral/surface/heat_method_distance.h\"\n#include \"geometrycentral/surface/meshio.h\"\n\n// Load a mesh\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = loadMesh(filename);\n\n// Create the Heat Method solver\nHeatMethodDistanceSolver heatSolver(*geometry);\n\n// Alternately, set useRobustLaplacian=true to get a robustified version\n// HeatMethodDistanceSolver heatSolver(*geometry, 1.0, true);\n\n// Some vertices as source set\nstd::vector&lt;Vertex&gt; sourceVerts = /* some interesting vertices */\nfor(Vertex v : sourceVerts) {\nVertexData&lt;double&gt; distToSource = heatSolver.computeDistance(v);\n/* do something useful */\n}\n\n\n// A point in a face as a source set\nFace sourceF =  /* some face */;\nVector3 sourceFBary =  /* some barycentric coords in face */;\nSurfacePoint targetP(sourceF, sourceFBary);\n\nVertexData&lt;double&gt; distToSource = heatSolver.computeDistance(targetP);\n/* do something useful */\n</code></pre></p> <code>HeatMethodDistanceSolver::HeatMethodDistanceSolver(IntrinsicGeometryInterface&amp; geom, double tCoef=1.0, bool useRobustLaplacian = false)</code> <p>Create a new solver to compute geodesic distance using the heat method. All precomputation work is performed immediately at construction time.</p> <ul> <li> <p><code>geom</code> is the geometry (and hence mesh) on which to compute. Note that nearly any geometry object (<code>VertexPositionGeometry</code>, etc) can be passed here.</p> </li> <li> <p><code>tCoef</code> is the time to use for short time heat flow, as a factor <code>m * h^2</code>, where <code>h</code> is the mean edge length. The default value of <code>1.0</code> is almost always sufficient.</p> </li> <li> <p><code>useRobustLaplacian</code> is true, the solver will internally use a robust intrinsic Laplacian, including mollification &amp; tufting for nonmanifold inputs. See \u201cA Laplacian for Nonmanifold Triangle Meshes\u201d [Sharp &amp; Crane 2020 @ SGP] for algorithmic details and citation.</p> </li> </ul> <p>Algorithm options (like <code>tCoef</code>) cannot be changed after construction; create a new solver object with the new settings.</p> <code>VertexData&lt;double&gt; HeatMethodDistanceSolver::computeDistance(Vertex v)</code> <p>Compute the distance from a single source vertex.</p> <code>VertexData&lt;double&gt; HeatMethodDistanceSolver::computeDistance(std::vector&lt;Vertex&gt; verts)</code> <p>Compute the distance from a set of source vertices.</p> <code>VertexData&lt;double&gt; HeatMethodDistanceSolver::computeDistance(SurfacePoint p)</code> <p>Compute the distance from a single source point.</p> <code>VertexData&lt;double&gt; HeatMethodDistanceSolver::computeDistance(std::vector&lt;SurfacePoint&gt; points)</code> <p>Compute the distance from a set of source points.</p>"},{"location":"surface/algorithms/geodesic_paths/","title":"Tracing Geodesic Paths","text":"<p>The function <code>traceGeodesic</code> allows one to compute straightest paths along a surface (i.e. geodesic paths). </p> <p>Note that straightest paths depend only on the intrinsic geometry of a surface (via the <code>IntrinsicGeometryInterface</code>). Therefore, these routines can be run on abstract geometric domains as well as traditional surfaces in 3D. However, these routines do assume that the domain is a <code>ManifoldSurfaceMesh</code>.</p> <p><code>#include \"geometrycentral/surface/trace_geodesic.h\"</code></p> <code>TraceGeodesicResult traceGeodesic(IntrinsicGeometryInterface&amp; geom, SurfacePoint startP, Vector2 traceVec, const TraceOptions&amp; traceOptions = defaultTraceOptions);</code> <p>Trace a geodesic path along a surface mesh.</p> <ul> <li><code>inputGeom</code>: the input geometry (as always, a <code>VertexPositionGeometry</code> is valid input)</li> <li><code>startP</code>: the point on the surface where the path should start</li> <li><code>traceVec</code>: the direction the path should proceed in, and the distance that it should travel</li> <li><code>traceOptions</code>: options to specify the behavior of <code>traceGeodesic</code> in various situations</li> </ul> <p>The function <code>traceGeodesic</code> traces out a geodesic path starting at <code>startP</code> which proceeds in the direction of <code>traceVec</code> and has length equal to <code>traceVec.norm()</code>, unless the path intersects a boundary edge in which case it stops there.  This is also known as the exponential map. (As an aside, <code>geometry-central</code> also provides procedures for computing the inverse of the exponential map, known as the logarithmic map.)</p>"},{"location":"surface/algorithms/geodesic_paths/#example","title":"Example","text":"<pre><code>#include \"geometrycentral/surface/meshio.h\"\n#include \"geometrycentral/surface/surface_point.h\"\n#include \"geometrycentral/surface/trace_geodesic.h\"\n\n// Load a mesh\nstd::unique_ptr&lt;ManifoldSurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readManifoldSurfaceMesh(filename);\n\nVertex v = mesh-&gt;vertex(0);\nVector2 traceVec = 3 * Vector2::fromAngle(M_PI/6);\nSurfacePoint pathEndpoint = traceGeodesic(*geometry, SurfacePoint(v), traceVec).endPoint;\n</code></pre>"},{"location":"surface/algorithms/geodesic_paths/#helper-types","title":"Helper Types","text":""},{"location":"surface/algorithms/geodesic_paths/#options","title":"Options","text":"<p>Options are passed in to <code>traceGeodesic</code> via a <code>TraceOptions</code> object.</p> Field Default value Meaning <code>bool includePath</code> <code>false</code> whether to return the entire path trajectory (as opposed to merely returning the path\u2019s endpoint) <code>bool errorOnProblem</code> <code>false</code> whether to throw exceptions if the procedure encounters degenerate geometry <code>EdgeData&lt;bool&gt;* barrierEdges</code> <code>nullptr</code> if set, paths will stop when they hit barrier edges <code>size_t maxIters</code> <code>INVALID_IND</code> if set, paths will stop after traversing through <code>maxIters</code> faces"},{"location":"surface/algorithms/geodesic_paths/#result","title":"Result","text":"<p>The result is returned as a <code>TraceGeodesicResult</code>, which has 5 fields:</p> Field Meaning <code>SurfacePoint endPoint</code> the point the path ended at <code>std::vector&lt;SurfacePoint&gt; pathPoints</code> all points along the path, including start and end <code>Vector2 endingDir</code> the incoming direction to the final point, in its tangent space <code>bool hitBoundary</code> did the path stop early because we hit a boundary? <code>bool hasPath</code> is <code>pathPoints</code> populated? <code>double length</code> length of the traced path (generally equals norm of <code>traceVec</code> unless tracing stopped early due to hitting a boundary/barrier edge or due to the iteration limit <code>maxIters</code>)"},{"location":"surface/algorithms/geodesic_paths/#tangent-spaces","title":"Tangent Spaces","text":"<p>The input <code>traceVec</code> is specified as a vector in the tangent space of the starting point. The meaning of this vector depends on whether the starting point is located on a vertex, edge, or face of the mesh. Tangent space in geometry central are discussed in more detail on the Quantities page, but we give a brief overview here.</p> <p>Given any mesh element (i.e. vertex, edge, or face) <code>p</code>, the x-axis of the tangent space at <code>p</code> points in the direction of <code>p.halfedge()</code>. The yy-axis then points 90 degrees counterclockwise from the xx-axis. (This is slightly more complicated at vertices, where one must use rescaled corner angles to define these directions. See the discussion of vertex tangent spaces) for more details.</p>"},{"location":"surface/algorithms/geodesic_voronoi_tessellations/","title":"Geodesic Centroidal Voronoi Tessellations","text":"<p>A Voronoi tessellation partitions a domain M based on a set of sites s_i \\in Ms_i \\in M. To each site s_is_i, we associate a region (or \u201cVoronoi cell\u201d) consisting of the points closer to s_is_i than to any other site. Such a tessellation is called centroidal if each site is at the center of its corresponding cell. This routine computes centroidal Voronoi tessellations on surface meshes.</p> <p>Output is not unique!</p> <p>By default, this procedure picks some random points and optimizes them to compute a centroidal Voronoi tessellation. Since the initialization is random, the results will generally be different each time the procedure is run.</p> <p><code>#include \"geometrycentral/surface/geodesic_centroidal_voronoi_tessellation.h\"</code></p> <p></p> <code>VoronoiResult computeGeodesicCentroidalVoronoiTessellation(ManifoldSurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; geom, VoronoiOptions options = defaultVoronoiOptions)</code> <p>Compute a geodesic centroidal Voronoi tessellation on the input mesh. Options are passed as a VoronoiOptions object, and the output is returned as a VoronoiResult object.</p>"},{"location":"surface/algorithms/geodesic_voronoi_tessellations/#helper-types","title":"Helper Types","text":""},{"location":"surface/algorithms/geodesic_voronoi_tessellations/#options","title":"Options","text":"<p>Options are passed in to <code>computeGeodesicCentroidalVoronoiTessellation</code> via a <code>VoronoiOptions</code> object.</p> Field Default value Meaning <code>size_t nSites;</code> <code>10</code> the number of sites to place <code>std::vector&lt;SurfacePoint&gt; initialSites;</code> <code>{}</code> desired locations for sites. If blank, initial locations are chosen randomly <code>size_t iterations;</code> <code>50</code> number of iterations to run for <code>bool useDelaunay;</code> <code>true</code> solve on an intrinsic Delaunay triangulation of the input <code>double tCoef;</code> <code>1</code> diffusion time for the vector heat method <code>size_t nSubIterations;</code> <code>1</code> number of iterations to use when computing surface centers during optimization"},{"location":"surface/algorithms/geodesic_voronoi_tessellations/#result","title":"Result","text":"<p>The result is returned as a <code>VoronoiResult</code>, which has 3 fields:</p> Field Meaning <code>std::vector&lt;SurfacePoint&gt; siteLocations;</code> the sites at the centers of the Voronoi cells <code>std::vector&lt;VertexData&lt;double&gt;&gt; siteDistributions;</code> indicator functions which each Voronoi cell <code>bool hasDistributions;</code> is <code>siteDistributions</code> populated?"},{"location":"surface/algorithms/geodesic_voronoi_tessellations/#citation","title":"Citation","text":"<p>This algorithms is described in The Vector Heat Method, the appropriate citation is:</p> <pre><code>@article{sharp2019vector,\ntitle={The Vector Heat Method},\nauthor={Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan},\njournal={ACM Transactions on Graphics (TOG)},\nvolume={38},\nnumber={3},\npages={24},\nyear={2019},\npublisher={ACM}\n}\n</code></pre>"},{"location":"surface/algorithms/intersection/","title":"Intersection","text":"<p>The functions <code>intersections</code> and <code>selfIntersections</code> find intersections between a pair of triangle meshes, or between a mesh and itself. </p> <p>Intersections are meaningful only for meshes that have an extrinsic geometry, encoded via an <code>EmbeddedGeometryInterface</code> (e.g. a <code>VertexPositionGeometry</code>). These routines assume the meshes are triangle meshes, but otherwise works with arbitrary polygon soup (encoded via <code>SurfaceMesh</code>).</p> <p>Intersections are returned as an \u201cedge soup,\u201d i.e., a collection of line segments with no explicit connectivity between shared endpoints.</p> <p>Triangle-triangle intersections are computed using Tomas Moller\u2019s 1997 triangle intersection routine, provided here.</p> <p>all-pairs check</p> <p>The current implementation does a naive all-pairs check, which takes O(nm) time (or O(n^2) time in the case of self-intersections).  This makes the methods very slow for large meshes.  A natural future improvement would be to perform hierarchical collision checking.</p> <p><code>#include \"geometrycentral/surface/intersection.h\"</code></p> <p></p> <code>SurfaceIntersectionResult intersections(EmbeddedGeometryInterface&amp; geometry1, EmbeddedGeometryInterface&amp; geometry2);</code> <p>Find all intersections between two meshes.</p> <ul> <li><code>geometry1</code>: the geometry of the first mesh</li> <li><code>geometry2</code>: the geometry of the second mesh</li> </ul> <p></p> <code>SurfaceIntersectionResult selfIntersections(EmbeddedGeometryInterface&amp; geometry);</code> <p>Find all intersections between non-adjacent pairs of triangles in a single mesh, i.e., triangles that do not share vertices or edges.  (Adjacent triangles are excluded, since otherwise we would find all the mesh vertices and edges in addition to more global intersections.) Note that for polygon soup, where triangles have identical vertex locations but there is no explicit connectivity, intersections will still be found between adjacent triangles (such as the triangles in the eyes of the model pictured above).</p> <ul> <li><code>geometry</code>: the input geometry</li> </ul>"},{"location":"surface/algorithms/intersection/#example","title":"Example","text":"<pre><code>#include \"geometrycentral/surface/surface_mesh.h\"\n#include \"geometrycentral/surface/meshio.h\"\n#include \"geometrycentral/surface/intersection.h\"\n\n// Load two meshes\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh1, mesh2;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry1, geometry2;\nstd::tie(mesh1, geometry1) = readSurfaceMesh(filename1);\nstd::tie(mesh2, geometry2) = readSurfaceMesh(filename2);\n\n// Find self-intersections in mesh1\nSurfaceIntersectionResult r1 = selfIntersections( *geometry1 );\n\n// Find intersections between the two meshes\nSurfaceIntersectionResult r12 = intersections( *geometry1, *geometry2 );\n</code></pre>"},{"location":"surface/algorithms/intersection/#helper-types","title":"Helper Types","text":""},{"location":"surface/algorithms/intersection/#result","title":"Result","text":"<p>The result is returned as a <code>SurfaceIntersectionResult</code>, which has 3 fields:</p> Field Meaning <code>SurfacePoint endPoint</code> the point the path ended at <code>std::vector&lt;Vector3&gt; points</code> endpoints of segments along intersection <code>std::vector&lt;std::array&lt;size_t,2&gt;&gt; edges</code> segments along intersection, as pairs of indices into the <code>points</code> list <code>bool hasIntersections</code> were there any intersections?"},{"location":"surface/algorithms/parameterization/","title":"Parameterization","text":"<p>This section describes the algorithms in geometry-central for surface parameterization, which compute maps from surfaces meshes to the plane.</p> <p>Note that these procedures all depend on the intrinsic geometry of a surface (via the <code>IntrinsicGeometryInterface</code>). Therefore, these routines can be run on abstract geometric domains as well as traditional surfaces in 3D.</p>"},{"location":"surface/algorithms/parameterization/#boundary-first-flattening","title":"Boundary First Flattening","text":"<p> This algorithm is described in the paper Boundary First Flattening. It computes a conformal parameterization of a surface mesh, allowing the user to specify target angles or scale factors along the boundary of the mesh. The input mesh must be a topological disk.</p> <p><code>#include \"geometrycentral/surface/boundary_first_flattening.h\"</code></p>"},{"location":"surface/algorithms/parameterization/#single-parameterizations","title":"Single Parameterizations","text":"<p>A one-off utility function is provided to compute single parameterizations. Repeated parameterizations of the same mesh can be computed more efficiently using the utility class <code>BFF</code> below.</p> <p>Example: <pre><code>#include \"geometrycentral/surface/boundary_first_flattening.h\"\n#include \"geometrycentral/surface/meshio.h\"\n\n// Load a mesh\nstd::unique_ptr&lt;ManifoldSurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readManifoldSurfaceMesh(filename);\n\nVertexData&lt;Vector2&gt; parameterization = parameterizeBFF(*mesh, *geometry);\n</code></pre></p> <code>VertexData&lt;Vector2&gt; parameterizeBFF(ManifoldSurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; geom)</code> <p>Conformally parameterize the input mesh. Picks boundary conditions to minimize area distortion (i.e. sets the conformal scale factor to 0 along the boundary).</p> <code>VertexData&lt;Vector2&gt; parameterizeBFFfromScaleFactors(ManifoldSurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; geom, const VertexData&lt;double&gt;&amp; boundaryScaleFactors)</code> <p>Conformally parameterize the input mesh, setting the scale factors to the given values along the boundary. Although <code>boundaryScaleFactors</code> is a <code>VertexData</code> object which stores values at all vertices, only the values at boundary vertices are used by the algorithm. All other values are ignored.</p> <code>VertexData&lt;Vector2&gt; parameterizeBFFfromExteriorAngles(ManifoldSurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; geom, const VertexData&lt;double&gt;&amp; exteriorAngles)</code> <p>Conformally parameterize the input mesh so that the boundary vertices of the parameterized mesh have the given exterior angles. The exterior angles must sum up to 2\\pi along the boundary.</p> <p>Although <code>exteriorAngles</code> is a <code>VertexData</code> object which stores values at all vertices, only the values at boundary vertices are used by the algorithm. All other values are ignored.</p>"},{"location":"surface/algorithms/parameterization/#repeated-parameterization","title":"Repeated Parameterization","text":"<p>The stateful class <code>BFF</code> does precomputation when constructed to efficiently compute many parameterizations of the same mesh.</p> <p>Example: <pre><code>#include \"geometrycentral/surface/boundary_first_flattening.h\"\n#include \"geometrycentral/surface/meshio.h\"\n\n// Load a mesh\nstd::unique_ptr&lt;ManifoldSurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readManifoldSurfaceMesh(filename);\n\nVertexData&lt;double&gt; boundaryScaleFactors = /* target scale factors */;\nVertexData&lt;double&gt; exteriorAngles = /* target exteriorAngles */;\n\nBFF bff(*mesh, *geometry);\nVertexData&lt;Vector2&gt; parameterization1 = bff.flattenFromScaleFactors(boundaryScaleFactors);\nVertexData&lt;Vector2&gt; parameterization2 = bff.flattenFromExteriorAngles(exteriorAngles);\n</code></pre></p> <code>BFF::BFF(ManifoldSurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; geom)</code> <p>Create a new solver for boundary first flattening. Most precomputation is done immediately when the object is constructed, although some additional precomputation may be done lazily later on.</p> <code>VertexData&lt;Vector2&gt; BFF::flatten()</code> <p>Compute a conformal parameterization which minimizes area distortion (i.e. sets the scale factor to 0 along the boundary).</p> <code>VertexData&lt;Vector2&gt; BFF::flattenFromScaleFactors(const VertexData&lt;double&gt;&amp; boundaryScaleFactors)</code> <p>Compute a conformal parameterization with the given scale factor along the boundary. Although <code>boundaryScaleFactors</code> is a <code>VertexData</code> object which stores values at all vertices, only the values at boundary vertices are used by the algorithm. All other values are ignored.</p> <code>VertexData&lt;Vector2&gt; BFF::flattenFromExteriorAngles(const VertexData&lt;double&gt;&amp; exteriorAngles)</code> <p>Compute a conformal parameterization with the given exterior angles along the boundary. The exterior angles must sum up to 2\\pi2\\pi along the boundary.</p> <p>Although <code>exteriorAngles</code> is a <code>VertexData</code> object which stores values at all vertices, only the values at boundary vertices are used by the algorithm. All other values are ignored.</p>"},{"location":"surface/algorithms/parameterization/#citation","title":"Citation","text":"<p>If this algorithm contributes to academic work, please cite the following paper:</p> <pre><code>@article{Sawhney:2017:BFF,\nauthor = {Sawhney, Rohan and Crane, Keenan},\ntitle = {Boundary First Flattening},\njournal = {ACM Transactions on Graphics (TOG)},\nvolume = {37},\nnumber = {1},\nmonth = dec,\nyear = {2017},\nissn = {0730-0301},\npages = {5:1--5:14},\narticleno = {5},\nnumpages = {14},\nurl = {http://doi.acm.org/10.1145/3132705},\ndoi = {10.1145/3132705},\nacmid = {3132705},\npublisher = {ACM},\naddress = {New York, NY, USA}\n}\n</code></pre>"},{"location":"surface/algorithms/remeshing/","title":"Remeshing","text":"Original Remeshed <p>These routines try to improve mesh quality using repeated rounds of vertex position smoothing, edge flipping, and edge splits/collapses.</p> <code>void remesh(ManifoldSurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; geom, RemeshOptions options = defaultRemeshOptions);</code> <p>Remesh a mesh using vertex smoothing along with edge splits, collapses, and flips. Options are passed as a RemeshOptions object.</p> <code>void remesh(ManifoldSurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; geom, MutationManager&amp; mm, RemeshOptions options = defaultRemeshOptions);</code> <p>Remesh a mesh using vertex smoothing along with edge splits, collapses, and flips. Options are passed as a RemeshOptions object. All mesh mutations are performed through a <code>MutationManager</code> object, which can e.g. keep special vertices fixed or run callback functions when certain mesh mutations occur.</p>"},{"location":"surface/algorithms/remeshing/#tangential-vertex-smoothing","title":"Tangential Vertex Smoothing","text":"<p>Vertex smoothing moves each vertex towards the average of its neighborhood. This average can be computed in two ways: in circumentric smoothing, every vertex is moved towards the area-weighted average of the circumcenters of its neighboring faces (as in [Chen &amp; Holst 2011]), whereas in Laplacian smoothing, every vertex is moved towards the average of the positions of its neighboring vertices.</p> <p>In either case we perform tangential smoothing, meaning that we only move vertices tangentially along the surface. </p> <code>double smoothByCircumcenter(ManifoldSurfaceMesh&amp; mesh, VertexPositionGeometry&amp; geom, double stepSize = 1, RemeshBoundaryCondition bc = RemeshBoundaryCondition::Tangential);</code> <p>Move each vertex tangentially towards the area-weighted average of its neighboring face circumcenters. Returns the average amount that each vertex was moved by.</p> <code>double smoothByCircumcenter(ManifoldSurfaceMesh&amp; mesh, VertexPositionGeometry&amp; geom, MutationManager&amp; mm, double stepSize = 1, RemeshBoundaryCondition bc = RemeshBoundaryCondition::Tangential);</code> <p>Move each vertex tangentially towards the area-weighted average of its neighboring face circumcenters , using the provided <code>MutationManager</code> to move the vertices Returns the average amount that each vertex was moved by.</p> <code>double smoothByLaplacian(ManifoldSurfaceMesh&amp; mesh, VertexPositionGeometry&amp; geom, double stepSize = 1, RemeshBoundaryCondition bc = RemeshBoundaryCondition::Tangential);</code> <p>Move each vertex tangentially towards the average of its neighbors Returns the average amount that each vertex was moved by.</p> <code>double smoothByLaplacian(ManifoldSurfaceMesh&amp; mesh, VertexPositionGeometry&amp; geom, MutationManager&amp; mm, double stepSize = 1, RemeshBoundaryCondition bc = RemeshBoundaryCondition::Tangential);</code> <p>Move each vertex tangentially towards the average of its neighbors, using the provided <code>MutationManager</code> to move the vertices Returns the average amount that each vertex was moved by.</p>"},{"location":"surface/algorithms/remeshing/#boundary-conditions","title":"Boundary Conditions","text":"<p>The boundary conditions for smoothing can be set to <code>RemeshBoundaryCondition::Tangential</code>, <code>RemeshBoundaryCondition::Fixed</code>, or <code>RemeshBoundaryCondition::Free</code>. Tangential smoothing allows boundary vertices to move along the tangent direction to the boundary curve, fixed smoothing fixes the boundary vertices, and free smoothing allows boundary vertices to move along any direction in the surface\u2019s tangent plane. Leaving boundary vertices free allows the mesh to degenerate, so it is not recommended unless you impose additional constraints.</p>"},{"location":"surface/algorithms/remeshing/#extrinsic-delaunay-flipping","title":"Extrinsic Delaunay Flipping","text":"<p>Delaunay flipping performs edge flips to improve triangle quality.</p> <p>No guarantees</p> <p>Unlike the intrinsic Delaunay flipping routines, extrinsic flipping algorithms are not guaranteed to produce a Delaunay mesh. Nonetheless, these edge flips generally improve triangle quality in practice.</p> <code>size_t fixDelaunay(ManifoldSurfaceMesh&amp; mesh, VertexPositionGeometry&amp; geom);</code> <p>Try to make all triangles Delaunay using extrinsic edge flips. Returns the number of flips performed.</p> <code>size_t fixDelaunay(ManifoldSurfaceMesh&amp; mesh, VertexPositionGeometry&amp; geom, MutationManager&amp; mm);</code> <p>Try to make all triangles Delaunay using extrinsic edge flips, using the provided <code>MutationManager</code> to flip edges. Returns the number of flips performed.</p>"},{"location":"surface/algorithms/remeshing/#edge-length-adjustment","title":"Edge Length Adjustment","text":"<p>These routines perform edge splits and collapses to drive mesh edge lengths towards a target value. If curvature adaptation is enabled, this target length is made shorter in high-curvature areas, leading to more resolution there.</p> <code>bool adjustEdgeLengths(ManifoldSurfaceMesh&amp; mesh, VertexPositionGeometry&amp; geom, RemeshOptions options = defaultRemeshOptions);</code> <p>Apply splits and collapses to adjust edge lengths.</p> <p>Reads the following options from <code>options</code>, with the following default values and meanings:</p> <ul> <li><code>double options.targetEdgeLength = -1</code>: the target edge length in flat regions. If <code>targetEdgeLength</code> is negative, the target length is set relative to the input mesh\u2019s mean length.</li> <li><code>double options.curvatureAdaptation = 0</code>: how much target edge length should vary due to curvature. Set <code>curvatureAdaptation</code> to zero if you want edge lengths to be approximately <code>targetEdgeLength</code> everywhere.</li> <li><code>double options.minRelativeLength = 0.05</code>: the minimum possible edge length in the output mesh. Defined relative to <code>targetEdgeLength</code>.</li> </ul> <code>bool adjustEdgeLengths(ManifoldSurfaceMesh&amp; mesh, VertexPositionGeometry&amp; geom, MutationManager&amp; mm, RemeshOptions options = defaultRemeshOptions);</code> <p>Apply splits and collapses to adjust edge lengths. All splits and collapses are performed using the provided <code>MutationManager</code>.</p> <p>Reads the following options from <code>options</code>, with the following default values and meanings:</p> <ul> <li><code>double options.targetEdgeLength = -1</code>: the target edge length in flat regions. If <code>targetEdgeLength</code> is negative, the target length is set relative to the input mesh\u2019s mean length.</li> <li><code>double options.curvatureAdaptation = 0</code>: how much target edge length should vary due to curvature. Set <code>curvatureAdaptation</code> to zero if you want edge lengths to be approximately <code>targetEdgeLength</code> everywhere.</li> <li><code>double options.minRelativeLength = 0.05</code>: the minimum possible edge length in the output mesh. Defined relative to <code>targetEdgeLength</code>.</li> </ul>"},{"location":"surface/algorithms/remeshing/#helper-types","title":"Helper Types","text":""},{"location":"surface/algorithms/remeshing/#options","title":"Options","text":"<p>Options are passed in to <code>remesh</code> via a <code>RemeshOptions</code> object.</p> Field Default value Meaning <code>double targetEdgeLength</code> <code>-1</code> the target edge length in flat regions. If <code>targetEdgeLength</code> is negative, the target edge length is set to relative the input mesh\u2019s mean edge length <code>size_t maxIterations</code> <code>10</code> the maximum number of iterations to run for <code>double curvatureAdaptation</code> <code>0</code> how much target length should vary due to curvature. Set curvatureAdaptation to 0 if you want edge lengths to be approximately targetEdgeLength everywhere <code>double minRelativeLength</code> <code>0.05</code> the minimum possible edge length allowed in the output mesh. Defined relative to targetEdgeLength <code>RemeshSmoothStyle smoothStyle</code> <code>RemeshSmoothStyle::Circumcentric</code> the type of vertex smoothing to use (either <code>RemeshSmoothStyle::Circumcentric</code> or <code>RemeshSmoothStyle::Laplacian</code>) <code>RemeshBoundaryCondition boundaryCondition</code> <code>RemeshBoundaryCondition::Tangential</code> the type of motions allowed for boundary vertices (either <code>RemeshBoundaryCondition::Fixed</code>, <code>RemeshBoundaryCondition::Tangential</code> or <code>RemeshBoundaryCondition::Free</code>) <p>\u2018Fixed\u2019 boundary may still move slightly</p> <p>Setting <code>boundaryCondition</code> to <code>RemeshBoundaryCondition::Fixed</code> only fixes boundary vertices during vertex smoothing. Boundary edges may still be split or collapsed during edge length adjustment, which can also cause the boundary to move slightly. To stop all motion of the boundary, you can pass in a <code>MutationManager</code> which marks all boundary edges as not splittable or collapsible.</p>"},{"location":"surface/algorithms/robust_geometry/","title":"Robust Geometry","text":"<p>Many data structures and algorithms in geometry-central help to \u201crobustify\u201d algorithms, and help them automatically work better on meshes with poor geometry and/or connectivity. Whenever possible, this done in a way which is transparent to the algorithm designer and end user.</p>"},{"location":"surface/algorithms/robust_geometry/#intrinsic-mollifiction","title":"Intrinsic Mollifiction","text":"<p><code>#include \"geometrycentral/surface/intrinsic_mollification.h\"</code></p> <p>Poor quality meshes might have triangles whose shape is so close to being degenerate that even basic floating point arithmetic breaks down. Such features are difficult to resolve with by perturbing vertex positions, because a motion that makes one triangle better might make another triangle worse. Fortunately, when working with intrinsic geometry, there is a simple strategy which is always guaranteed to work.</p> <p>To ensure that all triangles are nondegenerate, we want to have</p>  l_{ij} + l_{jk} &gt; l_{ki} + \\delta  <p>for all triples of triangle edge lengths, according to some user-specified numerical tolerance \\delta\\delta, which specified how far from degenerate the triangles should be.  This is easily achieved by simply adding some small value \\epsilon\\epsilon to all edge lengths, chosen to be the smallest \\epsilon\\epsilon which will make the above inequality hold. </p> <p>This strategy ensures all triangles are non-degenerate, yet yields a negligible change to the mesh\u2019s geometry. For a mesh which already has no degenerate triangles, it will have no effect.</p> <p>Example:</p> <pre><code>#include \"geometrycentral/surface/intrinsic_mollification.h\"\nusing namespace geometrycentral;\nusing namespace surface;\n\n// your mesh and intrinsic geometry\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;EdgeLengthGeometry&gt; geometry;\n\n// mollify the edge lengths\nmollifyIntrinsic(*mesh, geometry-&gt;edgeLengths);\n\n// ensure that any existing quantities are updated for the new edge lengths\ngeometry-&gt;refreshQuantities();\n\n// continue running algorithms, etc\ngeometry-&gt;requireVertexGaussianCurvatures();\nfor(Vertex v : mesh-&gt;vertices()) {\nstd::cout &lt;&lt; \"Gaussian curvature of \" &lt;&lt; v &lt;&lt; \" is \" &lt;&lt; geometry-&gt;vertexGaussianCurvatures[v] &lt;&lt; std::endl;\n}\n</code></pre> <code>void mollifyIntrinsic(SurfaceMesh&amp; mesh, EdgeData&lt;double&gt;&amp; edgeLengths, double relativeFactor = 1e-6)</code> <p>Mollify the edge lengths in <code>edgeLengths</code>, to ensure that all triangles are nondegenerate by a factor \\delta\\delta, where \\delta\\delta is computed as <code>relativeFactor</code> times the mean edge length in the input.</p> <code>void mollifyIntrinsicAbsolute(SurfaceMesh&amp; mesh, EdgeData&lt;double&gt;&amp; edgeLengths, double absoluteFactor)</code> <p>Similar to above, but mollifies with an absolute factor given by <code>absoluteFactor</code>, rather than a relative factor.</p> <p>This strategy is described in A Laplacian for Nonmanifold Triangle Meshes. The appropriate citation is:</p> <pre><code>@article{Sharp:2020:LNT,\nauthor={Nicholas Sharp and Keenan Crane},\ntitle={{A Laplacian for Nonmanifold Triangle Meshes}},\njournal={Computer Graphics Forum (SGP)},\nvolume={39},\nnumber={5},\nyear={2020}\n}\n</code></pre>"},{"location":"surface/algorithms/stripes/","title":"Stripes","text":"<p>The Stripe Patterns on Surfaces algorithm efficiently computes evenly-spaced stripes on a surface, aligned with some direction field given as input. This section describes an implementation in geometry-central, along with functions to extract the isolines of the stripes as polyline curves along the surface.</p> <p>Authors: Original algorithm by Felix Kn\u00f6ppel, Keenan Cranel, Ulrich Pinkall, Peter Schr\u00f6der. Extraction &amp; geometry-central integration by David Jourdan.</p> <p><code>#include \"geometrycentral/surface/stripe_patterns.h\"</code></p> <p></p> <p>Example <pre><code>// Generate a guiding field\nVertexData&lt;Vector2&gt; guideField =\ngeometrycentral::surface::computeSmoothestVertexDirectionField(*geometry, 2);\n\n// Compute the stripe pattern\ndougle constantFreq = 40.;\nVertexData&lt;double&gt; frequencies(*mesh, constantFreq);\nCornerData&lt;double&gt; periodicFunc;\nFaceData&lt;int&gt; zeroIndices;\nFaceData&lt;int&gt; branchIndices;\nstd::tie(periodicFunc, zeroIndices, branchIndices) =\ncomputeStripePattern(*geometry, frequencies, guideField);\n\n// Extract isolines\nstd::vector&lt;Vector3&gt; isolineVerts;\nstd::vector&lt;std::array&lt;size_t, 2&gt;&gt; isolineEdges;\nstd::tie(isolineVerts, isolineEdges) = extractPolylinesFromStripePattern(\n*geometry, periodicFunc, zeroIndices, branchIndices, guideField, false);\n</code></pre></p>"},{"location":"surface/algorithms/stripes/#stripe-patterns","title":"Stripe Patterns","text":"<p>No surface interpolation</p> <p>The Stripe Patterns paper describes a customized interpolation scheme to smoothly extend the scalar function on the interior of each triangle, even in the presence of singularities. That scheme is not yet implemented here; this implementation just computes a scalar function per-corner and extracts isolines.</p> <code>std::tuple&lt;CornerData&lt;double&gt;, FaceData&lt;int&gt;, FaceData&lt;int&gt;&gt; computeStripePattern(IntrinsicGeometryInterface&amp; geometry, const VertexData&lt;double&gt;&amp; frequencies, const VertexData&lt;Vector2&gt;&amp; directionField)</code> <p>Compute a stripe pattern on the surface.</p> <p>The direction field should be a 2-symmetric vector field, in the complex power representation.</p> <code>std::tuple&lt;std::vector&lt;Vector3&gt;, std::vector&lt;std::array&lt;size_t, 2&gt;&gt;&gt; extractPolylinesFromStripePattern(EmbeddedGeometryInterface&amp; geometry, const CornerData&lt;double&gt;&amp; values, const FaceData&lt;int&gt;&amp; stripeIndices, const FaceData&lt;int&gt;&amp; fieldIndices, const VertexData&lt;Vector2&gt;&amp; directionField, bool connectOnSingularities)</code> <p>Process a stripe pattern ot extract isolines of the stripes as explicit polylines.</p> <p>The direction field should be a 2-symmetric vector field, in the complex power representation.</p> <p>Can optionally connect isolines separated by a singularity using a directionField alignment heuristic</p> <code>std::tuple&lt;std::vector&lt;Vector3&gt;, std::vector&lt;std::array&lt;size_t, 2&gt;&gt;&gt; computeStripePatternPolylines(EmbeddedGeometryInterface&amp; geometry, const VertexData&lt;double&gt;&amp; frequencies, const VertexData&lt;Vector2&gt;&amp; directionField, bool connectIsolinesOnSingularities = true)</code> <p>Runs both of the above functions, computing the stripe pattern and extracting polylines from it.</p> <p>The direction field should be a 2-symmetric vector field, in the complex power representation.</p>"},{"location":"surface/algorithms/stripes/#citation","title":"Citation","text":"<p>These algorithms are described in Stripe Patterns on Surfaces</p> <pre><code>@article{Knoppel:2015:SPS,\nauthor = {Kn\\\"{o}ppel, Felix and Crane, Keenan and Pinkall, Ulrich and Schr\\\"{o}der, Peter},\ntitle = {Stripe Patterns on Surfaces},\njournal = {ACM Trans. Graph.},\nvolume = {34},\nissue = {4},\nyear = {2015},\npublisher = {ACM},\naddress = {New York, NY, USA},\n}\n</code></pre>"},{"location":"surface/algorithms/surface_centers/","title":"Surface Centers","text":"<p>These routines compute geometric centers of point sets and distrubtions on surfaces.</p> <p>A \u201ccenter\u201d c is a point on the surface which is a local minimum of the energy: $$ c = \\underset{m}{\\textrm{argmin}}\\sum_{y \\in \\mathcal{Y}} d(m,y)^p $$ where \\mathcal{Y}\\mathcal{Y} is a set of sites to take the average of and d(\\cdot, \\cdot)d(\\cdot, \\cdot) denotes the geodesic distance.</p> <p>Centers on surfaces with p=2p=2 (\u201cmeans\u201d) are known as Karcher Means or Frechet Means. Centers on surfaces with p=1p=1 (\u201cmedians\u201d) are known as geometric medians.</p> <p>Centers are not unique!</p> <p>In general, there will not be a single unqiue \u201ccenter\u201d of a point set or distribution on a surface. For nearby sites there may be a single center, but in general this may not be the case.</p> <p>The routines in this section use random initialization to report a center. As such, the results may be different under repeated runs of the procedure.</p> <p><code>#include \"geometrycentral/surface/surface_centers.h\"</code></p> <p></p>"},{"location":"surface/algorithms/surface_centers/#centers-of-points","title":"Centers of points","text":"<code>SurfacePoint findCenter(IntrinsicGeometryInterface&amp; geom, const std::vector&lt;Vertex&gt;&amp; vertexPts, int p = 2)</code> <p>Find a center of a collection of points at vertices.</p> <p><code>p</code> must be either 11 or 22.</p> <code>SurfacePoint findCenter(IntrinsicGeometryInterface&amp; geom, VectorHeatMethodSolver&amp; solver, const std::vector&lt;Vertex&gt;&amp; vertexPts, int p = 2)</code> <p>Like the above method, but uses an existing solver object, which saves precomputation.</p>"},{"location":"surface/algorithms/surface_centers/#centers-of-distributions","title":"Centers of distributions","text":"<code>SurfacePoint findCenter(IntrinsicGeometryInterface&amp; geom, const VertexData&lt;double&gt;&amp; distribution, int p = 2)</code> <p>Find a center of a distribution at vertices.</p> <p>Note that the input <code>distribution</code> is treated as integrated values at vertices. If your distribution is \u201cper-unit-area\u201d, you should multiply times vertex area before passing it in.</p> <p><code>p</code> must be either 11 or 22.</p> <code>SurfacePoint findCenter(IntrinsicGeometryInterface&amp; geom, VectorHeatMethodSolver&amp; solver, const VertexData&lt;double&gt;&amp; distribution, int p = 2)</code> <p>Like the above method, but uses an existing solver object, which saves precomputation.</p>"},{"location":"surface/algorithms/surface_centers/#citation","title":"Citation","text":"<p>These algorithms are described in The Vector Heat Method, the appropriate citation is:</p> <pre><code>@article{sharp2019vector,\ntitle={The Vector Heat Method},\nauthor={Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan},\njournal={ACM Transactions on Graphics (TOG)},\nvolume={38},\nnumber={3},\npages={24},\nyear={2019},\npublisher={ACM}\n}\n</code></pre>"},{"location":"surface/algorithms/surface_sampling/","title":"Surface Sampling","text":""},{"location":"surface/algorithms/surface_sampling/#poisson-disk-sampling","title":"Poisson disk sampling","text":"<p>The <code>PoissonDiskSampler</code> class contains a function that Poisson disk-samples a surface mesh so that each pair of sampled points are at a minimum distance r away from each other. This ensures that sampled points are distributed evenly in 3D space. Technically, Poisson disk sampling on surfaces should ensure that points are at least a certain geodesic distance away from each other. But for the purposes of visualization, it can be better to use extrinsic distance of the embedded surface instead, since this will ensure that the sampling looks even \u2013 two points could have a large geodesic distance between them but be very near each other in 3D space, which might lead to a visually crowded image.</p> <p>Currently the algorithm only works on manifold meshes.</p> <p><code>#include \"geometrycentral/surface/poisson_disk_sampler.h\"</code></p> <p>The algorithm has a few parameters that roughly correspond to the algorithm of Bridson\u2019s 2007 Fast Poisson Disk Sampling in Arbitrary Dimensions.</p> <p>Additionally, you can specify points around samples should be avoided (shown in red below.) By default, samples will avoid these points with the same radius <code>r</code> used in the rest of the algorithm. You can optionally specify a \u201cradius of avoidance\u201d for these points, where the radius of avoidance is given in multiples of <code>r</code>. </p> <p>The radius of avoidance can be further be specified to be a radius in 3D space, or a radius in terms of distance along the surface. The former will produce a radius of avoidance that will appear perfectly round and is likely more visually pleasing, but for very large radii may occlude samples from opposite sides of the mesh. The latter will restrict the radius of avoidance to only be along the surface, but such a metric ball will not appear perfectly round, especially in areas with very large and sudden changes in curvature.</p> <p></p> <code>PoissonDiskSampler::PoissonDiskSampler(ManifoldSurfaceMesh&amp; mesh, VertexPositionGeometry&amp; geometry)</code> <p>Create a new solver to Poisson disk-sample on the given mesh with the given geometry.</p> <ul> <li><code>mesh</code> specifies the mesh. It must be manifold, since the sampling depends on the <code>traceGeodesic</code> function.</li> <li><code>geometry</code> specifies the <code>VertexPositionGeometry</code> needed to describe the positions of vertices in 3D space.</li> </ul> <p>The mesh and geometry cannot be changed after construction.</p> <code>std::vector&lt;SurfacePoint&gt; PoissonDiskSampler::sample(double rCoef = 1.0, int kCandidates = 30, std::vector&lt;SurfacePoint&gt; pointsToAvoid = std::vector&lt;SurfacePoint&gt;(), int rAvoidance = 1, bool use3DAvoidanceRadius = true);</code> <p>Poisson disk-sample the surface mesh.</p> <ul> <li><code>rCoef</code>: corresponds to the minimum distance between samples, expressed as a multiple of the mean edge length. The actual minimum distance is computed as <code>r = rCoef * meanEdgeLength</code></li> <li><code>kCandidates</code>: the number of candidate points chosen from the (r,2r)-annulus around each sample.</li> <li><code>pointsToAvoid</code>: SurfacePoints which samples should avoid.</li> <li><code>rAvoidance</code>: the radius of avoidance around each point to avoid, expressed as a multiple of <code>r</code>.</li> <li><code>use3DAvoidanceRadius</code>: If true, the radius of avoidance will specify a solid ball in 3D space around which samples are avoided. Otherwise, samples are avoided within a ball on the surface.</li> </ul>"},{"location":"surface/algorithms/surface_sampling/#example","title":"Example","text":"<pre><code>#include \"geometrycentral/surface/manifold_surface_mesh.h\"\n#include \"geometrycentral/surface/vertex_position_geometry.h\"\n#include \"geometrycentral/surface/meshio.h\"\n#include \"geometrycentral/surface/surface_point.h\"\n#include \"geometrycentral/surface/poisson_disk_sampler.h\"\n\n\n// Load a mesh\nstd::unique_ptr&lt;ManifoldSurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readManifoldSurfaceMesh(filename);\n\n// construct a solver\nPoissonDiskSampler poissonSampler(*mesh, *geometry);\nstd::vector&lt;SurfacePoint&gt; samples = poissonSampler.sample(); // sample using default parameters\n</code></pre>"},{"location":"surface/algorithms/vector_heat_method/","title":"Vector Heat Method","text":"<p>This section describes the Vector Heat Method in geometry-central, which computes parallel transport of vectors using heat flow, and applications that follow from it.</p> <p>Note that these quantities all depend on the intrinsic geometry of a surface (via the <code>IntrinsicGeometryInterface</code>). Therefore, these routines can be run on abstract geometric domains as well as traditional surfaces in 3D.</p> <p>These algorithms are described in The Vector Heat Method. </p> <p><code>#include \"geometrycentral/surface/vector_heat_method.h\"</code></p>"},{"location":"surface/algorithms/vector_heat_method/#vector-heat-solver","title":"Vector Heat Solver","text":"<p>The stateful class <code>VectorHeatSolver</code> shares precomputation for all of the routines below.</p> <code>VectorHeatSolver::VectorHeatSolver(IntrinsicGeometryInterface&amp; geom, double tCoef=1.0)</code> <p>Create a new solver for the Vector Heat Method. Precomputation is performed lazily as needed.</p> <ul> <li> <p><code>geom</code> is the geometry (and hence mesh) on which to compute. Note that nearly any geometry object (<code>VertexPositionGeometry</code>, etc) can be passed here.</p> </li> <li> <p><code>tCoef</code> is the time to use for short time heat flow, as a factor <code>m * h^2</code>, where <code>h</code> is the mean edge length. The default value of <code>1.0</code> is almost always sufficient.</p> </li> </ul> <p>Algorithm options (like <code>tCoef</code>) cannot be changed after construction; create a new solver object with the new settings.</p>"},{"location":"surface/algorithms/vector_heat_method/#scalar-extension","title":"Scalar Extension","text":"<p>Given scalar data defined at isolated source locations on a surface, extend it to the entire domain. Each point on the domain will take the value of the nearest source point.  Note that the fast diffusion algorithm means the result is a slightly smoothed-out field.</p> <p></p> <p>Example: <pre><code>// your mesh and geometry\nVertexPositionGeometry geometry;\nSurfaceMesh mesh;\n\n// construct a solver\nVectorHeatMethodSolver vhmSolver(geometry);\n\n// some interesting source values\nstd::vector&lt;std::tuple&lt;Vertex, double&gt;&gt; points;\nfor (/* ... some inputs ... */ ) {\nVertex sourceVert = /* something */;\ndouble sourceVal = /* something */;\npoints.emplace_back(sourceVert, sourceVal);\n}\n\n// solve!\nVertexData&lt;double&gt; scalarExtension = vhmSolver-&gt;extendScalar(points);\n</code></pre></p> <code>VertexData&lt;double&gt; VectorHeatSolver::extendScalar( const std::vector&lt;std::tuple&lt;Vertex, double&gt;&gt;&amp; sources)</code> <p>Compute the nearest-neighbor extension of scalar data defined at isolated vertices to the entire domain.  The input is a list of vertices and their corresponding values.</p> <code>VertexData&lt;double&gt; VectorHeatSolver::extendScalar( const std::vector&lt;std::tuple&lt;SurfacePoint, double&gt;&gt;&amp; sources)</code> <p>Compute the nearest-neighbor extension of scalar data defined at isolated points to the entire domain.  The input is a list of surface points and their corresponding values.</p>"},{"location":"surface/algorithms/vector_heat_method/#vector-extension","title":"Vector Extension","text":"<p>Given tangent vectors defined at one or more isolated source locations on a surface, extend transport the vectors across the entire domain according to parallel transport. Each point on the domain will take the value of the nearest source point.  Note that the fast diffusion algorithm means the result is a slightly smoothed-out field.</p> <code>VertexData&lt;Vector2&gt; VectorHeatSolver::transportTangentVectors(Vertex sourceVert, Vector2 sourceVec)</code> <p>Compute the parallel transport of a vector defined at a single vertex to the entire domain. The input is defined in the tangent space of the source vertex.</p> <code>VertexData&lt;Vector2&gt; VectorHeatSolver::transportTangentVectors( const std::vector&lt;std::tuple&lt;Vertex, Vector2&gt;&gt;&amp; sources)</code> <p>Compute the parallel transport of vectors defined at a collection of vertices to the entire domain. The input is defined in the tangent space of each the source vertex.</p> <code>VertexData&lt;Vector2&gt; VectorHeatSolver::transportTangentVectors( const std::vector&lt;std::tuple&lt;SurfacePoint, Vector2&gt;&gt;&amp; sources)</code> <p>Compute the parallel transport of vectors defined at a collection of surface points to the entire domain. The input is defined in the tangent space of each the vertex, face, or edge respectively.</p>"},{"location":"surface/algorithms/vector_heat_method/#logarithmic-map","title":"Logarithmic Map","text":"<p>The logarithmic map is a very special 2D local parameterization of a surface about a point, where for each point on the surface the magnitude of the log map gives the geodesic distance from the source, and the polar coordinate of the log map gives the direction at which a geodesic must leave the source to arrive at the point.</p> <p></p> <p>These routines compute the logarithmic map using the vector heat method.</p> <code>VertexData&lt;Vector2&gt; VectorHeatSolver::computeLogMap(const Vertex&amp; sourceVert)</code> <p>Compute the logarithmic map with respect to the given source vertex.</p> <p>The angular coordinate of the log map will be respect to the tangent space of the source vertex.</p> <code>VertexData&lt;Vector2&gt; VectorHeatSolver::computeLogMap(const SurfacePoint&amp; sourceP)</code> <p>Compute the logarithmic map with respect to the given source point, which is a general surface point.</p> <p>The angular coordinate of the log map will be respect to the tangent space of the source vertex, edge, or face.</p>"},{"location":"surface/algorithms/vector_heat_method/#citation","title":"Citation","text":"<p>If these algorithms contribute to academic work, please cite the following paper:</p> <pre><code>@article{sharp2019vector,\ntitle={The Vector Heat Method},\nauthor={Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan},\njournal={ACM Transactions on Graphics (TOG)},\nvolume={38},\nnumber={3},\npages={24},\nyear={2019},\npublisher={ACM}\n}\n</code></pre>"},{"location":"surface/geometry/geometry/","title":"Overview","text":"<p>While the halfedge mesh encodes the connectivity of a surface, this section covers the classes which sit atop a halfedge mesh to define its geometry.</p> <p>The first section below explains the class structure used to expose geometric logic, and the second section explains the system of automatically-cached quantities.</p>"},{"location":"surface/geometry/geometry/#geometry-hierarchy","title":"Geometry hierarchy","text":"<p>TL;DR</p> <p>Construct a <code>VertexPositionGeometry</code> object using vertex positions; it offers all the geometric routines you would expect, and can be passed to any method that demands geometry.</p> <p>Many algorithms can actually operate on weaker data than vertex positions. Read on to learn more.</p> <p>Geometry central is intentionally designed to allow flexibility in defining the geometry of a surface. Traditional code might assume a 3D position for every vertex, but many algorithms actually need only the intrinsic geometry of a surface, aka the edge lengths. More generally, specifying algorithms to only use the geometric data they really need allows us to seamlessly leverage powerful techniques.</p> <p>We (sparingly) make use of polymorphism via inheritance in C++ to encode a hierarchy of geometric quantities that one might compute for a surface. </p> <ul> <li>Interfaces define which quantities can be computed from the geometry; for instance, an <code>EmbeddedGeometryInterface</code> can compute face normals, and it can also compute face areas because it extends the more basic <code>IntrinsicGeometryInterface</code>. Interfaces are abstract, and cannot be instantiated by themselves.</li> <li>Realizations are concrete classes that allow the user instantiate a geometry object from data; for instance, a <code>VertexPositionGeometry</code> can be constructed from vertex positions, and implements the <code>EmbeddedGeometryInterface</code> giving access to a wide range of intrinsic and extrinsic geometric quantities.</li> </ul> <p>The following diagram outlines the interfaces and realizations currently available.</p> <p></p>"},{"location":"surface/geometry/geometry/#quantity-management","title":"Quantity management","text":""},{"location":"surface/geometry/geometry/#immediate-computation","title":"Immediate computation","text":"<p>In the most basic usage, realizations can compute simple quantities for a given element directly from input data. For instance, <code>double VertexPositionGeometry::faceArea(Face f)</code> will compute the area of a face.  However, this is not the typical intended method for working with geometric quantities in geometry central.</p>"},{"location":"surface/geometry/geometry/#managed-quantities","title":"Managed quantities","text":"<p>A common pattern in geometry code is to maintain precomputed arrays of values that are used repeatedly (e.g. vertex normals). However, naive use of this pattern requires the programmer to coordinate these arrays throughout their codebase, or risk computing and storing the same array many times in distant subroutines. Geometry central embraces this pattern, and provides automatic support for proper use of it.</p> <p>All geometry objects automatically maintain of system of caches for geometric quantities; the user can simply call (for instance) <code>geometry.requireFaceAreas()</code> at the beginning of a subroutine to ensure that the face area buffer is populated, then access <code>geometry.faceAreas[f]</code> in any subsequent code. This strategy keep storage and computation to a minimum by sharing repeated values across any use of the geometry object.</p> <p>The following example demonstrates immediate computation vs cached quantities. <pre><code>VertexPositionGeometry&amp; geometry = /* ... */;\n\n// bad: immediate computation everywhere\nfor(Face f : mesh-&gt;faces()) {\nVector3 normal = geometry.faceNormal(f);\n}\n\n// good: automatic caching and storage\ngeometry.requireFaceNormals();\nfor(Face f : mesh-&gt;faces()) {\nVector3 normal = geometry.faceNormals[f];\n}\n</code></pre></p> <p>In fact, the inheritance in this design allows geometry central to leverage alternate ways of computing a quantity depending on the underlying data available. For instance, face areas are computed for an <code>EdgeLengthGeometry</code> using Heron\u2019s rule, but for a <code>VertexPositionGeometry</code> a faster and more stable edge cross-product is used. Of course, this is all happening under the hood\u2013 the user just needs to call <code>myGeometry.requireFaceAreas()</code>.</p>"},{"location":"surface/geometry/geometry/#dependencies","title":"Dependencies","text":"<p>In addition, dependencies between these quantities are managed internally; for instance, if vertex normals are requested, face normals will be internally populated and used to compute vertex normals. However, these dependencies are internal and subject to change; the programmer should always explicitly call <code>geometry.requireFaceNormals()</code> if they intend to access face normals.</p>"},{"location":"surface/geometry/geometry/#updating","title":"Updating","text":"<p>If the underlying geometric data changes (e.g., vertices are moved or the mesh is mutated), invoking <code>geometry.refreshQuantities()</code> will recompute all required values.</p>"},{"location":"surface/geometry/geometry/#minimizing-storage-usage","title":"Minimizing storage usage","text":"<p>To minimize memory usage, invoke <code>geometry.unrequireFaceNormals()</code> at the conclusion of a subroutine to indicate that the quantity is no longer needed, decrementing an internal counter. The quantity is not instantly deleted after being un-required, but invoking <code>geometry.purgeQuantities()</code> will delete any quantities that are not currently required, reducing memory usage. Most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object.</p>"},{"location":"surface/geometry/geometry/#quantity-api","title":"Quantity API","text":"<p><code>#include \"geometrycentral/surface/geometry.h\"</code> to get all geometry interfaces.</p> <p>All quantities offer methods and storage following the same naming pattern. For a quantity named <code>YYYs</code> (e.g. <code>faceAreas</code>), which is defined in an interface <code>GeometryInterface</code> (e.g. <code>IntrinsicGeometry</code>) the pattern is given below. </p> <p>An exauhstive list is given in quantities.</p> <code>MeshData&lt;&gt; GeometryInterface::YYYs</code> <p>The member variable array for quantity YYY. Initially empty, but can be populated with <code>requireYYYs()</code> below.</p> <p>For instance, for the quantity face areas, there is a member <code>FaceData&lt;double&gt; IntrinsicGeometry::faceAreas</code>.</p> <code>void GeometryInterface::requireYYYs()</code> <p>Request that the buffer for quantity YYYs be populated. If it is already populated the method will return right away, otherwise the quantity will be computed.</p> <p>For instance, for the quantity face areas, one would call <code>IntrinsicGeometry::requireFaceAreas()</code>.</p> <code>void GeometryInterface::unrequireYYYs()</code> <p>Indicate that the buffer for quantity YYYs no longer needs to be populated. Internally decrements a counter; once there is a <code>unrequireYYYs()</code> for every <code>requireYYYs()</code> call, the quantity can be purged by <code>GeometryInterface::purgeQuantities()</code>.</p> <p>For instance, for the quantity face areas, one would call <code>IntrinsicGeometry::unrequireFaceAreas()</code>.</p> <p>Note: most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object. This functionality can be used only if reducing memory usage is very important.</p> <code>T GeometryRealization::computeYYY(Element e)</code> <p>Immediate computation: rather than using the caching system described above, directly compute the value from the input data. </p> <p>Only available for quantities which can be easily computed in O(1) from inputs (e.g. face normals), but not for quantities with significant dependencies (e.g. vertex normals, which depend on all incident face normals).</p> <p>For instance, face areas can be immediately computed with <code>double VertexPositionGeometry::faceArea(Face f)</code>.</p> <p>Note: immediate computation is generally only preferred if you are frequently changing the geometry; managed quantities are the primary method for computing geometric values.</p> <p>In addition, the caching system provides two methods.</p> <code>void GeometryInterface::refreshQuantities()</code> <p>Recompute all required quantities from the input geometric data.</p> <p>Should be called, for instance if vertices are moved or the underlying mesh is mutated.</p> <code>void GeometryInterface::purgeQuantities()</code> <p>Delete all cached quantities which are not currently <code>require()</code>\u2018d, reducing memory usage.</p> <p>Note: most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object. This functionality can be used only if reducing memory usage is very important.</p>"},{"location":"surface/geometry/geometry/#interfaces","title":"Interfaces","text":"<p>Interfaces are abstract classes which define which quantities are available for a given geometry, and compute/manage caches of these quantities.</p> <p>For the full list of the managed quantities that can be computed by these interfaces, see the quantities section.</p> Base Geometry Intrinsic Geometry Extrinsic Geometry Embedded Geometry"},{"location":"surface/geometry/geometry/#base-geometry","title":"Base Geometry","text":"<p>Class: <code>BaseGeometryInterface</code></p> <p>This is a simple base class which is serves as a parent of all geometry interfaces. It does not actually correspond to any geometric data, and the only quantities it manages are convenience element indices.</p> <p><code>#include \"geometrycentral/surface/base_geometry_interface.h\"</code></p>"},{"location":"surface/geometry/geometry/#intrinsic-geometry","title":"Intrinsic Geometry","text":"<p>Class: <code>IntrinsicGeometryInterface</code></p> <p>Extends <code>BaseGeometryInterface</code>. These quantites depend only on the notion of lengths and angles on the surface, but not how it might sit in space.</p> <p><code>#include \"geometrycentral/surface/intrinsic_geometry_interface.h\"</code></p> <p>An intrinsic geometry can be instantiated via any of the realizations which inherit from it:</p> <ul> <li><code>EdgeLengthGeometry</code></li> <li><code>VertexPositionGeometry</code> (additionally inherits from the child <code>EmbeddedGeometryInterface</code>)</li> </ul>"},{"location":"surface/geometry/geometry/#extrinsic-geometry","title":"Extrinsic Geometry","text":"<p>Class: <code>ExtrinsicGeometryInterface</code></p> <p>Extends <code>IntrinsicGeometryInterface</code>. These quantites depend on extrinsic angles (like dihedral angles at edges), but are rotation-invariant.</p> <p><code>#include \"geometrycentral/surface/extrinsic_geometry_interface.h\"</code></p> <p>An extrinsic geometry can be instantiated via any of the realizations which inherit from it:</p> <ul> <li><code>VertexPositionGeometry</code> (additionally inherits from the child <code>EmbeddedGeometryInterface</code>)</li> </ul> <p>Note that there is not currently any realization which instantiates an <code>ExtrinsicGeometryInterface</code> which is not also an <code>EmbeddedGeometryInterface</code>, but such a realization might one day exist.</p>"},{"location":"surface/geometry/geometry/#embedded-geometry","title":"Embedded Geometry","text":"<p>Class: <code>EmbeddedGeometryInterface</code></p> <p>Extends <code>ExtrinsicGeometryInterface</code>. These quantites depend explicitly on how the surface sits in 3D space.</p> <p><code>#include \"geometrycentral/surface/embedded_geometry_interface.h\"</code></p> <p>An embedded geometry can be instantiated via any of the realizations which inherit from it:</p> <ul> <li><code>VertexPositionGeometry</code></li> </ul>"},{"location":"surface/geometry/geometry/#realizations","title":"Realizations","text":"<p>Realizations construct a geometry object from input data. There are two widely used realizations in geometry central: VertexPositionGeometry and EdgeLengthGeometry.  Other realizations of geometry can be created as needed to make use of other kinds of data, ranging from small modifications to e.g. make use of predefined tangent spaces, to completely new geometries defined from alternate input data.</p> <p>In addition to the quantities listed in their own section, the realizations each offer a few immediate computations and some utility functions.</p>"},{"location":"surface/geometry/geometry/#vertex-position-geometry","title":"Vertex Position Geometry","text":"<p>The usual notion of geometry for a mesh, with a position in 3D for each vertex. These positions are stored in the member <code>VertexPositionGeometry::vertexPositions</code> (which is inherited from the <code>EmbeddedGeometryInterface</code>). </p> <p>This class inherits from all of the geometry interfaces mentioned above, so all quantities will be available.</p> <p><code>#include \"geometrycentral/surface/vertex_position_geometry.h\"</code></p> <code>void VertexPositionGeometry::VertexPositionGeometry(SurfaceMesh&amp; mesh)</code> <p>Construct a new geometry for the mesh, with all positions set to the origin <code>Vector3{0., 0., 0.,}</code>.</p> <code>void VertexPositionGeometry::VertexPositionGeometry(SurfaceMesh&amp; mesh, const VertexData&lt;Vector3&gt;&amp; positions)</code> <p>Construct a new geometry for a mesh from known vertex positions.</p> <p>The <code>positions</code> input is copied, and stored in the member <code>VertexPositionGeometry::vertexPositions</code>.</p> <code>void VertexPositionGeometry::VertexPositionGeometry(SurfaceMesh&amp; mesh, const Eigen::MatrixBase&lt;T&gt;&amp; positions)</code> <p>Construct a new geometry for a mesh from known vertex positions, where the positions are stored as an Eigen matrix.</p> <p>The input matrix should be a <code>Vx3</code> matrix of floating point values. The <code>Eigen::MatrixBase</code> type is just a generic type which accepts most Eigen matrices as input, including the geometry-central <code>DenseMatrix&lt;&gt;</code> type.</p> <code>std::unique_ptr&lt;VertexPositionGeometry&gt; VertexPositionGeometry::copy()</code> <p>Copy the geometry, creating a new identical geometry on the same mesh. Any <code>require()</code> counts or already-computed quantities are not transferred, the new geometry is a blank slate.</p> <code>std::unique_ptr&lt;VertexPositionGeometry&gt; VertexPositionGeometry::reinterpretTo(SurfaceMesh&amp; targetMesh)</code> <p>Copy the geometry, creating a new identical geometry on <code>targetMesh</code>. The target mesh must be in vertex-correspondence with the input mesh, in the sense that both meshes have the same number of vertices and iterating through the vertex sets yields matching vertices.</p> <p>Any <code>require()</code> counts or already-computed quantities are not transferred, the new geometry is a blank slate.</p> <p>Immediate computations. These routines directly compute geometry quantities from the input data, without touching the caching system. For the full list of available managed quantities, see the quantities section.</p> <code>double VertexPositionGeometry::edgeLength(Edge e)</code> <p>Compute the length of a single edge.</p> <code>double VertexPositionGeometry::faceArea(Face f)</code> <p>Compute the area of a single face.</p> <code>double VertexPositionGeometry::cornerAngle(Corner c)</code> <p>Compute the angle (in radians) formed by the two edges incident on a corner.</p> <code>double VertexPositionGeometry::halfedgeCotanWeight(Halfedge he)</code> <p>Compute the cotangent weight of a hafedge.</p> <code>double VertexPositionGeometry::edgeCotanWeight(Edge e)</code> <p>Compute the cotangent weight of an edge.</p> <code>Vector3 VertexPositionGeometry::faceNormal(Face f)</code> <p>Compute the normal of a face.</p>"},{"location":"surface/geometry/geometry/#edge-length-geometry","title":"Edge Length Geometry","text":"<p>A weaker notion of geometry where one knows only edge lengths. This data turns out to be sufficient to implement many algorithms in geometry processing, and offers valuable flexibility in defining the geometry.</p> <p>This class inherits from the <code>IntrinsicGeometryInterface</code>, so only intrinsic quantities will be available.</p> <p><code>#include \"geometrycentral/surface/edge_length_geometry.h\"</code></p> <code>void EdgeLengthGeometry::EdgeLengthGeometry(SurfaceMesh&amp; mesh, EdgeData&lt;double&gt; edgeLengths)</code> <p>Construct a new geometry for a mesh from known edge lengths.</p> <p>The <code>edgeLengths</code> input is copied, and stored in the member <code>EdgeLengthGeometry::edgeLengths</code> (inherited from <code>IntrinsicGeometryInterface</code>).</p> <code>std::unique_ptr&lt;EdgeLengthGeometry&gt; EdgeLengthGeometry::copy()</code> <p>Copy the geometry, creating a new identical geometry on the same mesh. Any <code>require()</code> counts or already-computed quantities are not transferred, the new geometry is a blank slate.</p> <code>std::unique_ptr&lt;EdgeLengthGeometry&gt; reinterpretTo(SurfaceMesh&amp; targetMesh)</code> <p>Copy the geometry, creating a new identical geometry on <code>targetMesh</code>. The target mesh must be in edge-correspondence with the input mesh, in the sense that both meshes have the same number of edges and iterating through the edge sets yields matching edges.</p> <p>Any <code>require()</code> counts or already-computed quantities are not transferred, the new geometry is a blank slate.</p> <p>Immediate computations. These routines directly compute geometry quantities from the input data, without touching the caching system. For the full list of available managed quantities, see the quantities section.</p> <code>double EdgeLengthGeometry::faceArea(Face f)</code> <p>Compute the area of a single face.</p> <code>double EdgeLengthGeometry::cornerAngle(Corner c)</code> <p>Compute the angle (in radians) formed by the two edges incident on a corner.</p> <code>double EdgeLengthGeometry::halfedgeCotanWeight(Halfedge he)</code> <p>Compute the cotangent weight of a hafedge.</p> <code>double EdgeLengthGeometry::edgeCotanWeight(Edge e)</code> <p>Compute the cotangent weight of an edge.</p>"},{"location":"surface/geometry/quantities/","title":"Quantities","text":"<p>This page enumerates the surface geometry quantities available in geometry central.</p> <p>Recall that these quantities are each associated with a geometry interface specifying what can be computed from the given input data. Instantiating a geometry from data, classes like <code>VertexPositionGeometry</code> extend these interfaces and give access to all of the quantities therein.  Quantities should usually be accessed via the managed caches, as in the example below.</p> <pre><code>#include \"geometrycentral/surface/vertex_position_geometry.h\"\n#include \"geometrycentral/surface/meshio.h\"\nusing namespace geometrycentral::surface;\n\n// Load a mesh and geometry from file\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; positionGeometry;\nstd::tie&lt;mesh, positionGeometry&gt; = readSurfaceMesh(\"spot.obj\");\n\n// For the sake of the example, use an interface type that offers\n// only the quantities which we will actually use below.\nIntrinsicGeometryInterface&amp; geometry = *positionGeometry;\n\n// populate the quantity\ngeometry.requireFaceAreas();\n\nfor(Face f : mesh-&gt;faces()) {\n\n// Managed array holding quantity\ndouble area = geometry.faceAreas[f];\n\n// Immediate computation, computes directly from \n// input data without touching caches.\n// Generally discouraged but occasionally useful.\narea = positionGeometry-&gt;faceArea(f);\n}\n</code></pre>"},{"location":"surface/geometry/quantities/#indices","title":"Indices","text":"<p>These quantities are defined for the base <code>BaseGeometryInterface</code>, and will always be available. They are not actually geometric data, but it is convenient to cache the canonical arrays alongside geometric quantities, as they are often used in concert.</p> vertex indices halfedge indices corner indices edge indices face indices boundary loop indices"},{"location":"surface/geometry/quantities/#vertex-indices","title":"vertex indices","text":"<p>A dense 0-based enumeration of vertices. Equivalent to the result of <code>SurfaceMesh::getVertexIndices()</code>.</p> <ul> <li>member: <code>VertexData&lt;size_t&gt; BaseGeometryInterface::vertexIndices</code></li> <li>require: <code>void BaseGeometryInterface::requireVertexIndices()</code></li> </ul>"},{"location":"surface/geometry/quantities/#halfedge-indices","title":"halfedge indices","text":"<p>A dense 0-based enumeration of halfedges. Equivalent to the result of <code>SurfaceMesh::getHalfedgeIndices()</code>.</p> <ul> <li>member: <code>HalfedgeData&lt;size_t&gt; BaseGeometryInterface::halfedgeIndices</code></li> <li>require: <code>void BaseGeometryInterface::requireHalfedgeIndices()</code></li> </ul>"},{"location":"surface/geometry/quantities/#corner-indices","title":"corner indices","text":"<p>A dense 0-based enumeration of corners. Equivalent to the result of <code>SurfaceMesh::getCornerIndices()</code>.</p> <ul> <li>member: <code>CornerData&lt;size_t&gt; BaseGeometryInterface::cornerIndices</code></li> <li>require: <code>void BaseGeometryInterface::requireCornerIndices()</code></li> </ul>"},{"location":"surface/geometry/quantities/#edge-indices","title":"edge indices","text":"<p>A dense 0-based enumeration of edges. Equivalent to the result of <code>SurfaceMesh::getEdgeIndices()</code>.</p> <ul> <li>member: <code>EdgeData&lt;size_t&gt; BaseGeometryInterface::edgeIndices</code></li> <li>require: <code>void BaseGeometryInterface::requireEdgeIndices()</code></li> </ul>"},{"location":"surface/geometry/quantities/#face-indices","title":"face indices","text":"<p>A dense 0-based enumeration of faces. Equivalent to the result of <code>SurfaceMesh::getFaceIndices()</code>.</p> <ul> <li>member: <code>FaceData&lt;size_t&gt; BaseGeometryInterface::faceIndices</code></li> <li>require: <code>void BaseGeometryInterface::requireFaceIndices()</code></li> </ul>"},{"location":"surface/geometry/quantities/#boundary-loop-indices","title":"boundary loop indices","text":"<p>A dense 0-based enumeration of boundary loops. Equivalent to the result of <code>SurfaceMesh::getBoundaryLoopIndices()</code>.</p> <ul> <li>member: <code>BoundaryLoopData&lt;size_t&gt; BaseGeometryInterface::boundaryLoopIndices</code></li> <li>require: <code>void BaseGeometryInterface::requireBoundaryLoopIndices()</code></li> </ul>"},{"location":"surface/geometry/quantities/#lengths-areas-and-angles","title":"Lengths, areas, and angles","text":"<p>These quantities are defined for any <code>IntrinsicGeometryInterface</code>, which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry.</p> edge length face area vertex dual area corner angles vertex angle sum corner scaled angles halfedge cotan weight edge cotan weight"},{"location":"surface/geometry/quantities/#edge-length","title":"edge length","text":"<p>The length of an edge in the mesh, as a non-negative real number.</p> <ul> <li>member: <code>EdgeData&lt;double&gt; IntrinsicGeometryInterface::edgeLengths</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireEdgeLengths()</code></li> </ul> <p>The inline immediate method can alternately be used to compute this value directly from input data for a single element:</p> <ul> <li>immediate: <code>double VertexPositionGeometry::edgeLength(Edge e)</code></li> </ul>"},{"location":"surface/geometry/quantities/#face-area","title":"face area","text":"<p>The area of a face, as a non-negative real number.</p> <p>May be computed from edge lengths via Heron\u2019s formula, or from embedded vertex positions with a cross product.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>FaceData&lt;double&gt; IntrinsicGeometryInterface::faceAreas</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireFaceAreas()</code></li> </ul> <p>The inline immediate method can alternately be used to compute this value directly from input data for a single element:</p> <ul> <li>immediate: <code>double EdgeLengthGeometry::faceArea(Face f)</code></li> <li>immediate: <code>double VertexPositionGeometry::faceArea(Face f)</code></li> </ul>"},{"location":"surface/geometry/quantities/#vertex-dual-area","title":"vertex dual area","text":"<p>An area associated with each vertex, as a non-negative real number.</p> <p>Only valid on triangular meshes.</p> <p>Defined to be 1/3 the sum of all adjacent face areas. The sum of all vertex dual areas is equal to the usual surface area of the mesh.</p> <ul> <li>member: <code>VertexData&lt;double&gt; IntrinsicGeometryInterface::vertexDualAreas</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireVertexDualAreas()</code></li> </ul> <p>The inline immediate method can be used to compute this value directly from input data for a single element:</p> <ul> <li>immediate: <code>double EdgeLengthGeometry::vertexDualArea(Vertex v)</code></li> <li>immediate: <code>double VertexPositionGeometry::vertexDualArea(Vertex v)</code></li> </ul>"},{"location":"surface/geometry/quantities/#corner-angles","title":"corner angles","text":"<p>The angle between incident edges at each corner of a mesh.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>CornerData&lt;double&gt; IntrinsicGeometryInterface::cornerAngles</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireCornerAngles()</code></li> </ul> <p>The inline immediate method can alternately be used to compute this value directly from input data for a single element:</p> <ul> <li>immediate: <code>double EdgeLengthGeometry::cornerAngle(Corner c)</code></li> <li>immediate: <code>double VertexPositionGeometry::cornerAngle(Corner c)</code></li> </ul>"},{"location":"surface/geometry/quantities/#vertex-angle-sum","title":"vertex angle sum","text":"<p>The sum of corner angles around a vertex.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>VertexData&lt;double&gt; IntrinsicGeometryInterface::vertexAngleSums</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireVertexAngleSums()</code></li> </ul>"},{"location":"surface/geometry/quantities/#corner-scaled-angles","title":"corner scaled angles","text":"<p>The angle between incident edges at each corner of a mesh, linearly rescaled such that the angles around every vertex sum to 2 \\pi2 \\pi. At boundary vertices, no scaling will be performed.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>CornerData&lt;double&gt; IntrinsicGeometryInterface::cornerScaledAngles</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireCornerScaledAngles()</code></li> </ul>"},{"location":"surface/geometry/quantities/#halfedge-cotan-weight","title":"halfedge cotan weight","text":"<p>The \u201ccotangent weight\u201d of an interior halfedge, defined as \\frac{1}{2} \\cot(\\theta)\\frac{1}{2} \\cot(\\theta), where \\theta\\theta is the corner angle opposite the halfedge. Defined to be 00 for exterior halfedges.</p> <p>Can be computed directly from edge lengths, or more efficiently in an embedded triangle via \\cot(\\theta) = \\frac{u \\cdot v}{||u \\times v||}\\cot(\\theta) = \\frac{u \\cdot v}{||u \\times v||}, where uu and vv are the edge vectors emanating from the opposite corner.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>HalfedgeData&lt;double&gt; IntrinsicGeometryInterface::halfedgeCotanWeights</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireHalfedgeCotanWeights()</code></li> </ul> <p>The inline immediate method can alternately be used to compute this value directly from input data for a single element:</p> <ul> <li>immediate: <code>double EdgeLengthGeometry::halfedgeCotanWeight(Halfedge he)</code></li> <li>immediate: <code>double VertexPositionGeometry::halfedgeCotanWeight(Halfedge he)</code></li> </ul>"},{"location":"surface/geometry/quantities/#edge-cotan-weight","title":"edge cotan weight","text":"<p>The \u201ccotangent weight\u201d of an edge, defined as the sum of halfedge cotan weights for incident interior halfedges.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>EdgeData&lt;double&gt; IntrinsicGeometryInterface::edgeCotanWeights</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireEdgeCotanWeights()</code></li> </ul> <p>The inline immediate method can alternately be used to compute this value directly from input data for a single element:</p> <ul> <li>immediate: <code>double EdgeLengthGeometry::edgeCotanWeight(Edge e)</code></li> <li>immediate: <code>double VertexPositionGeometry::edgeCotanWeight(Edge e)</code></li> </ul>"},{"location":"surface/geometry/quantities/#curvatures","title":"Curvatures","text":"<p>Different curvatures are available depending on whether geometry is intrinsic or extrinsic.  In particular, Gaussian curvature is available for any <code>IntrinsicGeometryInterface</code> (such as <code>EdgeLengthGeometry</code>), which is the base class of all other geometry objects, whereas mean and principal curvatures are available only from an <code>ExtrinsicGeometryInterface</code> (such as <code>VertexPositionGeometry</code>).  All curvatures are rigid motion invariant.  Importantly, Gaussian and mean curvatures correspond to the integral of curvature over a local neighborhood, and are hence scale invariant\u2014to get the pointwise curvatures you should divide by area (see details below).  Principal curvatures are pointwise values.  See also <code>vertexPrincipalCurvatureDirections</code>, which provides curvature directions (rather than curvature magnitudes).  See this video for further background on discrete curvature.</p> <p></p> vertex Gaussian curvature vertex mean curvature vertex principal curvature face Gaussian curvature"},{"location":"surface/geometry/quantities/#vertex-gaussian-curvature","title":"vertex Gaussian curvature","text":"<p>The Gaussian curvature KK at a vertex, defined via the angle defect K_v = 2 \\pi - \\sum \\theta_iK_v = 2 \\pi - \\sum \\theta_i, where \\sum \\theta_i\\sum \\theta_i is the <code>vertexAngleSum</code> as above.</p> <p>Should be interpreted as an integrated Gaussian curvature, giving the total curvature in the neighborhood of the vertex. On a closed surface, the Gauss-Bonnet theorem tells us that the sum of these Gaussian curvatures will be a topological constant given by \\sum_v K_v = 2 \\pi \\chi\\sum_v K_v = 2 \\pi \\chi, where \\chi\\chi is the Euler characteristic of the surface. On surfaces with boundary, the geodesic curvature of the boundary factors in.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>VertexData&lt;double&gt; IntrinsicGeometryInterface::vertexGaussianCurvatures</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireVertexGaussianCurvatures()</code></li> </ul> <p>The inline immediate method can be used to compute this value directly from input data for a single element:</p> <ul> <li>immediate: <code>double VertexPositionGeometry::vertexGaussianCurvature(Vertex v)</code></li> <li>immediate: <code>double EdgeLengthGeometry::vertexGaussianCurvature(Vertex v)</code></li> </ul>"},{"location":"surface/geometry/quantities/#vertex-mean-curvature","title":"vertex mean curvature","text":"<p>The mean curvature HH at a vertex ii, defined via the Steiner approximation H_i = \\frac{1}{4}\\sum_{ij} \\theta_{ij} \\ell_{ij}H_i = \\frac{1}{4}\\sum_{ij} \\theta_{ij} \\ell_{ij}, where \\theta_{ij}\\theta_{ij} is the <code>edgeDihedralAngle</code> and \\ell_{ij}\\ell_{ij} is the <code>edgeLength</code> as defined above (and the sum is taken over halfedges extending from ii).</p> <p>Should be interpreted as an integrated mean curvature (units: mm), giving the total curvature in the neighborhood of the vertex.  A corresponding pointwise mean curvature (units: 1/m1/m) can be obtained by dividing by the <code>vertexDualArea</code>.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>VertexData&lt;double&gt; ExtrinsicGeometryInterface::vertexMeanCurvatures</code></li> <li>require: <code>void ExtrinsicGeometryInterface::requireVertexMeanCurvatures()</code></li> </ul> <p>The inline immediate method can be used to compute this value directly from input data for a single element:</p> <ul> <li>immediate: <code>double VertexPositionGeometry::vertexMeanCurvature(Vertex v)</code></li> </ul>"},{"location":"surface/geometry/quantities/#vertex-principal-curvatures","title":"vertex principal curvatures","text":"<p>The principal curvatures \\kappa_1,\\kappa_2\\kappa_1,\\kappa_2 at a vertex ii, defined by the relationships K = \\kappa_1\\kappa_2K = \\kappa_1\\kappa_2 and H = (\\kappa_1+\\kappa_2)/2H = (\\kappa_1+\\kappa_2)/2, where HH and KK are the pointwise mean and Gaussian curvatures (resp.).  These values are signed, and \\kappa_1\\kappa_1 is always the smaller curvature in value, but not necessarily the smaller one in magnitude (e.g., \\kappa_1\\kappa_1 could be a very large negative value, and \\kappa_2\\kappa_2 could be a very small positive value).</p> <p>These quantities can be interpreted as pointwise quantities (units: 1/m1/m), approximating the maximum and minimum bending the neighborhood of the vertex.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>VertexData&lt;double&gt; ExtrinsicGeometryInterface::vertexMinPrincipalCurvatures</code></li> <li> <p>require: <code>void ExtrinsicGeometryInterface::requireVertexMinPrincipalCurvatures()</code></p> </li> <li> <p>member: <code>VertexData&lt;double&gt; ExtrinsicGeometryInterface::vertexMaxPrincipalCurvatures</code></p> </li> <li>require: <code>void ExtrinsicGeometryInterface::requireVertexMaxPrincipalCurvatures()</code></li> </ul> <p>The inline immediate methods can be used to compute this value directly from input data for a single element:</p> <ul> <li>immediate: <code>double VertexPositionGeometry::vertexMinPrincipalCurvature(Vertex v)</code></li> <li>immediate: <code>double VertexPositionGeometry::vertexMaxPrincipalCurvature(Vertex v)</code></li> </ul>"},{"location":"surface/geometry/quantities/#face-gaussian-curvature","title":"face Gaussian curvature","text":"<p>The Gaussian curvature KK at a face, defined via the rescaled angle defect in the face K_f = \\pi - \\sum \\tilde{\\theta}_iK_f = \\pi - \\sum \\tilde{\\theta}_i, where \\tilde{\\theta}_i\\tilde{\\theta}_i are the rescaled corner angles (as in <code>cornerScaledAngles</code>) incident on the face.</p> <p>Should be interpreted as an integrated Gaussian curvature, giving the total curvature inside of the face. A corresponding curvature-per-unit-area can be computed by dividing by the area of the face.</p> <p>On a closed surface, the Gauss-Bonnet theorem tells us that the sum of these Gaussian curvatures will be a topological constant given by \\sum_f K_f = 2 \\pi \\chi\\sum_f K_f = 2 \\pi \\chi, where \\chi\\chi is the Euler characteristic of the surface. On surfaces with boundary, the geodesic curvature of the boundary factors in.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>FaceData&lt;double&gt; IntrinsicGeometryInterface::faceGaussianCurvatures</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireFaceGaussianCurvatures()</code></li> </ul>"},{"location":"surface/geometry/quantities/#tangent-vectors-and-transport","title":"Tangent vectors and transport","text":"<p>These quantities are defined for any <code>IntrinsicGeometryInterface</code>, which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. Tangent vectors and transport are defined in terms of tangent spaces at faces and vertices, as defined below.</p> <p>Recall that our <code>Vector2</code> types obey the multiplication and division rules of complex arithmetic, and thus can be used to represent rotations. For instance, a 2D vector representing a rotation can be used to rotate another vector like: <pre><code>Vector2 v = /* your vector */\nVector2 r = Vector2{std::cos(PI/4), std::sin(PI/4)}; // rotation by 45 degrees\nVector2 vRot = r * v;\n</code></pre> This is fundamentally no different from using 2x2 rotation matrices, but leads to much cleaner code (try using division to compute relative rotations!).</p>"},{"location":"surface/geometry/quantities/#face-tangent-spaces","title":"Face tangent spaces","text":"<p>To represent vectors that sit in flat mesh faces, we define a 2D coordinate frame tangent to each face. By default, this frame is aligned such that <code>face.halfedge()</code> points along the xx-axis (but subclasses might change this convention). All vectors in faces are then expressed via (x,y)(x,y) <code>Vector2D</code> coordinates in this frame. Crucially, this basis is well-defined even if the geometry does not have vertex positions.</p> <p>See face tangent basis to convert these vectors to world coordinates (if your mesh has vertex positions).</p> halfedge vectors in face transport vector across halfedge"},{"location":"surface/geometry/quantities/#halfedge-vectors-in-face","title":"halfedge vectors in face","text":"<p>Vectors for each halfedge in the coordinate frame of the face in which they sit. See the description of face tangent spaces above for a definition.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>HalfedgeData&lt;Vector2&gt; IntrinsicGeometryInterface::halfedgeVectorsInFace</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireHalfedgeVectorsInFace()</code></li> </ul>"},{"location":"surface/geometry/quantities/#transport-vector-across-halfedge","title":"transport vector across halfedge","text":"<p>Rotations which transport tangent vectors across a halfedge, rotating a vector from the tangent space of <code>halfedge.face()</code> to the tangent space <code>halfedge.twin().face()</code>.</p> <p>Always a unit vector, which can be multiplied by any other vector to compute the rotation. (recall our <code>Vector2</code>s multiply like complex numbers)</p> <p>Only valid on triangular meshes. Not defined for halfedges (interior or exterior) incident on boundary edges, these boundary values are set to NaN so errors can be caught quickly.</p> <ul> <li>member: <code>HalfedgeData&lt;Vector2&gt; IntrinsicGeometryInterface::transportVectorsAcrossHalfedge</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireTransportVectorAcrossHalfedge()</code></li> </ul> <p>Example usage: <pre><code>geometry.requireTransportVectorsAcrossHalfedge();\n\nFace f = /* ... */;        // a face of interest\nVector2 myVec = /* ... */; // tangent vector in face f\n\nfor(Halfedge he : f.adjacentHalfedges()) {\n\nFace neighborFace = he.twin().face();\nVector2 rot = geometry.transportVectorAcrossHalfedge[he];\nVector2 neighVec = rot * myVec;    // now in the basis of neighborFace\n}\n</code></pre></p>"},{"location":"surface/geometry/quantities/#vertex-tangent-spaces","title":"Vertex tangent spaces","text":"<p>To represent vectors that sit at mesh faces, we consider a polar coordinate frame at each vertex. This frame is defined by measuring angles according to the rescaled corner angles as in <code>cornerScaledAngles</code>. By default, this frame is aligned such that <code>vertex.halfedge()</code> points along the \\phi=0\\phi=0 xx-axis (but subclasses might change this convention). Of course, rather than using polar coordinates we can equivalently work in the corresponding Cartesian frame\u2014tangent vectors at vertices are then expressed via (x,y)(x,y) <code>Vector2D</code> coordinates in this frame. Crucially, this basis does not require picking a vertex normal, and is well-defined even if the geometry does not have vertex positions.</p> <p>See vertex tangent basis to convert these tangent vectors to world coordinates (if your mesh has vertex positions).</p> <p></p> halfedge vectors in vertex transport vector along halfedge"},{"location":"surface/geometry/quantities/#halfedge-vectors-in-vertex","title":"halfedge vectors in vertex","text":"<p>Vectors for each halfedge in the coordinate frame of the vertex from which the emanate (in <code>halfedge.vertex()</code>). See the description of vertex tangent spaces above for a definition.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>HalfedgeData&lt;Vector2&gt; IntrinsicGeometryInterface::halfedgeVectorsInVertex</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireHalfedgeVectorsInVertex()</code></li> </ul>"},{"location":"surface/geometry/quantities/#transport-vector-along-halfedge","title":"transport vector along halfedge","text":"<p>Rotations which transport tangent vectors along a halfedge, rotating a vector from the tangent space of <code>halfedge.vertex()</code> to the tangent space <code>halfedge.twin().vertex()</code>.</p> <p>Always a unit vector, which can be multiplied by any other vector to compute the rotation. (recall our <code>Vector2</code>s multiply like complex numbers)</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>HalfedgeData&lt;Vector2&gt; IntrinsicGeometryInterface::transportVectorsAlongHalfedge</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireTransportVectorsAlongHalfedge()</code></li> </ul> <p>Example usage: <pre><code>geometry.requireTransportVectorsAlongHalfedge();\n\nVertex v = /* ... */;        // a vertex of interest\nVector2 myVec = /* ... */;   // tangent vector in vertex v\n\nfor(Halfedge he : v.outgoingHalfedges()) {\nVertex neighborVertex = he.twin().vertex();\nVector2 rot = geometry.transportVectorAlongHalfedge[he];\nVector2 neighVec = rot * myVec;    // now in the basis of neighborVertex\n}\n</code></pre></p>"},{"location":"surface/geometry/quantities/#operators","title":"Operators","text":"<p>These quantities are defined for any <code>IntrinsicGeometryInterface</code>, which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. A full explanation of these operators is beyond the scope of these docs; see these course notes for one introduction.</p> <p>All operators are indexed over mesh elements according to the natural iteration order of the elements, or equivalently the indices from <code>SurfaceMesh::getVertexIndices()</code> (etc).</p> cotangent Laplacian vertex lumped mass matrix vertex Galerkin mass matrix vertex connection Laplacian DEC operators <p>While the vertex-based cotan Laplacian above is standard in geometry processing, one can also construct a discrete Laplacian using different basis functions. The following matrices are the result of using Crouzeix-Raviart basis functions, which are Lagrange elements based at edge midpoints: Each function is piecewise linear, has a value at 1 at its associated edge midpoint, and is 0 at all other adjacent edge midpoints.</p> <p>In graphics and geometry processing, Crouzeix-Raviart elements have been used, for example, to discretize bending energies and discretize vector Dirichlet energy. Because there are typically more edges than vertices in a mesh, and there are only two faces in the support of each Crouzeix-Raviart basis function, Crouzeix-Raviart operators also typically have more DOFs than vertex-based operators.</p> Crouzeix-Raviart Laplacian Crouzeix-Raviart mass matrix Crouzeix-Raviart connection Laplacian"},{"location":"surface/geometry/quantities/#cotangent-laplacian","title":"cotangent laplacian","text":"<p>The discrete Laplace operator, discretized via cotangent weights.</p> <p>A |V| \\times |V||V| \\times |V| real matrix. Always symmetric and positive semi-definite. If and only the underlying geometry is Delaunay, the matrix will furthermore have all negative off-diagonal entries, satisfy a maximum principle, and be an M-matrix.</p> <p>This is the weak Laplace operator, if we use it to evalutae \\mathsf{y} \\leftarrow \\mathsf{L} \\mathsf{x}\\mathsf{y} \\leftarrow \\mathsf{L} \\mathsf{x}, \\mathsf{x}\\mathsf{x} should hold pointwise quantities at vertices, and the result \\mathsf{y}\\mathsf{y} will contain integrated values of the result in the neighborhood of each vertex. If used to solve a Poisson problem, a mass matrix (such as the lumped or Galerkin mass matrices below) are likely necessary on the right hand side.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::cotanLaplacian</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireCotanLaplacian()</code></li> </ul>"},{"location":"surface/geometry/quantities/#vertex-lumped-mass-matrix","title":"vertex lumped mass matrix","text":"<p>A mass matrix at vertices, where vertex area is 1/31/3 the incident face areas as in <code>vertexDualAreas</code>.</p> <p>A |V| \\times |V||V| \\times |V| real diagonal matrix. Generally less-accurate than the Galerkin mass matrix below, but can be easily inverted since it is a diagonal matrix.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::vertexLumpedMassMatrix</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireVertexLumpedMassMatrix()</code></li> </ul>"},{"location":"surface/geometry/quantities/#vertex-galerkin-mass-matrix","title":"vertex Galerkin mass matrix","text":"<p>A mass matrix at vertices, supported at all neighbors of a vertex via integration of piecewise-linear elements.</p> <p>A |V| \\times |V||V| \\times |V| real matrix. Generally more accurate than the lumped mass matrix above, should be preferred unless the mass matrix needs to be inverted.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::vertexGalerkinMassMatrix</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireVertexGalerkinMassMatrix()</code></li> </ul>"},{"location":"surface/geometry/quantities/#vertex-connection-laplacian","title":"vertex connection Laplacian","text":"<p>A discrete connection Laplacian operator, which applies to vector fields defined in vertex tangent spaces. Essentially defined as the scalar cotangent Laplacian, augmented with rotations given by the rotations in <code>transportVectorAlongHalfedge</code>; see The Vector Heat Method, Sec 5.3 for more explanation and definition.</p> <p>A |V| \\times |V||V| \\times |V| complex matrix. Always Hermitian, but positive semi-definite if and only the underlying geometry is Delaunay.  This is a weak Laplace operator, the application of which outputs integrated values in vertex neighborhood.</p> <p>Given a complex vector \\mathsf{x}\\mathsf{x} of tangent vectors at vertices, apply the operator by multiplying \\mathsf{L} * \\mathsf{x}\\mathsf{L} * \\mathsf{x}.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>Eigen::SparseMatrix&lt;std::complex&lt;double&gt;&gt; IntrinsicGeometryInterface::vertexConnectionLaplacian</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireVertexConnectionLaplacian()</code></li> </ul>"},{"location":"surface/geometry/quantities/#dec-operators","title":"DEC operators","text":"<p>These operators are the basic building blocks for discrete exterior calculus on surfaces.</p> <p>Note: These quantities slightly deviate from the usual naming scheme for quantities. Rather than <code>requireD0()</code>, <code>requireD1()</code>, etc, there is a single <code>requireDECOperators()</code> function which manages all 8 of the members listed below.</p> <p>The following members are constructed:</p> <ul> <li><code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::hodge0</code> A |V| \\times |V||V| \\times |V| diagonal matrix</li> <li><code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::hodge0Inverse</code> A |V| \\times |V||V| \\times |V| diagonal matrix</li> <li><code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::hodge1</code> An |E| \\times |E||E| \\times |E| diagonal matrix</li> <li><code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::hodge1Inverse</code> An |E| \\times |E||E| \\times |E| diagonal matrix</li> <li><code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::hodge2</code> An |F| \\times |F||F| \\times |F| diagonal matrix</li> <li><code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::hodge2Inverse</code> An |F| \\times |F||F| \\times |F| diagonal matrix</li> <li><code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::d0</code> An |E| \\times |V||E| \\times |V| matrix with \\{-1, 0, 1\\}\\{-1, 0, 1\\} entries</li> <li><code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::d1</code> An |F| \\times |E||F| \\times |E| matrix with \\{-1, 0, 1\\}\\{-1, 0, 1\\} entries</li> </ul> <p>Only valid on triangular meshes.</p> <ul> <li>require: <code>void IntrinsicGeometryInterface::requireDECOperators()</code></li> </ul>"},{"location":"surface/geometry/quantities/#crouzeix-raviart-laplacian","title":"Crouzeix-Raviart Laplacian","text":"<p>The discrete Laplace operator, discretized via the piecewise linear Crouzeix-Raviart basis functions associated with edge midpoints.</p> <p>A |E| \\times |E||E| \\times |E| real matrix. Always symmetric and positive semi-definite. This is the weak Laplace operator, if we use it to evaluate \\mathsf{y} \\leftarrow \\mathsf{L} \\mathsf{x}\\mathsf{y} \\leftarrow \\mathsf{L} \\mathsf{x}, \\mathsf{x}\\mathsf{x} should hold pointwise quantities at edge midpoints, and the result \\mathsf{y}\\mathsf{y} will contain integrated values of the result in the neighborhood of each edge midpoint. If used to solve a Poisson problem, a mass matrix is likely necessary on the right hand side.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::crouzeixRaviartLaplacian</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireCrouzeixRaviartLaplacian()</code></li> </ul>"},{"location":"surface/geometry/quantities/#crouzeix-raviart-mass-matrix","title":"Crouzeix-Raviart mass matrix","text":"<p>A mass matrix at edges, where the edge area is 1/31/3 the incident face areas.</p> <p>A |E| \\times |E||E| \\times |E| real diagonal matrix. Corresponds to the Galerkin mass matrix for Crouzeix-Raviart elements, which is already diagonal without lumping.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::crouzeixRaviartMassMatrix</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireCrouzeixRaviartMassMatrix()</code></li> </ul>"},{"location":"surface/geometry/quantities/#crouzeix-raviart-connection-laplacian","title":"Crouzeix-Raviart connection Laplacian","text":"<p>A discrete connection Laplacian operator, which applies to vector fields defined in edge tangent spaces</p> <p>A |E| \\times |E||E| \\times |E| complex matrix. Always Hermitian and positive semi-definite.</p> <p>Given a complex vector \\mathsf{x}\\mathsf{x} of tangent vectors at edge midpoints, apply the operator by multiplying \\mathsf{L} * \\mathsf{x}\\mathsf{L} * \\mathsf{x}. Like other mesh elements, the xx-axis of the tangent space at edge <code>e</code> points in the direction of <code>e.halfedge()</code>.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>Eigen::SparseMatrix&lt;double&gt; IntrinsicGeometryInterface::crouzeixRaviartConnectionLaplacian</code></li> <li>require: <code>void IntrinsicGeometryInterface::requireCrouzeixRaviartConnectionLaplacian()</code></li> </ul>"},{"location":"surface/geometry/quantities/#extrinsic-angles","title":"Extrinsic angles","text":"<p>These quantities depend on extrinsic angles, but are still rotation-invariant, and independent of a particular embeddeding. They are defined for <code>ExtrinsicGeometryInterface</code> and classes that extend it, including the <code>EmbeddedGeometryInterface</code> one usually constructs from vertex positions. Currently there is no realization that constructs an <code>ExtrinsicGeometryInterface</code> from input data which is not also an <code>EmbeddedGeometryInterface</code>, but such a class could be implemented in the future.</p> edge dihedral angle vertex principal curvature direction"},{"location":"surface/geometry/quantities/#edge-dihedral-angle","title":"edge dihedral angle","text":"<p>The dihedral angle at an edge, in radians. Defined to be the signed angle between the incident triangle normals: 00 if the edge is flat, positive at a convex edge, and negative at a nonconvex edge.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>EdgeData&lt;double&gt; ExtrinsicGeometryInterface::edgeDihedralAngles</code></li> <li>require: <code>void ExtrinsicGeometryInterface::requireEdgeDihedralAngles()</code></li> </ul> <p>The inline immediate method can be used to compute this value directly from input data for a single element:</p> <ul> <li>immediate: <code>double VertexPositionGeometry::edgeDihedralAngle(Edge e)</code></li> </ul>"},{"location":"surface/geometry/quantities/#vertex-principal-curvature-direction","title":"vertex principal curvature direction","text":"<p>A 2-symmetric tangent vector field at vertices. The direction corresponds to the first principal direction, and the magnitude is proportional to the squared difference of the 1st and 2nd principal curvatures (\\kappa_1 - \\kappa_2)^2(\\kappa_1 - \\kappa_2)^2 (so for instance, if a surface is flat and \\kappa_1 \\approx \\kappa_2\\kappa_1 \\approx \\kappa_2, the magnitude of the field will be near 00).</p> <p>A formal description appears in section 6.1.2 of Globally Optimal Direction Fields</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>VertexData&lt;Vector2&gt; ExtrinsicGeometryInterface::vertexPrincipalCurvatureDirections</code></li> <li>require: <code>void ExtrinsicGeometryInterface::requireVertexPrincipalCurvatureDirections()</code></li> </ul>"},{"location":"surface/geometry/quantities/#embedded-positions-and-normals","title":"Embedded positions and normals","text":"<p>These quantities depend explicitly on an embedding in 3D space (better known as vertex positions). They are defined for <code>EmbeddedGeometryInterface</code> (which is usually instantiated as a <code>VertexPositionGeometry</code>). Don\u2019t forget, <code>EmbeddedGeometryInterface</code> extends the <code>IntrinsicGeometryInterface</code> and <code>ExtrinsicGeometryInterface</code>, so all of the quantities above are also accessible.</p> vertex position face normal vertex normal vertex dual mean curvature normal face tangent basis vertex tangent basis"},{"location":"surface/geometry/quantities/#vertex-position","title":"vertex position","text":"<p>Vertex positions in 3D.</p> <ul> <li>member: <code>VertexData&lt;Vector3&gt; EmbeddedGeometryInterface::vertexPositions</code></li> <li>require: <code>void EmbeddedGeometryInterface::requireVertexPositions()</code></li> </ul>"},{"location":"surface/geometry/quantities/#face-normal","title":"face normal","text":"<p>A normal vector for each face.</p> <ul> <li>member: <code>FaceData&lt;Vector3&gt; EmbeddedGeometryInterface::faceNormals</code></li> <li>require: <code>void EmbeddedGeometryInterface::requireFaceNormals()</code></li> </ul> <p>The inline immediate method can alternately be used to compute this value directly from input data for a single element:</p> <ul> <li>immediate: <code>Vector3 VertexPositionGeometry::faceNormal(Face f)</code></li> </ul>"},{"location":"surface/geometry/quantities/#vertex-normal","title":"vertex normal","text":"<p>A normal vector for each vertex. Defined as the corner-angle weighted average of incident face normals.</p> <ul> <li>member: <code>VertexData&lt;Vector3&gt; EmbeddedGeometryInterface::faceNormals</code></li> <li>require: <code>void EmbeddedGeometryInterface::requireFaceNormals()</code></li> </ul>"},{"location":"surface/geometry/quantities/#vertex-dual-mean-curvature-normal","title":"vertex dual mean curvature normal","text":"<p>Conceptually, the mean curvature normal at any location on a surface is a vector which points in the normal direction, and has magnitude equal to the mean curvature at that location. In practice, we discretize this using the fact that applying the Laplacian to the position function yields the mean curvature normals.</p> <p>Should be interpreted as an integrated mean curvature normal (units: mm), giving the integral of the mean curvature curvature in the neighborhood of the vertex.  A corresponding pointwise mean curvature (units: 1/m1/m) can be obtained by dividing by the <code>vertexDualArea</code>.</p> <p>Only valid on triangular meshes.</p> <ul> <li>member: <code>VertexData&lt;double&gt; EmbeddedGeometryInterface::vertexDualMeanCurvatureNormals</code></li> <li>require: <code>void EmbeddedGeometryInterface::requireVertexDualMeanCurvatureNormals()</code></li> </ul> <p>The inline immediate method can be used to compute this value directly from input data for a single element:</p> <ul> <li>immediate: <code>Vector3 VertexPositionGeometry::vertexDualMeanCurvatureNormal(Vertex v)</code></li> </ul> <p>Fun fact: these vertex dual mean curvature normals are also the derivative of the mesh\u2019s surface area with respect to vertex positions.</p>"},{"location":"surface/geometry/quantities/#face-tangent-basis","title":"face tangent basis","text":"<p>A pair of xx-axis and yy-axis 3D basis vectors in world space, corresponding to the intrinsic tangent space for the face. Always orthogonal to the face normal.</p> <p>Example:</p> <pre><code>SurfaceMesh&amp; mesh = /* ... */ VertexPositionGeometry&amp; geometry = /* ... */;    FaceData&lt;Vector2&gt; myTangentVectorField;\n\ngeometry.requireFaceTangentBasis();\n\nfor(Face f : mesh.faces()) {\nVector2 field = myTangentVectorField[f];\n\nVector3 basisX = geometry.faceTangentBasis[f][0];\nVector3 basisY = geometry.faceTangentBasis[f][1];\n\nVector3 fieldInWorldCoords = basisX * field.x + basisY * field.y;\n}\n</code></pre> <ul> <li>member: <code>FaceData&lt;std::array&lt;Vector3,2&gt;&gt; EmbeddedGeometryInterface::faceTangentBasis</code></li> <li>require: <code>void EmbeddedGeometryInterface::requireFaceTangentBasis()</code></li> </ul>"},{"location":"surface/geometry/quantities/#vertex-tangent-basis","title":"vertex tangent basis","text":"<p>A pair of xx-axis and yy-axis 3D basis vectors in world space, corresponding to the intrinsic tangent space for the vertex. Always orthogonal to the vertex normal.</p> <p>Example:</p> <pre><code>SurfaceMesh&amp; mesh = /* ... */ VertexPositionGeometry&amp; geometry = /* ... */;    VertexData&lt;Vector2&gt; myTangentVectorField;\n\ngeometry.requireFaceTangentBasis();\n\nfor(Vertex v : mesh.vertices()) {\nVector2 field = myTangentVectorField[v];\n\nVector3 basisX = geometry.vertexTangentBasis[v][0];\nVector3 basisY = geometry.vertexTangentBasis[v][1];\n\nVector3 fieldInWorldCoords = basisX * field.x + basisY * field.y;\n}\n</code></pre> <ul> <li>member: <code>VertexData&lt;std::array&lt;Vector3,2&gt;&gt; EmbeddedGeometryInterface::vertexTangentBasis</code></li> <li>require: <code>void EmbeddedGeometryInterface::requireVertexTangentBasis()</code></li> </ul>"},{"location":"surface/intrinsic_triangulations/basics/","title":"Basics","text":"<p>Intrinsic triangulations begin with a simple idea: rather than representing a triangle mesh\u2019s geometry via vertex positions, instead store a length associated with each edge. This turns out to be just the right data to compute many geometric quantities, including areas, angles, Laplacians, geodesic distance, etc; from these one can evaluate many algorithms directly on an intrinsic triangulation.</p> <p>The general workflow with intrinsic triangulations is to start out with some initial mesh having 3D vertex positions, and construct a new intrinsic triangulation which \u201csits on top\u201d of the initial mesh, and can then be modified and improved.  The benefit of working with intrinsic triangulations is that they enable a family of simple &amp; powerful mesh operations to robustly compute with a surface while preserving its shape exactly\u2014these operations are not possible when working directly with vertex positions. For a general introduction to intrinsic triangulations and the technique used here, see this course.</p> <p> The above image shows an intrinsic triangulation of a poorly-tessellated surface. The original mesh is given by the black wireframe, while the intrinsic triangulation (after Delaunay refinement) is given by the colored triangles. Computing with the intrinsic triangulation yields significant benefits, while still implicitly encoding the original shape exactly.</p> <p>The tricky part of working with intrinsic triangulations like this is encoding the correspondence to the original mesh. Geometry-central contains two data structures for encoding this correspondence, which allow you to e.g. transfer data between to original mesh and the intrinsic triangulation, or map a point in barycentric coordinates between the triangulations. Additionally, these data structures offer routines for standard operations such as generating a high-quality intrinsic triangulation of a given surface.</p> <p>The main interface for working with intrinsic triangulations is <code>IntrinsicTriangulation</code>. This interface is realized by the <code>SignpostIntrinsicTriangulation</code> and <code>IntegerCoordinatesIntrinsicTriangulation</code> classes (see here for a brief discussion of interfaces, realization, and polymorphism in C++). The routines in this section show how to initialize a triangulation, improve its quality, and run algorithms on it. In particular, this intrinsic triangulation satisfies the IntrinsicGeometryInterface, and thus can be used directly as input to many algorithms in geometry-central.</p> <p>This repository contains a simple demo application with a GUI for manipulating intrinsic triangulations, and demonstrates much of the fuctionality documented here.</p> <p>Headers: <pre><code>#include \"geometrycentral/surface/intrinsic_triangulation.h\"\n#include \"geometrycentral/surface/signpost_intrinsic_triangulation.h\"\n#include \"geometrycentral/surface/integer_coordinates_intrinsic_triangulation.h\"\n</code></pre></p>"},{"location":"surface/intrinsic_triangulations/basics/#example","title":"Example","text":"<pre><code>#include \"geometrycentral/surface/signpost_intrinsic_triangulation.h\"\n#include \"geometrycentral/surface/direction_fields.h\"\n#include \"geometrycentral/surface/meshio.h\"\nusing namespace geometrycentral;\nusing namespace surface;\n\n// Load a mesh\nstd::unique_ptr&lt;ManifoldSurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = loadMesh(filename);\n\n// Construct an intrinsic triangulation\n// (here, using the signpost data structure)\nstd::unique_ptr&lt;IntrinsicTriangulation&gt; intTri(\nnew SignpostIntrinsicTriangulation(*mesh, *geometry));\n\n\n// == Improve the quality\n\n// flip edges to get the intrinsic Delaunay triangulation\nintTri-&gt;flipToDelaunay(); // optional: go even further and insert new vertices guarantee \n// a minimum angle bound (default: 25 deg) in the underlying \n// intrinsic triangulation\nintTri-&gt;delaunayRefine();\n\n\n// == Do some computation on the intrinsic triangulation \n\n// Compute a smooth direction field\nVertexData&lt;Vector2&gt; directionsOnInt = computeSmoothestVertexDirectionField(*intTri);\n\n// Copy the result back to the vertices of the input mesh\nVertexData&lt;Vector2&gt; directionsOnOrig = intTri-&gt;restrictToInput(directionsOnInt);\n</code></pre>"},{"location":"surface/intrinsic_triangulations/basics/#intrinsic-triangulation","title":"Intrinsic Triangulation","text":"<p>This class tracks the geometry and connectivity of an intrinsic triangulation sitting atop a triangle mesh. It \u201cis-a\u201d <code>IntrinsicGeometryInterface</code>, so it can be used directly as a geometry input to many geometry-central subroutines. Furthermore, we can compute all sorts of geometric quantities on it just as we normally would with a geometry object.</p> <p><code>IntrinsicTriangulation</code> is an interface and cannot be constructed directly: to use it, you must construct a <code>SignpostIntrinsicTriangulation</code> or <code>IntegerCoordinatesIntrinsicTriangulation</code>.</p> <p>Example: compute some quantities <pre><code>// Construct an intrinsic triangulation\n// (here, using the signpost data structure)\nstd::unique_ptr&lt;IntrinsicTriangulation&gt; intTri(\nnew SignpostIntrinsicTriangulation(*mesh, *geometry));\n\nintTri-&gt;flipToDelaunay(); // edge lengths\nintTri-&gt;requireEdgeLengths();\nfor(Edge e : intTri-&gt;intrinsicMesh.edges()) {\n// print them, as an example\nstd::cout &lt;&lt; \"Length of edge \" &lt;&lt; e &lt;&lt; \" is \" &lt;&lt; intTri-&gt;edgeLengths[e] &lt;&lt; std::endl;\n}\n\n// vertex dual area (mass)\nintTri-&gt;requireVertexDualAreas();\nfor(Vertex v : intTri-&gt;intrinsicMesh.vertices()) {\nstd::cout &lt;&lt; \"Area of vertex \" &lt;&lt; v &lt;&lt; \" is \" &lt;&lt; intTri-&gt;vertexDualAreas[v] &lt;&lt; std::endl;\n}\n\n// Laplace matrix\n// (this is this intrinsic Delaunay Laplace matrix, since we flipped to Delaunay)\nintTri-&gt;requireCotanLaplacian();\nSparseMatrix&lt;double&gt; L = intTri-&gt;cotanLaplacian; // an Eigen sparse matrix\n</code></pre></p>"},{"location":"surface/intrinsic_triangulations/basics/#basic-api","title":"Basic API","text":"<p>Note that some additional functions and members can be found in the <code>IntrinsicTriangulation</code> class at  <code>geometrycentral/surface/intrinsic_triangulation.h</code>.</p>"},{"location":"surface/intrinsic_triangulations/basics/#members","title":"Members","text":"<code>ManifoldSurfaceMesh&amp; inputMesh</code> <p>The underlying mesh which the intrinsic triangulation sits on top of. It must not be modified during the intrinsic triangulation\u2019s lifetime.</p> <code>IntrinsicGeometryInterface&amp; inputGeom</code> <p>The underlying geometry corresponding to <code>inputMesh</code>. It must not be modified during the intrinsic triangulation\u2019s lifetime.</p> <code>std::unique_ptr&lt;ManifoldSurfaceMesh&gt;&amp; intrinsicMesh</code> <p>A triangle mesh (distinct from <code>inputMesh</code>), which represents the connectivity of the intrinsic triangulation. Right after construction, it will be a copy of <code>inputMesh</code>, but may be modified by subsequent mutations like edge flips.</p> <p>Note that that because the <code>IntrinsicTriangulation</code> is-a <code>IntrinsicGeometryInterface</code>, there is also a  <code>IntrinsicTriangulation::mesh</code> member reference which refers to this same mesh object, inherited from the geometry interface.</p> <code>VertexData&lt;SurfacePoint&gt;&amp; vertexLocations</code> <p>A position on <code>inputMesh</code> for each vertex in the intrinsic triangulation. Initially, these positions will all corresponding vertices on the input mesh, but as e.g. refinements are performed, some intrinsic vertices will have positions inside faces of the original triangulation.</p>"},{"location":"surface/intrinsic_triangulations/basics/#queries-and-accessors","title":"Queries and Accessors","text":"<code>EdgeData&lt;std::vector&lt;SurfacePoint&gt;&gt; IntrinsicTriangulation::traceAllIntrinsicEdgesAlongInput()</code> <p>Traces out the path that each intrinsic edge takes along the surface, as a sequence of SurfacePoints beginning with the vertex at the tail of the halfedge and ending with the vertex at the tip of the halfedge.</p> <code>std::vector&lt;SurfacePoint&gt; IntrinsicTriangulation::traceIntrinsicHalfedgeAlongInput(Halfedge intrinsicHe)</code> <p>Traces out the path that an intrinsic edge takes along the surface, as a sequence of SurfacePoints beginning with the vertex at the tail of the halfedge and ending with the vertex at the tip of the halfedge.</p> <p>Nore: When using an <code>IntegerCoordinatesIntrinsicTriangulation</code>, calling <code>traceEdges()</code> is significantly more efficient than calling <code>traceHalfedge(he)</code> on each edge.</p> <code>EdgeData&lt;std::vector&lt;SurfacePoint&gt;&gt; IntrinsicTriangulation::traceAllInputEdgesAlongIntrinsic()</code> <p>Traces out the path that each input edge takes along the surface, as a sequence of SurfacePoints beginning with the vertex at the tail of the halfedge and ending with the vertex at the tip of the halfedge.</p> <code>std::vector&lt;SurfacePoint&gt; IntrinsicTriangulation::traceInputHalfedgeAlongIntrinsic(Halfedge inputHe)</code> <p>Traces out the path that an input edge takes along the surface, as a sequence of SurfacePoints beginning with the vertex at the tail of the halfedge and ending with the vertex at the tip of the halfedge.</p> <code>CommonSubdivision&amp; IntrinsicTriangulation::getCommonSubdivision()</code> <p>Returns the common subdivison of the input and intrisnic meshes. May construct it from scratch if this is the first time it is needed. The intrinsic triangulation manages the lifetime of the subdivision\u2014it will be deallocated if</p> <p>(a) this object is deleted, or</p> <p>(b) the triangulation is mutated, invalidating the common subdivision.</p> <p>Be sure to copy it if you want to retain it through those operations.</p> <code>SurfacePoint IntrinsicTriangulation::equivalentPointOnIntrinsic(const SurfacePoint&amp; pointOnInput)</code> <p>Given a point on the input triangulation, returns the corresponding point on the current intrinsic triangulation.</p> <p>The input and output are given as a SurfacePoint, which may be a vertex, point along an edge, or point within some face.</p> <code>SurfacePoint IntrinsicTriangulation::equivalentPointOnInput(const SurfacePoint&amp; pointOnIntrinsic)</code> <p>Given a point on the current intrinsic triangulation, returns the corresponding point on the input triangulation.</p> <p>The input and output are given as a SurfacePoint, which may be a vertex, point along an edge, or point within some face.</p> <code>VertexData&lt;T&gt; IntrinsicTriangulation::sampleFromInput(const VertexData&lt;T&gt;&amp; dataOnInput)</code> <p>Given data defined on the vertices of the input triangulation, samples it to the vertices of the intrinsic triangulation.</p> <code>VertexData&lt;T&gt; IntrinsicTriangulation::restrictToInput(const VertexData&lt;T&gt;&amp; dataOnIntrinsic)</code> <p>Given data defined on the vertices of the intrinsic triangulation, restrict it to the vertices of the input triangulation.</p> <code>bool IntrinsicTriangulation::isDelaunay()</code> <p>Returns true if all edges in the intrinsic triangulation satisfy the intrinsic Delaunay property (aka have nonnegative cotangent weights).</p> <code>double IntrinsicTriangulation::minAngleDegrees()</code> <p>Returns the smallest corner angle in the intrinsic triangulation, in degrees.</p>"},{"location":"surface/intrinsic_triangulations/basics/#high-level-mutators","title":"High-Level Mutators","text":"<code>void IntrinsicTriangulation::flipToDelaunay()</code> <p>Flips edges in the intrinsic triangulation until is satisfies the intrinsic Delaunay criterion.</p> <code>void IntrinsicTriangulation::delaunayRefine(double angleThreshDegrees = 25, double circumradiusThresh = inf, size_t maxInsertions = inf)</code> <p>Applies Chew\u2019s 2nd algorithm to the intrinsic triangulation, flipping edges and inserting vertices until the triangulation simultaneously:</p> <ul> <li> <p>satisfies the intrinsic Delaunay criterion</p> </li> <li> <p>has no angles smaller than <code>angleThreshDegrees</code> (values &gt; 30 degrees may not terminate)</p> </li> <li> <p>has no triangles larger than <code>circumradiusThresh</code></p> </li> </ul> <p>Terminates no matter what after <code>maxInsertions</code> insertions (infinite by default)</p> <p>The algorithm converges with angle threshold settings up to 30 degrees (away from ultra-skinny needle vertices and boundary angles which cannot be improved).</p> <code>void IntrinsicTriangulation::delaunayRefine(cosnt std::function&lt;bool(Face)&gt;&amp; shouldRefine, size_t maxInsertions = inf)</code> <p>General version of intrinsic Delaunay refinement, taking a function which will be called to determine if a triangle should be refined. Will return only when all triangles pass this function, or <code>maxInsertions</code> is exceeded, so be sure to chose arguments such that the function terminates.</p> <code>void IntrinsicTriangulation::setMarkedEdges(const EdgeData&lt;bool&gt;&amp; markedEdges)</code> <p>Set a subset of the edges which are special marked edges. If true, the edge is fixed, and will not be flipped (e.g. in <code>flipToDelaunay()</code>. </p> <p>The class automatically internally hanldes updates to this array as edge splits are performed, so if a marked edge is split the two resulting edges will be marked.</p>"},{"location":"surface/intrinsic_triangulations/basics/#low-level-mutators","title":"Low-Level Mutators","text":"<p>Refreshing quantities</p> <p>The intrinsic triangulation is-a geometry object, which means that one may <code>require()</code> quantities from it. However, for efficiency reasons, these quantities are not automatically updated after each low-level mutataion. Call <code>refreshQuantities()</code> after a sequence of mutations to update.</p> <code>bool IntrinsicTriangulation::flipEdgeIfNotDelaunay(Edge e)</code> <p>If the edge is not (intrinsic) Delaunay, flip it. Returns true if flipped.</p> <code>bool IntrinsicTriangulation::flipEdgeIfPossible(Edge e)</code> <p>If the edge can be flipped, flip it. Returns true if flipped.</p> <p>Edges cannot be flipped if: - the are boundary edges - either endpoint is a degree 1 vertex - when laid out in the plane, the diamond containing the edge is a nonconvex quadrilateral</p> <code>Vertex IntrinsicTriangulation::insertVertex(SurfacePoint newPositionOnIntrinsic)</code> <p>Inserts a new vertex in the intrinsic triangulation. The adjacent faces will be triangulated to maintain a triangle mesh. In degenerate situations, this procedure may fail and return <code>Vertex()</code>.</p> <code>Vertex IntrinsicTriangulation::insertCircumcenter(Face f)</code> <p>Insert an new vertex in to the intrinsic triangulation, at the intrinsic circumcenter of some face. Note that for an obtuse face, the circumcenter is outside of the triangle; the resulting location will be found by tracing. Adjacent faces will be triangulated to maintain a triangle mesh. In degenerate situations, this procedure may fail and return <code>Vertex()</code>.</p> <code>Vertex IntrinsicTriangulation::insertBarycenter(Face f)</code> <p>Insert a new vertex in the intrinsic triangulation, at the intrinsic barycenter of face <code>f</code>.</p> <code>Face IntrinsicTriangulation::removeInsertedVertex(Vertex v)</code> <p>Removes an inserted vertex from the triangulation. Returns <code>Face()</code> if the vertex cannot be removed.</p> <code>Halfedge IntrinsicTriangulation::splitEdge(Halfedge he, double tSplit)</code> <p>Splits an oriented edge. Returns the halfedge which starts at the inserted vertex and points in the same direction as the input halfedge.</p> <p>Additionally, callbacks can be registered by inserting them in to the following lists. These callbacks will be invoked whenever the corresponding mesh operation is performed within the intrinsic triangulation. This can be useful e.g. for maintaining values as the mesh is modified.</p> <code>std::list&lt;std::function&lt;void(Edge)&gt;&gt; edgeFlipCallbackList</code> <p>Member variable, a list of callbacks which are invoked whenever an edge is flipped.</p> <p>Example: construct a lambda callback and register it <pre><code>SignpostIntrinsicTriangulation intTri = /* constructed somehow */;\n\nauto updateOnFlip = [&amp;](Edge flipE) {\n// do something\n};\nauto callbackRef = intTri-&gt;edgeFlipCallbackList.insert(std::end(intTri-&gt;edgeFlipCallbackList), updateOnFlip);\n</code></pre></p> <code>std::list&lt;std::function&lt;void(Face, Vertex)&gt;&gt; faceInsertionCallbackList</code> <p>Member variable, a list of callbacks which are invoked whenever vertex is inserted in to a face. The first argument is the old face, and the second is the new vertex.  </p> <p>Example: construct a lambda callback and register it <pre><code>SignpostIntrinsicTriangulation intTri = /* constructed somehow */;\n\nauto updateOnInsert = [&amp;](Face oldF, Vertex newV) {\n// do something\n};\nauto callbackRef = intTri-&gt;faceInsertionCallbackList.insert(std::end(intTri-&gt;faceInsertionCallbackList), updateOnInsert);\n</code></pre></p> <code>std::list&lt;std::function&lt;void(Edge, Halfedge, Halfedge)&gt;&gt; edgeSplitCallbackList</code> <p>Member variable, a list of callbacks which are invoked whenever an edge is split. The first edge is the old edge which was just split, and the two halfedges are along the new edges which were created by the split.</p> <p>Example: construct a lambda callback and register it <pre><code>SignpostIntrinsicTriangulation intTri = /* constructed somehow */;\n\nauto updateOnSplit = [&amp;](Edge oldE, Halfedge newHe1, Halfedge newHe2) {\n// do something\n};\nauto callbackRef = intTri-&gt;edgeSplitCallbackList.insert(std::end(intTri-&gt;edgeSplitCallbackList), updateOnSplit);\n</code></pre></p>"},{"location":"surface/intrinsic_triangulations/basics/#citations","title":"Citations","text":"<p>The above data structures are described in the following works:</p> <pre><code>@article{Sharp:2021:GPI,\nauthor = {Sharp, Nicholas and Gillespie, Mark and Crane, Keenan},\ntitle = {Geometry Processing with Intrinsic Triangulations},\nbooktitle = {ACM SIGGRAPH 2021 courses},\nseries = {SIGGRAPH '21},\nyear = {2021},\npublisher = {ACM},\naddress = {New York, NY, USA},\n}\n</code></pre> <pre><code>@article{sharp2019navigating,\ntitle={Navigating intrinsic triangulations},\nauthor={Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan},\njournal={ACM Transactions on Graphics (TOG)},\nvolume={38},\nnumber={4},\npages={55},\nyear={2019},\npublisher={ACM}\n}\n</code></pre> <pre><code>@article{gillespie2021integer,\ntitle={Integer Coordinates for Intrinsic Geometry Processing},\nauthor={Gillespie, Mark and Sharp, Nicholas and Crane, Keenan},\njournal={arXiv preprint arXiv:2106.00220},\nyear={2021}\n}\n</code></pre>"},{"location":"surface/intrinsic_triangulations/common_subdivision/","title":"Common Subdivision","text":"<p><code>#include \"geometrycentral/surface/common_subdivision.h\"</code></p> <p>Intuitively, the common subdivision of meshes T_A and T_BT_B is the polygon mesh that you obtain if you cut T_BT_B along the edges of T_AT_A. The vertices of the common subdivision correspond to intersections of simplices of T_AT_A with simplices of T_BT_B (e.g. intersections between edges).  </p> <p>The <code>CommonSubdivision</code> class represents the common subdivision of two meshes, referred to as <code>meshA</code> and <code>meshB</code>. </p> <p>Note</p> <p>In the common case of intrinsic triangulations, the input triangulation is <code>meshA</code>, and the intrinsic triangulation drawn along its surface is <code>meshB</code>.</p> <p>Warning</p> <p>Every vertex of <code>meshA</code> must also be a vertex of <code>meshB</code>.</p> <p>The common subdivision is encoded by a list of CommonSubdivisionPoints, representing its vertices. In addition, it provides ordered lists indicating which points appear along each edge of <code>meshA</code> and <code>meshB</code>. Optionally, an explicit mesh of the common subdivision can be constructed via the <code>constructMesh()</code> function.</p> <p>Example: construct an intrinsic triangulation, an build its common subdivision as a mesh.</p> <pre><code>#include \"geometrycentral/surface/common_subdivision.h\"\n#include \"geometrycentral/surface/intrinsic_triangulation.h\"\n#include \"geometrycentral/surface/integer_coordinates_intrinsic_triangulation.h\"\n#include \"geometrycentral/surface/vertex_position_geometry.h\"\n\nManifoldSurfaceMesh&amp; mesh;\nVertexPositionGeometry&amp; geometry; // your mesh and geometry\n\n// Build an interesting intrinsic triangulation\nIntegerCoordinatesIntrinsicTriangulation intTri(mesh, geometry);\nintTri.delaunayRefine();\n\n// Get the common subdivision\nCommonSubdivision&amp; cs = intTri.getCommonSubdivision();\n\n// Build a mesh of the common subdivision, and interpolate vertex positions for it\ncs.constructMesh();\nManifoldSurfaceMesh&amp; csMesh = *cs.mesh;\nVertexData&lt;Vector3&gt; csPositions = cs.interpolateAcrossA(geometry-&gt;vertexPositions);\n</code></pre>"},{"location":"surface/intrinsic_triangulations/common_subdivision/#members","title":"Members","text":"<code>ManifoldSurfaceMesh&amp; CommonSubdivision::meshA</code><code>ManifoldSurfaceMesh&amp; CommonSubdivision::meshB</code> <p>The two meshes whose common subdivision this object encodes.</p> <code>std::deque&lt;CommonSubdivisionPoint&gt; CommonSubdivision::subdivisionPoints</code> <p>A list of the vertices (subdivision points) of the common subdivision. See documentation of <code>CommonSubdivisionPoint</code> below.</p> <code>EdgeData&lt;std::vector&lt;CommonSubdivisionPoint*&gt;&gt; CommonSubdivision::pointsAlongA</code><code>EdgeData&lt;std::vector&lt;CommonSubdivisionPoint*&gt;&gt; CommonSubdivision::pointsAlongB</code> <p>Stores the list of the vertices of the common subdivision along each edge of <code>meshA</code> (resp. <code>meshB</code>), represented as pointers to elements of <code>subdivisionPoints</code>. These lists are ordered according to the edge\u2019s orientation and include the start and end points of the edges.</p> <p>If edge <code>eA</code> of <code>meshA</code> and <code>eB</code> of <code>meshB</code> run parallel to each other, then <code>pointsAlongA[eA]</code> will store an \u201cintersection\u201d of type <code>CSIntersectionType::EDGE_PARALLEL</code> to record the fact that it runs parallel to edge <code>eB</code>, and vice versa.</p>"},{"location":"surface/intrinsic_triangulations/common_subdivision/#queries-and-accessors","title":"Queries and Accessors","text":"<code>size_t CommonSubdivision::nVertices() const</code> <p>Counts the number of vertices of the common subdivision. Works even if an explicit mesh of the common subdivision has not been constructed yet.</p> <code>std::tuple&lt;size_t, size_t, size_t&gt; CommonSubdivision::elementCounts() const</code> <p>Counts the number of vertices, edges, and faces of the common subdivision. Works even if an explicit mesh of the common subdivision has not been constructed yet.</p> <code>size_t CommonSubdivision::intersectionsA(Edge eA) const</code><code>size_t CommonSubdivison::intersectionsB(Edge eB) const</code> <p>Counts the number of common subdivision vertices (not including endpoints) along edge <code>eA</code> of <code>meshA</code> (resp. <code>eB</code> of <code>meshB</code>). These intersection counts can be thought of as normal coordinates.</p> <code>std::unique_ptr&lt;SimplePolygonMesh&gt; CommonSubdivision::buildSimpleMesh()</code> <p>Construct and return a <code>SimplePolygonMesh</code> of the common subdivision.</p> <p>In cases where there are some errors in intersection data defining the common subvidision, it may not be possible to construct the <code>ManifoldSurfaceMesh</code> with <code>constructMesh()</code>, and this is the only option.</p>"},{"location":"surface/intrinsic_triangulations/common_subdivision/#common-subdivision-points","title":"Common Subdivision Points","text":"<p>A <code>CommonSubdivisionPoint</code> is a struct representing a vertex of the common subdivision. Each vertex of the common subdivision is the intersection of a mesh element from <code>meshA</code> with a mesh element of <code>meshB</code>.</p> <code>CSIntersectionType CommonSubdivisionPoint::intersectionType</code> <p>The type of elements intersecting (e.g. edge-edge intersection, or face-vertex intersection).</p> <code>SurfacePoint CommonSubdivisionPoint::posA</code><code>SurfacePoint CommonSubdivisionPoint::posB</code> <p>The location of this intersection on <code>meshA</code> (resp. <code>meshB</code>), represented as a SurfacePoint.</p> <code>bool CommonSubdivisionPoint::orientation</code> <p>For edge-edge intersections, this stores the orientation of the intersection. It is set to <code>true</code> for positive intersections, meaning that when traveling along the edge of <code>meshA</code>, the intersecting edge of <code>meshB</code> points to the left.</p>"},{"location":"surface/intrinsic_triangulations/common_subdivision/#intersection-types","title":"Intersection Types","text":"<pre><code>enum class CSIntersectionType {\nVERTEX_VERTEX,\nEDGE_TRANSVERSE,\nEDGE_PARALLEL,\nFACE_VERTEX, // Face of mesh A, Vertex of mesh B\nEDGE_VERTEX  // Edge of mesh A, Vertex of mesh B\n};\n</code></pre> \u2018Parallel\u2019 intersections <p>In addition to storing points representing transverse intersections of mesh elements, we also store points which represent edges of <code>meshA</code>  and <code>meshB</code> that run parallel to each other. These points are not really vertices of the common subdivision, but provide a convenient way of encoding the fact that edges run parallel to each other. These points are tagged with type <code>CSIntersectionType::EDGE_PARALLEL</code>.</p>"},{"location":"surface/intrinsic_triangulations/common_subdivision/#mesh-connectivity","title":"Mesh connectivity","text":"<p>Optionally, the raw intersections stored in the common subdivision can be used to explicitly construct a <code>SurfaceMesh</code> (with all the usual halfedge connectivity) of the common subdivision; this mesh can then be used for many higher-level geometric operations.</p> <p>The routines and members in this section all require that constructMesh() has been called first.</p> <p>Note that in cases where there are some errors in intersection data defining the common subdivision, it may not be possible to construct a manifold mesh of the common subdivision. <code>constructMesh()</code> will fail with an exception in this case. Note that <code>buildSimpleMesh()</code> above can be used to build a plain old vertex-face adjacency list representation of the mesh, although it cannot be used for the various routines in this section.</p> <p>By default, the common subdivision mesh is connectivity-only; there is no geometry associated with. Geometry can be recovered by either interpolating vertex positions from a mesh sitting in space (like <code>interpolateAcrossA(geometry-&gt;vertexPositions)</code>), or intrinsically via (like <code>interpolationEdgeLengthsA()</code>).</p>"},{"location":"surface/intrinsic_triangulations/common_subdivision/#mesh-members","title":"Mesh Members","text":"<code>std::unique_ptr&lt;ManifoldSurfaceMesh&gt; CommonSubdivision::mesh</code> <p>An explicit mesh of the common subdivision.</p> <code>VertexData&lt;CommonSubdivisionPoint*&gt; CommonSubdivision::sourcePoints</code> <p>Defined per-vertex of the mesh <code>CommonSubdivision::mesh</code>, associates each vertex of <code>mesh</code> with the corresponding element of <code>subdivisionPoints</code>.</p> <code>FaceData&lt;Face&gt; CommonSubdivision::sourceFaceA</code> <code>FaceData&lt;Face&gt; CommonSubdivision::sourceFaceB</code> <p>Defined per-face of the mesh <code>CommonSubdivision::mesh</code>, associates each face of <code>mesh</code> with the corresponding face of <code>meshA</code> (resp. <code>meshB</code>) which contains it.</p>"},{"location":"surface/intrinsic_triangulations/common_subdivision/#mesh-constructors","title":"Mesh Constructors","text":"<code>void CommonSubdivision::constructMesh(bool triangulate = true, bool skipIfAlreadyConstructed = true)</code> <p>Compute an explicit mesh of the common subdivision, storing it in the <code>mesh</code> member.</p> <p>Initially, the faces of the common subdivision are polygons. If <code>triangulate</code> is <code>true</code>, then these faces are immediately triangulated internally.</p> <p>If <code>skipIfAlreadyConstructed</code> is <code>true</code>, this function does nothing when called multiple times. Otherwise, it deletes and reconstructs on subsequent calls.</p> <code>void CommonSubdivision::triangulateMesh() const</code> <p>Triangulate the <code>mesh</code> member. Internally, the <code>sourceFaceA</code> and <code>sourceFaceB</code> are also updated to reflect the triangulation.</p> <p>This is already called be default in <code>constructMesh()</code> if <code>triangulate=true</code>.</p>"},{"location":"surface/intrinsic_triangulations/common_subdivision/#mesh-utilities","title":"Mesh Utilities","text":"<p>Interpolate values defined at vertices from either <code>meshA</code> or <code>meshB</code> to the vertices of the common subdivision mesh.</p> <code>VertexData&lt;T&gt; CommonSubdivision::interpolateAcrossA(const VertexData&lt;T&gt;&amp; dataA)</code><code>VertexData&lt;T&gt; CommonSubdivision::interpolateAcrossB(const VertexData&lt;T&gt;&amp; dataB)</code> <p>Linearly interpolates data on <code>meshA</code> (resp. <code>meshB</code>) to the common subdivision.</p> <code>FaceData&lt;T&gt; CommonSubdivision::copyFromA(const FaceData&lt;T&gt;&amp; dataA)</code><code>FaceData&lt;T&gt; CommonSubdivision::copyFromB(const FaceData&lt;T&gt;&amp; dataB)</code> <p>Copy data at faces from one of the meshes to the common subdivision. Each face of the common subdivision gets the value from the face which contains it. The return value is defined per-face of the common subdivision mesh.</p> <code>SparseMatrix&lt;double&gt; CommonSubdivison::interpolationMatrixA()</code><code>SparseMatrix&lt;double&gt; CommonSubdivision::interpolationMatrixB()</code> <p>Yields a <code>|V| x |V_A|</code> matrix (resp. <code>|V| x |V_B|</code>) which linearly interpolates data on <code>meshA</code> (resp. <code>meshB</code>) to the common subdivision. Here <code>|V|</code> denotes the number of vertices in the common subdivision.</p> <code>EdgeData&lt;double&gt; CommonSubdivision::interpolateEdgeLengthsA(const EdgeData&lt;double&gt;&amp; lengthA)</code><code>EdgeData&lt;double&gt; CommonSubdivision::interpolateEdgeLengthsB(const EdgeData&lt;double&gt;&amp; lengthB)</code> <p>Takes in edge lengths for <code>meshA</code> (resp. <code>meshB</code>) and computes the edge lengths of the common subdivision.</p> <p>Note that in the standard case of an intrinsic triangulation with Euclidean metric-preserving edge flips, calling either of these methods with the edge lengths from the respective triangulation will produce identical outputs (up to floating-point error).</p> <code>SparseMatrix&lt;double&gt; CommonSubdivision::vertexGalerkinMassMatrixFromPositionsA(const VertexData&lt;Vector3&gt;&amp; positionsA)</code><code>SparseMatrix&lt;double&gt; CommonSubdivision::vertexGalerkinMassMatrixFromPositionsB(const VertexData&lt;Vector3&gt;&amp; positionsB)</code> <p>Takes in vertex positions for <code>meshA</code> (resp. <code>meshB</code>) and computes the Galerkin mass matrix of the common subdivision.</p> <code>SparseMatrix&lt;double&gt; CommonSubdivision::vertexGalerkinMassMatrixFromLengthsA(const EdgeData&lt;Vector3&gt;&amp; lengthsA)</code><code>SparseMatrix&lt;double&gt; CommonSubdivision::vertexGalerkinMassMatrixFromLengthsB(const EdgeData&lt;Vector3&gt;&amp; lengthsB)</code> <p>Takes in edge lengths for <code>meshA</code> (resp. <code>meshB</code>) and computes the Galerkin mass matrix of the common subdivision.</p>"},{"location":"surface/intrinsic_triangulations/common_subdivision/#additional-utilities","title":"Additional Utilities","text":"<code>FaceData&lt;double&gt; niceColors(ManifoldSurfaceMesh&amp; mesh, int kColors=7)</code> <p>Take <code>kColors</code> evenly spaced values on [0,1] and treat them as categorical labels. These labels are assigned to mesh faces in the sense of a graph coloring, with further heuristics to try to avoid neighbors-of-neighbors at vertices.</p> <p>This function is useful for generating a nice coloring of an intrinsic triangulation, defined along the common subdivision, for visualization.</p>"},{"location":"surface/intrinsic_triangulations/function_transfer/","title":"Function Transfer","text":"<p>Intrinsic triangulations provide high quality function spaces, even on near-degenerate geometry, which dramatically improves the accuracy of PDE-based algorithms (e.g. the heat-based methods in geometry-central). However, these accurate solutions live on the intrinsic triangulation, and cannot be represented exactly as piecewise-linear functions on the original mesh. </p> <p>Given an input mesh of some surface, and an intrinsic triangulations of that surface (which may have additional vertices inserted), these functions allow you to transfer values between the two domains via several different strategies. </p>"},{"location":"surface/intrinsic_triangulations/function_transfer/#pointwise-transfer-at-vertices","title":"Pointwise Transfer at Vertices","text":"<p>The simplest method to transfer functions between two triangulations of the same surface is to simply copy values at vertices.  The following methods, from the <code>IntrinsicTriangulation</code> class, implement this simple transfer scheme in both the forward and reverse direction.</p> <code>VertexData&lt;T&gt; IntrinsicTriangulation::sampleFromInput(const VertexData&lt;T&gt;&amp; dataOnInput)</code> <p>Given data defined on the vertices of the input triangulation, samples it to the vertices of the intrinsic triangulation.</p> <p>If the intrinsic triangulation contains new, inserted vertices which are not in common with the input triangulation, they sample a linearly-interpolated value from the input function.</p> <code>VertexData&lt;T&gt; IntrinsicTriangulation::restrictToInput(const VertexData&lt;T&gt;&amp; dataOnIntrinsic)</code> <p>Given data defined on the vertices of the intrinsic triangulation, restrict it to the vertices of the input triangulation (that is, simply copy values from the shared vertices).</p> <p>If the intrinsic triangulation contains new, inserted vertices which are not in common with the input triangulation, their values are ignored for the purposes of restriction.</p>"},{"location":"surface/intrinsic_triangulations/function_transfer/#transfer-to-the-common-subdivision","title":"Transfer to the Common Subdivision","text":"<p>Another possibility is to transfer data to the common subdivison, a special triangulation which is a superset of both the input and the intrinsic triangulation. This transfer is easy to define, because the common subdivision is precisely the triangulation whose linear bases can exactly represent functions from either the input or intrinsic triangulation.</p> <p>Of course, unlike the other methods described on this page, this strategy does not transfer functions directly between an input triangulation and an intrinsic triangulation, but rather transfers values from either the input or intrinsic triangulation to the common subdivision. </p> <p>One common use for transferring values to the common subdivision is visualization, because the common subdivision is naturally embedded in space as an ordinary mesh.</p> <code>VertexData&lt;T&gt; CommonSubdivision::interpolateAcrossA(const VertexData&lt;T&gt;&amp; dataA)</code><code>VertexData&lt;T&gt; CommonSubdivision::interpolateAcrossB(const VertexData&lt;T&gt;&amp; dataB)</code> <p>Linearly interpolates data on <code>meshA</code> (resp. <code>meshB</code>) to the common subdivision.</p> <code>FaceData&lt;T&gt; CommonSubdivision::copyFromA(const FaceData&lt;T&gt;&amp; dataA)</code><code>FaceData&lt;T&gt; CommonSubdivision::copyFromB(const FaceData&lt;T&gt;&amp; dataB)</code> <p>Copy data at faces from one of the meshes to the common subdivision. Each face of the common subdivision gets the value from the face which contains it. The return value is defined per-face of the common subdivision mesh.</p> <code>SparseMatrix&lt;double&gt; CommonSubdivison::interpolationMatrixA()</code><code>SparseMatrix&lt;double&gt; CommonSubdivision::interpolationMatrixB()</code> <p>Yields a <code>|V| x |V_A|</code> matrix (resp. <code>|V| x |V_B|</code>) which linearly interpolates data on <code>meshA</code> (resp. <code>meshB</code>) to the common subdivision. Here <code>|V|</code> denotes the number of vertices in the common subdivision.</p>"},{"location":"surface/intrinsic_triangulations/function_transfer/#l2-optimal-transfer","title":"L2-Optimal Transfer","text":"<p><code>#include \"geometrycentral/surface/transfer_functions.h\"</code></p> <p>When transferring data directly between the input triangulation and intrinsic triangulation, simple sampling values is naive, and has no reason to be the \u201cbest\u201d approach.  Instead, one can directly compute the function on the other surface, in the sense of L_2-distance between functions\u2014see Integer Coordinates for Intrinsic Geometry Processing for details.</p> <p>Computationally, this amounts to solving a sparse linear least-squares problem defined via the common subdivision. Though somewhat more expensive, this approach can greatly improve accuracy.</p>"},{"location":"surface/intrinsic_triangulations/function_transfer/#single-transfer-functions","title":"Single Transfer Functions","text":"<p>A one-off utility function is provided which transfers functions between different triangulations of the same surface. Repeated solves should use the stateful version below.</p> <p>Example <pre><code>#include \"geometrycentral/surface/meshio.h\"\n#include \"geometrycentral/surface/signpost_intrinsic_triangulation.h\"\n#include \"geometrycentral/surface/transfer_functions.h\"\n\n// Load a mesh\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = loadMesh(filename);\n\n// Create an intrinsic triangulation\nSignpostIntrinsicTriangulation intTri(*mesh, *geometry);\n\n// Change the intrinsic triangulation\nintTri.delaunayRefine();\n\n// Compute something useful on the intrinsic triangulation\nVertexData&lt;double&gt; f_intrinsic = /* some function */\n\n// Transfer function back to extrinsic mesh\nVertexData&lt;double&gt; f_extrinsic = transferBtoA(intTri, f_intrinsic, TransferMethod::L2);\n</code></pre></p> <code>VertexData&lt;double&gt; transferAtoB(IntrinsicTriangulation&amp; intTri, const VertexData&lt;double&gt;&amp; valuesOnA, TransferMethod method)</code> <p>Transfers a scalar function from <code>intTri.inputMesh</code> to <code>intTri.intrinsicMesh</code></p> <ul> <li> <p><code>valuesOnA</code> : the data on <code>intTri.inputMesh</code> to be transferred.</p> </li> <li> <p><code>method</code> : either <code>TransferMethod::Pointwise</code> for pointwise transfer of <code>TransferMethod::L2</code> for L^2L^2-optimal transfer.</p> </li> </ul> <code>VertexData&lt;double&gt; transferBtoA(IntrinsicTriangulation&amp; intTri, const VertexData&lt;double&gt;&amp; valuesOnB, TransferMethod method)</code> <p>Transfers a scalar function from <code>intTri.intrinsicMesh</code> to <code>intTri.inputMesh</code></p> <ul> <li> <p><code>valuesOnB</code> : the data on <code>intTri.intrinsicMesh</code> to be transferred.</p> </li> <li> <p><code>method</code> : either <code>TransferMethod::Pointwise</code> for pointwise transfer of <code>TransferMethod::L2</code> for L^2L^2-optimal transfer.</p> </li> </ul>"},{"location":"surface/intrinsic_triangulations/function_transfer/#transfer-method","title":"Transfer Method","text":"<p>The <code>method</code> argument is an enum:</p> <pre><code>enum class TransferMethod { Pointwise = 0, L2 };\n</code></pre> <p>for completeness, the<code>TransferMethod::Pointwise</code> option implements the pointwise transfer described above, while <code>TransferMethod::L2</code> is the optimal scheme described here.</p>"},{"location":"surface/intrinsic_triangulations/function_transfer/#repeated-transfer-functions","title":"Repeated Transfer Functions","text":"<p>If many functions are to be transferred, pre-factoring the linear least-squares problem can greatly improve performance.  The stateful class <code>AttributeTransfer</code> facilitates this precomputation.</p> <pre><code>#include \"geometrycentral/surface/meshio.h\"\n#include \"geometrycentral/surface/signpost_intrinsic_triangulation.h\"\n#include \"geometrycentral/surface/transfer_functions.h\"\n\n// Load a mesh\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = loadMesh(filename);\n\n// Create an intrinsic triangulation\nSignpostIntrinsicTriangulation intTri(*mesh, *geometry);\n\n// Change the intrinsic triangulation\nintTri.delaunayRefine();\n\n// Create the AttributeTransfer object\nAttributeTransfer transfer(intTri);\n\n// Compute several functions on the intrinsic triangulation\nstd::vector&lt;VertexData&lt;double&gt;&gt; intrinsicFunctions = /* some functions */\n\n// Transfer functions back to extrinsic mesh\nfor (VertexData&lt;double&gt; f_intrinsic : intrinsicFunctions) {\nVertexData&lt;double&gt; f_extrinsic = transfer.transferBtoA(f_intrinsic, TransferMethod::L2);\n/* do something with f_extrinsic */\n}\n</code></pre>"},{"location":"surface/intrinsic_triangulations/function_transfer/#constructors","title":"Constructors","text":"<code>AttributeTransfer::AttributeTransfer(CommonSubdivision&amp; cs, VertexPositionGoemetry&amp; geomA)</code> <p>Create a new solver for attribute transfer. Precomputation is performed lazily as needed.</p> <ul> <li> <p><code>cs</code> is the common subdivision of the two triangulations between which the solver will transfer data.</p> </li> <li> <p><code>geomA</code> is the geometry of <code>meshA</code>.</p> </li> </ul> <code>AttributeTransfer::AttributeTransfer(CommonSubdivision&amp; cs, IntrinsicTriangulation&amp; intTri)</code> <p>Create a new solver for attribute transfer. Precomputation is performed lazily as needed.</p> <ul> <li> <p><code>cs</code> is the common subdivision of the two triangulations between which the solver will transfer data.</p> </li> <li> <p><code>intTri</code> is the <code>IntrinsicTriangulation</code> object representing the two triangulations.</p> </li> </ul>"},{"location":"surface/intrinsic_triangulations/function_transfer/#methods","title":"Methods","text":"<code>VertexData&lt;double&gt; AttributeTransfer::transferAtoB(const VertexData&lt;double&gt;&amp; valuesOnA, TransferMethod method)</code> <p>Transfers a scalar function from <code>meshA</code> to <code>meshB</code></p> <ul> <li> <p><code>valuesOnA</code> : the data on <code>meshA</code> to be transferred.</p> </li> <li> <p><code>method</code> : either <code>TransferMethod::Pointwise</code> for pointwise transfer of <code>TransferMethod::L2</code> for L^2L^2-optimal transfer.</p> </li> </ul> <code>VertexData&lt;double&gt; AttributeTransfer::transferBtoA(const VertexData&lt;double&gt;&amp; valuesOnB, TransferMethod method)</code> <p>Transfers a scalar function from <code>meshB</code> to <code>meshA</code></p> <ul> <li> <p><code>valuesOnB</code> : the data on <code>meshB</code> to be transferred.</p> </li> <li> <p><code>method</code> : either <code>TransferMethod::Pointwise</code> for pointwise transfer of <code>TransferMethod::L2</code> for L^2L^2-optimal transfer.</p> </li> </ul>"},{"location":"surface/intrinsic_triangulations/integer_coordinates/","title":"Integer Coordinates Intrinsic Triangulation","text":"<p>The integer coordinates data structure encodes an intrinsic triangulation using normal coordinates and roundabouts, which are integer values stored on edges. Since it avoids floating point data, this data structure is more robust than signposts, but operations such as vertex insertion can take longer. For more details, see Integer Coordinates for Intrinsic Geometry Processing.</p> <p>The <code>IntegerCoordinatesIntrinsicTriangulation</code> is one concrete implementation (subclass) of intrinsic triangulations. Most of its functionality is documented there.</p>"},{"location":"surface/intrinsic_triangulations/integer_coordinates/#tradeoffs","title":"Tradeoffs","text":"<p>The signpost intrinsic triangulation is one of the two main intrinsic triangulation representations currently available in geometry-central, the other being signposts. For many tasks, either reprentation will be highly effective, but there are some tradeoffs.</p> <p>Pros:</p> <ul> <li>Robustness. Integer coordinates are guaranteed to always maintain a topologically valid representation of the common subdivision, through any sequence of operations.</li> </ul> <p>Cons:</p> <ul> <li>Performance. Integer coordinates may be moderately more expensive in terms of runtime than signposts (although both are often on the order of milliseconds). Some operations, such as tracing out a single edge of the intrinsic triangulation, are only implemented by first extracting the entire common subdivision, which has some overhead.</li> </ul> <p>Not yet implemented</p> <p>The methods <code>equivalentPointOnIntrinsic()</code> and <code>splitEdge()</code> from <code>IntrinsicTriangulation</code> are not yet implemented for the integer coordinates representation. For <code>splitEdge()</code>, an alternate version is provided which returns a vertex instead.</p>"},{"location":"surface/intrinsic_triangulations/integer_coordinates/#constructors","title":"Constructors","text":"<code>IntegerCoordinatesIntrinsicTriangulation::IntegerCoordinatesIntrinsicTriangulation(ManifoldSurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; inputGeom, double mollifyEPS=1e-5)</code> <p>Initialize an intrinsic triangulation sitting on top of <code>mesh</code>. Recall that <code>IntrinsicGeometryInterface</code> can be almost any geometry object, including a <code>VertexPositionGeometry</code>.</p> <p>Initially, the intrinsic triangulation will be identical to the input mesh; it can be modified with the routines below.</p> <p>The <code>mollifyEPS</code> parameter performs initial mollification on the intrinsic triangulation, which greatly improves floating-point robustness while generally, while having a negligible impact on accuracy. Set <code>mollifyEPS=0</code> to disable.</p>"},{"location":"surface/intrinsic_triangulations/integer_coordinates/#citation","title":"Citation","text":"<pre><code>@article{gillespie2021integer,\ntitle={Integer Coordinates for Intrinsic Geometry Processing},\nauthor={Gillespie, Mark and Sharp, Nicholas and Crane, Keenan},\njournal={arXiv preprint arXiv:2106.00220},\nyear={2021}\n}\n</code></pre>"},{"location":"surface/intrinsic_triangulations/signposts/","title":"Signpost Intrinsic Triangulation","text":"<p>The signpost data structure encodes an intrinsic triangulation by storing \u201csignposts\u201d at mesh vertices. Explicitly, for each intrinsic edge it stores the edge\u2019s length and direction at the two incident vertices. This information fully specifies how the intrinsic triangulation sits above the input mesh. For more details, see Navigating Intrinsic Triangulations.</p> <p>The <code>SignpostIntrinsicTriangulation</code> is one concrete implementation (subclass) of intrinsic triangulations. Most of its functionality is documented there. Here, we document additional routines which are specific to signposts.</p>"},{"location":"surface/intrinsic_triangulations/signposts/#tradeoffs","title":"Tradeoffs","text":"<p>The signpost intrinsic triangulation is one of the two main intrinsic triangulation representations currently available in geometry-central, the other being integer coordinates. For many tasks, either reprentation will be highly effective, but there are some tradeoffs.</p> <p>Pros:</p> <ul> <li> <p>Performance. Signposts are moderately faster in terms of runtime than integer coordinates (although both are often on the order of milliseconds).</p> </li> <li> <p>Tangent vector data. Signposts naturally offer tangent space coordinate systems which are consistent with the input mesh, making it easy to work with tangent-valued data at vertices of the intrinsic triangulation.</p> </li> </ul> <p>Cons:</p> <ul> <li>Robustness. The representation relies heavily on tracing intrinsic edge paths across the input surface, which can be error-prone in floating-point arithmetic. In particular, reconstructing the common subdivision may fail if the input contains degenerate triangles.</li> </ul>"},{"location":"surface/intrinsic_triangulations/signposts/#constructors","title":"Constructors","text":"<code>SignpostIntrinsicTriangulation::SignpostIntrinsicTriangulation(ManifoldSurfaceMesh&amp; mesh, IntrinsicGeometryInterface&amp; inputGeom)</code> <p>Initialize an intrinsic triangulation sitting on top of <code>mesh</code>. Recall that <code>IntrinsicGeometryInterface</code> can be almost any geometry object, including a <code>VertexPositionGeometry</code>.</p> <p>Initially, the intrinsic triangulation will be identical to the input mesh; it can be modified with the routines below.</p>"},{"location":"surface/intrinsic_triangulations/signposts/#methods","title":"Methods","text":"<code>std::vector&lt;SurfacePoint&gt; SignpostIntrinsicTriangulation::traceIntrinsicHalfedgeAlongInput(Halfedge intrinsicHe, bool trimEnd)</code> <p>This function is generally the same as <code>traceIntrinsicHalfedgeAlongInput()</code>.</p> <p>When edges paths from signposts, the path often does not exactly hit the destination vertex, but rather ends somewhere very close in the adjacent 1-ring. If <code>trimEnd=true</code>, a simple heuristic is used to clean up the path so it exactly hits the target vertex; with <code>trimEnd=false</code> the result of tracing is directly reported.</p> <p>By default <code>traceIntrinsicHalfedgeAlongInput(he)</code> is equivalent to <code>traceIntrinsicHalfedgeAlongInput(he, true)</code>.</p>"},{"location":"surface/intrinsic_triangulations/signposts/#citation","title":"Citation","text":"<pre><code>@article{sharp2019navigating,\ntitle={Navigating intrinsic triangulations},\nauthor={Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan},\njournal={ACM Transactions on Graphics (TOG)},\nvolume={38},\nnumber={4},\npages={55},\nyear={2019},\npublisher={ACM}\n}\n</code></pre>"},{"location":"surface/surface_mesh/basics/","title":"Basics","text":"<p>The <code>SurfaceMesh</code> is the workhorse data structure for representing surface in geometry-central. Internally, it is reference-based mesh (similar to halfedge mesh), and can hold general polygonal meshes (though many routines only support triangle meshes). <code>SurfaceMesh</code> offers wide support for things like iterating around a mesh, modifying a mesh, and associating data with a mesh via containers. Under the hood, it is implemented with dense, automatically resizing buffers for efficient performance.</p> <pre><code>#include \"geometrycentral/surface/surface_mesh.h\"\n#include \"geometrycentral/surface/manifold_surface_mesh.h\"\n</code></pre> Old <code>HalfedgeMesh</code> type <p>In a previous version of <code>geometrycentral</code>, the mesh type was simply called <code>HalfedgeMesh</code>, and only supported manifold meshes. This type as been renamed to <code>ManifoldSurfaceMesh</code>.</p> <p>Including <code>geometrycentral/surface/halfedge_mesh.h</code> will simply typedef <code>HalfedgeMesh</code> as <code>ManifoldSurfaceMesh</code>, so most existing code will still work unchanged; new code should use <code>ManifoldSurfaceMesh</code>.</p>"},{"location":"surface/surface_mesh/basics/#general-vs-manifold-surface-meshes","title":"General vs. Manifold Surface Meshes","text":"<p>There are variants of the surface mesh class; the more general <code>SurfaceMesh</code> which can hold any very general polygonal mesh, and the more specific <code>ManifoldSurfaceMesh</code>, which only supports manifold, oriented meshes.</p> <p>Beyond the general capabilities of a <code>SurfaceMesh</code>, the <code>ManifoldSurfaceMesh</code>:</p> <ul> <li>inherits from <code>SurfaceMesh</code>, and can be used anywhere a <code>SurfaceMesh</code> is expected</li> <li>supports additional operations which require a manifold structure</li> <li>internally uses a more efficient representation</li> </ul> <p>There are also a small number of operations which might throw an error if called on a <code>ManifoldSurfaceMesh</code>, and should be used only on the more general <code>SurfaceMesh</code>. In particular, mutations which would make the mesh nonmanifold.</p> <p>Nonmanifold Meshes</p> <p>Support for general, possibly nonmanifold surface meshes is a recent addition to geometry-central. We are still gradually porting routines from supporting <code>ManifoldSurfaceMesh</code> to the more general <code>SurfaceMesh</code> where appropriate!</p>"},{"location":"surface/surface_mesh/basics/#element-types","title":"Element types","text":"<p>The <code>SurfaceMesh</code> also comes with a collection of lightweight types serving as logical references, or \u201chandles\u201d to mesh elements: <code>Vertex</code>, <code>Halfedge</code>, <code>Edge</code>, <code>Corner</code>, <code>Face</code>, and <code>BoundaryLoop</code> (<code>ManifoldSurfaceMesh</code> only). These handles are essentially just a typed wrapper around an ID for the element.  Deleting one of these handles does not delete the underlying element, and one may have many distinct handles to the same element <code>Vertex a; Vertex b; a == b;</code>.</p>"},{"location":"surface/surface_mesh/basics/#mesh-connectivity","title":"Mesh connectivity","text":"<p>Generally, you can (and should) interact with the mesh via higher-level, abstracted routines. However, this section details the low-level relationships between these handles. Note that on a <code>ManifoldSurfaceMesh</code>, the guarantees about these relationships are much stronger than on a more general <code>SurfaceMesh</code>.</p> <p>The primary type in our halfedge-based mesh is a halfedge, in addition to the usual vertex, edge and face types. A halfedge is a directed edge incident on a face, as shown below. </p> <p>On a <code>ManifoldSurfaceMesh</code>, two halfedges, oriented in opposite directions, make up each edge in the mesh. Each halfedge has relationships with five adjacent elements: </p> <ul> <li><code>Halfedge::twin()</code> the other halfedge across the incident edge</li> <li><code>Halfedge::next()</code> the next halfedge in clockwise order around the incident face</li> <li><code>Halfedge::vertex()</code> the vertex at the tail (back) of the halfedge</li> <li><code>Halfedge::edge()</code> the incident edge</li> <li><code>Halfedge::face()</code> the incident face</li> </ul> <p></p> <p>On a more general <code>SurfaceMesh</code>, rather than a single twin, the <code>Halfedge::sibling()</code> referene orbits around all other halfedge incident on the edge, which might point in the same or the opposite direction.</p> <p>Each vertex, edge, and face need just one relationship:</p> <ul> <li><code>Vertex::halfedge()</code> any of the incident halfedges (which point outward from the vertex)</li> <li><code>Edge::halfedge()</code> any of the incident halfedges</li> <li><code>Face::halfedge()</code> any of the incident halfedges</li> </ul> <p>In fact, these relationships is sufficient to implement pretty much any local traversal. Geometry central provides a wide range of convience iterators which wrap these relationships to traverse neighborhoods (see navigation).</p> <pre><code>for(Edge e : vertex.adjacentEdges()) {\n// do science\n}\n</code></pre>"},{"location":"surface/surface_mesh/basics/#manifold-oriented-surfaces","title":"Manifold, Oriented Surfaces","text":"<p>The <code>ManifoldSurfaceMesh</code> mesh imposes two requirements: manifoldness and orientation. </p> <p>Manifoldness means that our surface must locally look like a plane in any neighborhood. This disallows structures such as three faces meeting at an edge, or two cones of faces meeting at a single vertex like an hourglass. </p> <p>Furthermore the halfedge mesh implies a combinatorial orientation of the surface, indicated by the clockwise ordering of halfedges around each face (see figure below). Because the halfedge mesh implies an orientation, it cannot represent non-orientable surfaces, like a Klein bottle.</p> <p></p> <p>These properties are invariants which always hold for the <code>ManifoldSurfaceMesh</code>; in practice we check them during construction and ensure that all operations preserve them.</p>"},{"location":"surface/surface_mesh/basics/#basic-api","title":"Basic API","text":""},{"location":"surface/surface_mesh/basics/#constructors","title":"Constructors","text":"<p>See the mesh I/O page for helpers which read a mesh from file, and factory methods to construct a mesh and geometry simultaneously.</p> <code>SurfaceMesh(const std::vector&lt;std::vector&lt;size_t&gt;&gt;&amp; polygons)</code> <p>Constructs a mesh from a face-index list.</p> <ul> <li><code>polygons</code> a list of faces, each holding the indices of the vertices incident on that face, zero-indexed and in counter-clockwise order.</li> </ul> <code>ManifoldSurfaceMesh(const std::vector&lt;std::vector&lt;size_t&gt;&gt;&amp; polygons)</code> <p>Same as above, but constructs a manifold surface mesh.</p> <code>SurfaceMesh(const Eigen::MatrixBase&lt;T&gt;&amp; faces)</code> <p>Constructs a mesh from a rectangular face-index matrix, like an <code>Fx3</code> array of triangle indices, or an <code>Fx4</code> array of quad indices. The matrix scalar can be any integer type, like <code>size_t</code> or <code>int</code>.</p> <p>The <code>Eigen:MatrixBase&lt;T&gt;</code> type is just a general type which accepts most Eigen matrix types as input, including geometry-central\u2019s nicely-named wrapper <code>DenseMatrix&lt;T&gt;</code>.</p> <code>ManifoldSurfaceMesh(const Eigen::MatrixBase&lt;T&gt;&amp; faces)</code> <p>Same as above, but constructs a manifold surface mesh.</p> <code>ManifoldSurfaceMesh(const std::vector&lt;std::vector&lt;size_t&gt;&gt;&amp; polygons, const std::vector&lt;std::vector&lt;std::tuple&lt;size_t, size_t&gt;&gt;&gt;&amp; twins)</code> <p>Constructs a mesh from a face-index list, and extra data specifying the neighboring face across each face-side. This extra data allows you to describe meshes where there are multiple, distinct edges between some pair of vertices</p> <ul> <li> <p><code>polygons</code> a list of faces, each holding the indices of the vertices incident on that face, zero-indexed and in counter-clockwise order.</p> </li> <li> <p><code>twins</code> a list of tuples, in correspondence with the <code>polygons</code> list. For each side of a face, it holds an <code>(iF, iS)</code> tuple, where <code>iF</code> is the index of the face across the edge, and <code>iS</code> is the side of that face (e.g. the <code>iS = 2</code> for the third side of a triangle). Set both tuple elements to <code>INVALID_IND</code> for boundary sides.</p> </li> </ul>"},{"location":"surface/surface_mesh/basics/#element-counts","title":"Element counts","text":"<p>Remember, all functions from <code>SurfaceMesh</code> can also be called on <code>ManifoldSurfaceMesh</code>.</p> <code>size_t SurfaceMesh::nVertices()</code> <p>Returns the number of vertices. </p> <code>size_t SurfaceMesh::nInteriorVertices()</code> <p>Returns the number of vertices not incident on the boundary.</p> <code>size_t SurfaceMesh::nBoundaryVertices()</code> <p>Returns the number of vertices incident on the boundary.</p> <code>size_t SurfaceMesh::nEdges()</code> <p>Returns the number of edges. </p> <code>size_t SurfaceMesh::nFaces()</code> <p>Returns the number of faces in the mesh.</p> <code>size_t SurfaceMesh::nHalfedges()</code> <p>Returns the number of halfedges, including both interior halfedges and any exterior halfedges incident on boundary loops. Always exactly twice the number of edges.</p> <code>size_t SurfaceMesh::nInterioHalfedges()</code> <p>Returns the number of interior halfedges, which are incident on faces of the mesh. Always equal to the sum of the number of sides of all faces.</p> <code>size_t SurfaceMesh::nExteriorHalfedges()</code> <p>Returns the number of exterior halfedges, which are opposite boundary faces. </p> <code>size_t SurfaceMesh::nBoundaryLoops()</code> <p>Returns the number of distinct boundary loops in the mesh, each identified as an fictional face closing a boundary loop in the mesh.</p>"},{"location":"surface/surface_mesh/basics/#properties","title":"Properties","text":"<code>bool SurfaceMesh::hasBoundary()</code> <p>Returns true if the mesh has boundary, that is if it is not closed.</p> <p>Complexity \\mathcal{O}(1).</p> <code>int ManifoldSurfaceMesh::eulerCharacteristic()</code> <p>Returns the Euler characteristic of the surface. Computed in O(1) from element counts. </p> <p>Note: always computed by naively applying Euler\u2019s polyhedron formula, which might not do what you want in the case of multiple-connected components.</p> <code>int ManifoldSurfaceMesh::genus()</code> <p>Returns the genus of the surface. Computed in O(1) from element counts.</p> <p>Note: always computed by naively applying Euler\u2019s polyhedron formula, which might not do what you want in the case of multiple connected components.</p> <code>bool SurfaceMesh::isManifold()</code> <p>Returns true if the mesh is both edge- and vertex- manifold.</p> <p>Note that there is no <code>isVertexManifold()</code>, because a mesh which is edge-nonmanifold is always also vertex-nonmanifold.</p> <code>bool SurfaceMesh::isEdgeManifold()</code> <p>Returns true if the mesh is edge-manifold. </p> <code>bool SurfaceMesh::isOriented()</code> <p>Returns true if all faces have consistent orientations.</p> <code>bool SurfaceMesh::isTriangular()</code> <p>Returns true if all faces in the mesh have 3 sides. </p> <p>Complexity \\mathcal{O}(n)\\mathcal{O}(n), do not call in a tight loop.</p> <code>size_t SurfaceMesh::nConnectedComponents()</code> <p>Returns the number of distinct connected components of the mesh. </p> <p>Complexity \\mathcal{O}(n)\\mathcal{O}(n), do not call in a tight loop.</p>"},{"location":"surface/surface_mesh/basics/#utility-functions","title":"Utility functions","text":"<code>std::vector&lt;std::vector&lt;size_t&gt;&gt; SurfaceMesh::getFaceVertexList()</code> <p>Return a listing of the vertex indices incident on each face.</p> <code>DenseMatrix&lt;T&gt; SurfaceMesh::getFaceVertexMatrix()</code> <p>Return a dense <code>F x D</code> matrix of the vertex indices for each face in the mesh.  All faces in the mesh must have the same degree <code>D</code>.</p> <p>This function is templated on the scalar type for the resulting matrix, so call it like <pre><code>DenseMatrix&lt;size_t&gt; F = mesh-&gt;getFaceVertexMatrix&lt;size_t&gt;();\n</code></pre> to get a matrix where each entry is a <code>size_t</code>, or like <pre><code>DenseMatrix&lt;int&gt; F = mesh-&gt;getFaceVertexMatrix&lt;int&gt;();\n</code></pre> to get a matrix where each entry is an <code>int</code>.</p> <p>Remember that <code>DenseMatrix&lt;T&gt;</code> is just our nice synonym for <code>Eigen:::Matrix</code>.</p> <code>std::unique_ptr&lt;SurfaceMesh&gt; SurfaceMesh::copy() const</code> <p>Construct a copy of the mesh. </p> <code>std::unique_ptr&lt;ManifoldSurfaceMesh&gt; ManifoldSurfaceMesh::copy() const</code> <p>Construct a copy of the mesh. </p> <code>std::unique_ptr&lt;SurfaceMesh&gt; SurfaceMesh::copyToSurfaceMesh() const</code> <p>Construct a copy of the mesh. The underlying type will be the same as the underlying type of the mesh on which it is called.</p> <code>std::unique_ptr&lt;ManifoldSurfaceMesh&gt; SurfaceMesh::toManifoldMesh()</code> <p>Convert the mesh to <code>ManifoldSurfaceMesh</code>, which is certainly manifold and oriented.</p> <p>Throws an error if the mesh is not manifold and oriented.</p>"},{"location":"surface/surface_mesh/boundaries/","title":"Boundaries","text":"<p>Mesh boundaries in halfedge meshes are modelled by logically treating each boundary loop as if it were a face with an associated set of halfedges. These halfedges incident on boundary loops are referred to as exterior halfedges, while the usual halfedges incident on faces actually present in the mesh are interior halfedges. Any boundary edge of the mesh will have one interior and one exterior halfedge incident upon it.</p> <p></p> <p>Manifold Surfaces Only</p> <p>This section largely only applies to <code>ManifoldSurfaceMesh</code>, which has well-defined boundary loops. On a general <code>SurfaceMesh</code>, you can test if an element is along the boundary (like <code>edge.isBoundary()</code>), but not much else.</p>"},{"location":"surface/surface_mesh/boundaries/#exterior-halfedges","title":"Exterior halfedges","text":"<p>Nearly all routines involving halfedges include both interior and exterior halfedges, as this is most often what is needed in algorithms. <code>HalfedgeData&lt;&gt;</code> containers can hold data on exterior halfedges, and iterators (like <code>Vertex::outgoingHalfedges</code>) will iterate over both interior and exterior halfedges.</p> <p>A few routines explicitly indicate whether they process interior halfedges, exterior halfedges, or both, such as <code>ManifoldSurfaceMesh::nInteriorHalfedges()</code>.</p> <code>bool Halfedge::isInterior()</code> <p>Return: true if the halfedge is an interior halfedge, and false if it is an exterior halfedge.</p>"},{"location":"surface/surface_mesh/boundaries/#faces-and-boundary-loops","title":"Faces and boundary loops","text":"<p>The separate type <code>BoundaryLoop</code> is used to represent boundary loops, and offers all functionality of other element types. For instance, the <code>BoundaryLoopData&lt;&gt;</code> container can be used to associate data with boundary loops, and <code>BoundaryLoop::adjacentVertices()</code> can be used to iterate over the vertices along a boundary component.</p> <p>Since boundary loops act like faces in the mesh connectivity, traversing the mesh might yield a \u201cface\u201d referring to what is really a boundary loop. In particular, calling <code>Halfedge::face()</code> on an exterior halfedge will yield the \u201cface\u201d which is its boundary loop.  However, this \u201cface\u201d is a lie, we have not really added a face to the mesh: <code>ManifoldSurfaceMesh::nFaces()</code> will still report the actual number of faces, etc.  The only valid thing to do with a <code>Face</code> which actually a boundary loop is to immediately convert it to a <code>BoundaryLoop</code>, See the example below.</p> <pre><code>Halfedge myHe = /* some exterior halfedge */;\nassert(myHe.isInterior() == false); // this is an exterior halfedge\n\n// Traverse to \"face\"\nFace bFace = myExteriorHalfedge.face();\n\n// bFace is really a boundary loop, doing any face things \n// with it would be invalid\nassert(bFace.isBoundaryLoop() == true);\n\n// Convert the \"face\" to its true boundary loop form \nBoundaryLoop bLoop = bFace.asBoundaryLoop();\n\n// Now we can do all kinds of things with it\nfor(Edge e : bLoop.adjacentEdges()) {\n/* do science */\n}\n</code></pre> <code>bool Face::isBoundaryLoop()</code> <p>Returns true if the face is really a boundary loop.</p> <code>BoundaryLoop Face::asBoundaryLoop()</code> <p>Convert a face to the equivalent boundary loop. Only valid to call on a face for which <code>Face::isBoundaryLoop() == true</code>.</p> <code>Face BoundaryLoop::asFace()</code> <p>Convert a boundary loop back to its equivalent face. The inverse of <code>Face::asBoundaryLoop()</code>. Rarely used.</p>"},{"location":"surface/surface_mesh/boundaries/#element-boundary-properties","title":"Element boundary properties","text":"<p>The previous sections describe elements which make up the boundary of a mesh. The methods here identify elements which merely lie along the mesh boundary.</p> <code>bool Vertex::isBoundary()</code> <p>Returns true if the vertex is on the boundary. A vertex is on the boundary if any of its incident edges are boundary edges. O(1).</p> <code>bool Edge::isBoundary()</code> <p>Returns true if the edge is on the boundary. An edge is on the boundary if either of its incident halfedges are exterior halfedges. O(1)O(1).</p> <p>Note that only edges which lie entirely along a boundary are considered boundary edges. Edges which \u201cpoint at\u201d the boundary and touch the boundary only at one endpoint are not considered boundary edges by this function.</p>"},{"location":"surface/surface_mesh/containers/","title":"Containers","text":"<p>The halfedge mesh class is equipped with a system of containers for associating data with mesh vertices, halfedges, edges, and faces. For instance, to represent a scalar value at vertices, or a vector value at faces, one can use </p> <p><pre><code>// on vertices\nVertexData&lt;double&gt; myVertexScalar(mesh);\nVertex v = /* some vertex */;\nmyVertexScalar[v] = 42.;\n\n// on faces\nFaceData&lt;Vector3&gt; myFaceVector(mesh);\nFace f = /* some face */;\nmyFaceVector[f] = Vector3{1., 2., 3.};\n</code></pre> and so on.</p> <p>A key feature of the <code>MeshData&lt;&gt;</code> containers is that they automatically adapt to mutation of the underlying mesh. All existing <code>MeshData&lt;&gt;</code> containers will remain valid during any sequence of mesh element insertions and deletions, adaptively and efficiently resizing themselves as needed. These containers can also be automatically written to file.</p>"},{"location":"surface/surface_mesh/containers/#mesh-data-types","title":"Mesh data types","text":"<p>The mesh data types are all templated on a common base class: <code>MeshData&lt;E,T&gt;</code>, where <code>E</code> is an element pointer type (such as <code>Vertex</code>) and <code>T</code> is a scalar type (such as <code>double</code>). The first template argument should usually be omitted in user code; the various element containers are all typedef\u2019d with concise names as follows:</p> <ul> <li><code>VertexData&lt;T&gt;</code> data at vertices</li> <li><code>HalfedgeData&lt;T&gt;</code> data at (interior and exterior) halfedges </li> <li><code>CornerData&lt;T&gt;</code> data at corners</li> <li><code>EdgeData&lt;T&gt;</code> data at edges </li> <li><code>FaceData&lt;T&gt;</code> data at faces </li> <li><code>BoundaryLoopData&lt;T&gt;</code> data at boundary loops</li> </ul> <p>Most functionality is identical between all of these classes, so the sections below are written in terms of the generic <code>MeshData&lt;&gt;</code> class.</p>"},{"location":"surface/surface_mesh/containers/#construction","title":"Construction","text":"<code>MeshData&lt;E,T&gt;::MeshData&lt;E,T&gt;(SurfaceMesh&amp; mesh)</code> <p>Construct a new container over a mesh. Elements will be default-initialized with <code>T()</code>.</p> <code>MeshData&lt;E,T&gt;::MeshData&lt;E,T&gt;(SurfaceMesh&amp; mesh, T initVal)</code> <p>Construct a new container over a mesh. </p> <p>Elements will be initialized with <code>initVal</code>, and any newly-created mesh elements will have their default values set to <code>initVal</code>.</p> <p>Additionally, see the vector-based initializers in vector interoperability.</p>"},{"location":"surface/surface_mesh/containers/#accessors","title":"Accessors","text":"<code>T&amp; MeshData&lt;E,T&gt;::operator[](E ptr)</code> <p>Access data stored in the container with a reference to a mesh element. A const version also exists; expect semantics like <code>std::vector&lt;&gt;</code>.</p> <p>For example: <pre><code>// on vertices\nVertexData&lt;double&gt; myVertexScalar(mesh);\nVertex v = /* some vertex */;\nmyVertexScalar[v] = 42.;\ndouble val = myVertexScalar[v];\n</code></pre></p> <code>T&amp; MeshData&lt;E,T&gt;::operator[](size_t ind)</code> <p>Access data stored in the container by the index of a mesh element. A const version also exists; expect semantics like <code>std::vector&lt;&gt;</code>.</p> <p>Only valid when the underlying mesh is compressed.</p> <p>Must have <code>0 &lt;= ind &lt; N</code>, where <code>N</code> is the number of elements of that type.</p> <p>For example: <pre><code>// on vertices\nVertexData&lt;double&gt; myVertexScalar(mesh);\nmyVertexScalar[11] = 42.;\ndouble val = myVertexScalar[11];\n\n// equivalent to:\ndouble val = myVertexScalar[mesh-&gt;vertex(11)];\n</code></pre></p> <code>void MeshData&lt;E,T&gt;::fill(T fillVal)</code> <p>Fill all entries in the container with <code>fillVal</code>.</p> <code>size_t MeshData&lt;E,T&gt;::size()</code> <p>The size of the underlying buffer for the container. In particular, the largest integer <code>i</code> such that <code>data[i]</code> is safe.</p> <p>Generally on a compressed mesh this is the same as the number of elements of type <code>E</code>, e.g. <code>SurfaceMesh::nVertices()</code>, but on an uncompressed mesh or in the presence of exterior halfedges it may be larger.</p> <p>NOTE: The behavior of this function as changed in recent versions.</p> <code>SurfaceMesh* MeshData&lt;E,T&gt;::getMesh() const</code> <p>The mesh on which the container is defined.</p>"},{"location":"surface/surface_mesh/containers/#arithmetic","title":"Arithmetic","text":"<p><code>MeshData&lt;&gt;</code> containers support arithmetic operations with each other, and with scalar values. All arithmetic is applied independently to each value in the container, and is only well-defined for containers defined on the same mesh.</p> <pre><code>// add two vertex datas together\nVertexData&lt;double&gt; A(*mesh, 1.); // (sample data, filled with all 1's)\nVertexData&lt;double&gt; B(*mesh, 2.); VertexData&lt;double&gt; C = A + B;\n\n// multiply times a scalar\nFaceData&lt;double&gt; vals(*mesh, 1.);\nvals *= 12.0;\n\n// types do not need to be the same, as long as the operation\n// is well-defined\nVertexData&lt;float&gt; scales(*mesh, 2.);\nVertexData&lt;Vector3&gt; vecs(*mesh, Vector3{1., 2., 3.});\nVertexData&lt;Vector3&gt; scaledVecs = scales * vecs ;\n</code></pre> <p>The binary operators <code>+,-,*,/,%,&amp;,|,^,&lt;&lt; ,&gt;&gt;,&amp;&amp;,||</code> and the unary operators <code>+,-,!,~</code> are all supported, along with the matching assignment operators like <code>+=</code>. Of course, the underlying container entry types must support the operation, and the result of the operation must be compatible with the destination container.</p>"},{"location":"surface/surface_mesh/containers/#vector-interoperability","title":"Vector interoperability","text":"<p>To support easy common-case linear algebra operations, <code>MeshData&lt;&gt;</code> containers support conversion to and from Eigen vector types.</p> <p>The corresponding vectors are indexed according to the indices of the underlying mesh elements, or by a user-supplied index map which maps each elements to a dense set of zero-based indices.</p> <p>Construct from a vector:</p> <code>MeshData&lt;E,T&gt;::MeshData&lt;E,T&gt;(SurfaceMesh&amp; mesh Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; vec)</code> <p>Construct a new container over a mesh, with the contents of <code>vec</code>.</p> <code>MeshData&lt;E,T&gt;::MeshData&lt;E,T&gt;(SurfaceMesh&amp; mesh Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; vec, MeshData&lt;E, size_t&gt;&amp; indexer)</code> <p>Construct a new container over a mesh, with the contents of <code>vec</code>, indexed according to <code>indexer</code>.</p> <p>Fill from a vector:</p> <code>void MeshData&lt;E,T&gt;::fromVector(Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; vec)</code> <p>Fill this container with the contents of <code>vec</code>.</p> <code>void MeshData&lt;E,T&gt;::fromVector(Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; vec, MeshData&lt;E, size_t&gt;&amp; indexer)</code> <p>Fill this container with the contents of <code>vec</code>, indexed according to <code>indexer</code>.</p> <p>Convert to a vector:</p> <code>Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; MeshData&lt;E,T&gt;::toVector()</code> <p>Return a new <code>std::vector</code> which holds the contents of this container.</p> <p>Detail: this vector will always be a dense listing of values per-element, regardless of whether the mesh is compressed, etc. Therefore, the contents of this vector are not necessarily always identical to the raw underlying buffer via <code>raw()</code>. Even in the case of a compressed mesh, for <code>CornerData&lt;&gt;</code> the resulting vector will omit implicit indices for exterior \u201coutside\u201d corners which may exist on meshes with boundary.</p> <code>Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt; MeshData&lt;E,T&gt;::toVector(MeshData&lt;E, size_t&gt;&amp; indexer)</code> <p>Return a new vector which holds the contents of this container, indexed according to <code>indexer</code>.</p> <p>See <code>toVector()</code> for more details.</p>"},{"location":"surface/surface_mesh/containers/#default-values","title":"Default values","text":"<p>All containers track a default value for their elements, which can optionally be set at construction; if not set it is simply <code>T()</code>. After construction this value is significant because it will be used as the value for any newly-created mesh elements if the underlying mesh is mutated. The getter and setter below allow you to modify the default value for an existing container.</p> <code>void MeshData&lt;E,T&gt;::setDefault(T newDefault)</code> <p>Sets a new default value for the container. </p> <p>Does not modify any existing data in the container.</p> <code>T MeshData&lt;E,T&gt;::getDefault() const</code> <p>Get the current default value for the container. </p>"},{"location":"surface/surface_mesh/containers/#transferring-data","title":"Transferring data","text":"<p><code>MeshData&lt;&gt;</code> containers are defined with respect to a particular mesh object. Sometimes one may need to transfer data defined on one mesh to another, for instance after making a copy of a mesh, or when reading data from file.</p> <code>MeshData&lt;E,T&gt; MeshData&lt;E,T&gt;::reinterpretTo(SurfaceMesh&amp; target)</code> <p>Map data defined on one halfedge mesh to another. The meshes must have the same number of elements, and data will be naively transferred between elements with the same index.</p> <p>Requires that both meshes be compressed.</p> <p>Example usage: <pre><code>SurfaceMesh meshA = /* something */;\nstd::unique_ptr&lt;SurfaceMesh&gt; meshB = meshA.copy();\n\nFaceData&lt;Vector3&gt; myDataOnA(meshA);\n/* fill myDataOnA with interesting values */\n\nFaceData&lt;Vector3&gt; myDataOnB = myDataOnA.reinterpretTo(*meshB);\n</code></pre></p>"},{"location":"surface/surface_mesh/containers/#advanced-features","title":"Advanced features","text":"<p>Under the hood, all <code>MeshData&lt;&gt;</code> types use a <code>Eigen::Matrix&lt;T&gt;</code> to store their values. However, the size and indexing indexing are carefully managed in conjunction with the underlying mesh. This vector will only be a dense listing if the mesh is compressed.</p> <code>Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt;&amp; MeshData&lt;E,T&gt;::raw()</code> <p>Access the raw underlying Eigen vector of storage.</p> <code>const Eigen::Matrix&lt;T, Eigen::Dynamic, 1&gt;&amp; MeshData&lt;E,T&gt;::raw() const</code> <p>Access the raw underlying Eigen vector of storage (const).</p>"},{"location":"surface/surface_mesh/delta_complex/","title":"Delta Complexes","text":"<p>TL;DR</p> <p>This section clarifies some formal mathematical ideas that may arise in advanced usage of the halfedge mesh class. If you are simply loading up a triangle mesh and running an ordinary geometry processing algorithm, you need not worry about these details\u2014everything will behave as expected.</p> <p>If you are implementing intrinsic triangulation algorithms, doing an unreasonable number of edge flips, or are simply curious: read on!</p>"},{"location":"surface/surface_mesh/delta_complex/#introduction","title":"Introduction","text":"<p>Halfedge meshes are often used to represent simplicial complexes. When you\u2019re thinking about a triangle mesh, you probably imagine a simplicial complex: each face has three distinct vertices and three distinct edges, each edge connects two distinct vertices, and there can be at most one edge between any pair of vertices.</p> <p>In fact, halfedge meshes (unlike many other mesh representations) can actually represent more general structures than just simplicial complexes. Halfedges meshes can represent any (oriented, manifold) \\Delta-complex1. Intuitively, the \\Delta\\Delta-complex relaxes the restriction that incident elements be unique:</p> <ul> <li>a face may be incident on the same vertex multiple times</li> <li>an edge may connect a vertex to itself</li> <li>there may be multiple edges between a pair of vertices</li> </ul> <p>However, the \\Delta\\Delta-complex still requires that every faces has 3 sides, and the manifold restriction still means that the complex looks like a surface in any local neighborhood. Recall that we are only concerned with the connectivity of these surfaces, not how they sit in space: these general \\Delta\\Delta-complexes might be impossible to embed with straight edges between vertex positions in \\mathbb{R}^3\\mathbb{R}^3, but that does not bother us right now.</p> <p>The following surfaces are \\Delta\\Delta-complexes but not simplicial complexes:</p> <p></p>"},{"location":"surface/surface_mesh/delta_complex/#that-sounds-complicated-why-would-you-do-that","title":"That sounds complicated, why would you do that?","text":"<p>Don\u2019t forget, \\Delta\\Delta-complexes are a superset of simplicial complexes, so everything that works on general \\Delta\\Delta-complexes will work on a plain old triangle mesh too. Buy why go to the extra trouble to support general \\Delta\\Delta-complexes in geometry central?</p> <p>General \\Delta\\Delta-complexes allow extremely powerful algorithms for intrinsic geometry processing. Most famously, the intrinsic Delaunay formulation2 builds a Laplace operator for an input triangle mesh which has fantastic numerical and computational properties, and the algorithm requires representing a \\Delta\\Delta-complex as an intermediate step. More generally, intrinsic triangulations3 enable computational geometry algorithms like Delaunay refinement on triangle meshes, so long as long as one can represent \\Delta\\Delta-complexes which arise in intermediate steps. In both of these examples, features like self-edges are rare, and do not occur on most inputs. However, supporting them is necessary for the robustness and correctness of the algorithm.</p> <p>Fortunately, working in a software library which already supports the nuances of \\Delta\\Delta-complexes means these powerful algorithms can be implemented with little additional work.</p>"},{"location":"surface/surface_mesh/delta_complex/#software-support","title":"Software support","text":"<p>The halfedge mesh class in geometry central is explicitly designed to ensure support for \\Delta\\Delta-complexes, rather than just simplicial complexes. Mostly, this is a natural consequence of the halfedge mesh formulation, but special care is needed for a few operations like mutations and automatically written to file. Wherever relevant, the API will note its special properties with respect to \\Delta\\Delta-complexes. </p> <ol> <li> <p>see Section 2.1 of Algebraic Topology by Allen Hatcher\u00a0\u21a9</p> </li> <li> <p>Bobenko, Alexander I., and Boris A. Springborn. A discrete Laplace\u2013Beltrami operator for simplicial surfaces. Discrete &amp; Computational Geometry (2007)\u00a0\u21a9</p> </li> <li> <p>Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan.  Navigating Intrinsic Triangulations.  ACM Trans. Graph. (2019)\u00a0\u21a9</p> </li> </ol>"},{"location":"surface/surface_mesh/elements/","title":"Elements","text":""},{"location":"surface/surface_mesh/elements/#introduction","title":"Introduction","text":"<p>This section covers the elements types for our surface mesh, as well as the traversal and utility functions that they offer.</p> <p>Note</p> <p>In the most proper sense, these element types are really \u201chandles\u201d to the underlying element. They refer to a particular element, but the <code>Vertex</code> variable in memory is not really the mesh element itself, just a temporary reference to it.</p> <p>For instance, it is possible (and common) to have multiple <code>Vertex</code> variables which actually refer to the same vertex, and allowing a <code>Vertex</code> variable to go out of scope certainly does not delete the vertex in the mesh.</p> <p>However, the semantics are very natural, so for the sake of brevity we call the type simply <code>Vertex</code>, rather than <code>VertexHandle</code> (etc).</p> <p>Additionally, see navigation for iterators to travese adjacent elements, like <code>for(Vertex v : face.adjacentVertices())</code>.</p>"},{"location":"surface/surface_mesh/elements/#construction","title":"Construction","text":"<p>Element types do not have constructors which should be called by the user. Instead, the element will always be created for you, via one of several methods, including:</p> <ul> <li>Iterating through the mesh <code>for(Vertex v : mesh.vertices())</code></li> <li>Traversing from a neighbor element <code>Face f = halfedge.face()</code></li> <li>Iterating around an element <code>for(Halfedge he : vertex.outgoingHalfedges())</code></li> </ul> <p>Adding a new element to a mesh is covered in the mutation section.</p>"},{"location":"surface/surface_mesh/elements/#comparison-hashing","title":"Comparison &amp; Hashing","text":"<p>All mesh elements support:</p> <ul> <li>equality checks (<code>==</code>, <code>!=</code>)</li> <li>comparions (<code>&lt;</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, according to the iteration order of the elements)</li> <li>hashing (so they can be used in a <code>std::unordered_map</code>)</li> </ul>"},{"location":"surface/surface_mesh/elements/#vertex","title":"Vertex","text":"<p>A vertex is a 0-dimensional point which serves as a node in the mesh.</p> <p>Traversal:</p> <code>Halfedge Vertex::halfedge()</code> <p>Returns one of the halfedges whose tail is incident on this vertex. </p> <p>If the vertex is a boundary vertex, then it is guaranteed that the returned halfedge will be the unique interior halfedge along the boundary. That is the unique halfedge such that <code>vertex.halfedge().twin().isInterior() == false</code>.</p> <code>Corner Vertex::corner()</code> <p>Returns one of the corners incident on the vertex.</p> <p>Utility:</p> <code>bool Vertex::isBoundary()</code> <p>Returns true if the vertex is along the boundary of the mesh. </p> <p>See boundaries for more information.</p> <code>bool Vertex::isManifold()</code> <p>Returns true if the vertex neighborhood is manifold.</p> <code>bool Vertex::isManifoldAndOriented()</code> <p>Returns true if the vertex neighborhood is manifold, and all faces have consistent orientations.</p> <code>size_t Vertex::degree()</code> <p>The degree of the vertex, i.e. the number of edges incident on the vertex.</p> <code>size_t Vertex::faceDegree()</code> <p>The face-degree of the vertex, i.e. the number of faces incident on the vertex. On the interior of a mesh, this will be equal to <code>Vertex::degree()</code>, at the boundary it will be smaller by one.</p>"},{"location":"surface/surface_mesh/elements/#halfedge","title":"Halfedge","text":"<p>A halfedge is a the basic building block of a halfedge mesh. As its name suggests, the halfedge is half of an edge, connecting two vertices and sitting on on side of an edge in some face. The halfedge is directed, from its tail, to its tip. Our halfedges have a counter-clockwise orientation: the halfedges with in a face will always point in the counter-clockwise direction. On a <code>ManifoldSurfaceMesh</code>, a halfedge and its twin (the neighbor across an edge) will point in opposite directions.</p> <p>Traversal:</p> <code>Halfedge Halfedge::twin()</code> <p>Returns the halfedge\u2019s twin, a neighbor across an edge. See notes in <code>sibling()</code>.</p> <p>On a <code>ManifoldSurfaceMesh</code>, it will point in the opposite direction.  Calling twin twice will always return to the initial halfedge: <code>halfedge.twin().twin() == halfedge</code>.</p> <code>Halfedge Halfedge::sibling()</code> <p>A synonym for <code>twin()</code>, which makes it clear that on a general <code>SurfaceMesh</code> which is not manifold there may be many halfedges incident on an edge. Calling <code>sibling()</code> repeatedly orbits around these halfedges.</p> <code>Halfedge Halfedge::next()</code> <p>Returns the next halfedge in the same face as this halfedge, according to the counter-clockwise ordering.</p> <code>Vertex Halfedge::vertex()</code> <p>Returns the vertex at the tail of this halfedge.</p> <code>Vertex Halfedge::tailVertex()</code> <p>Returns the vertex at the tail of this halfedge.</p> <code>Vertex Halfedge::tipVertex()</code> <p>Returns the vertex at the tip of this halfedge.</p> <code>Edge Halfedge::edge()</code> <p>Returns the edge that this halfedge sits along.</p> <code>Face Halfedge::face()</code> <p>Returns the face that this halfedge sits inside.</p> <p>Note that in the case of a mesh with boundary, if the halfedge is exterior the result of this function will really be a boundary loop. See boundaries for more information.</p> <code>Corner Halfedge::corner()</code> <p>Returns the corner at the tail of this halfedge.</p> <p>Fancy Traversal:</p> <code>Halfedge Halfedge::prevOrbitFace()</code> <p>Returns the previous halfedge, that is the halfedge such that <code>he.next() == *this</code>. This result is found by orbiting around the shared face.</p> <p>Because our halfedge mesh is singly-connected, this is not a simple O(1) lookup, but must be computed by orbiting around the face. Be careful: calling <code>he.prevOrbitFace()</code> on each exterior halfedge can easily lead to O(N^2)O(N^2) algorithm complexity, as each call walks all the way around a a boundary loop.</p> <p>Generally this operation can (and should) be avoided with proper code structure.</p> <p>Utility:</p> <code>bool Halfedge::isInterior()</code> <p>Returns true if the edge is interior, and false if it is exterior (i.e., incident on a boundary loop).</p> <p>See boundaries for more information.</p> <code>bool Halfedge::orientation()</code> <p>Returns true if the halfedge points in the same direction as the arbitrary orientation defined at each edge.</p> <p>For instance, for two halfedges incident on the same edge, you can test if they point in the same direction by checking <code>heA.orientation() == heB.orientation()</code>. Recall that two halfedges will point in the same direction along an edge when their respective faces have opposite orientation.</p>"},{"location":"surface/surface_mesh/elements/#edge","title":"Edge","text":"<p>An edge is a 1-dimensional element that connects two vertices in the mesh.</p> <p>Traversal:</p> <code>Halfedge Edge::halfedge()</code> <p>Returns one of the two halfedges incident on this edge. If the edge is a boundary edge, it is guaranteed that the returned edge will be the interior one.</p> <code>Vertex Edge::otherVertex(Vertex v)</code> <p>Of the two vertices incident on the edge, returns the one which is not <code>v</code>. If both incident vertices are <code>v</code>, returns <code>v</code>.</p> <code>Vertex Edge::firstVertex()</code> <p>Returns one of the two vertices incident on the edge. In particular, returns <code>edge.halfedge().tailVertex()</code>.</p> <p>See also: <code>Edge::secondVertex()</code>.</p> <code>Vertex Edge::secondVertex()</code> <p>Returns one of the two vertices incident on the edge. In particular, returns <code>edge.halfedge().tipVertex()</code>.</p> <p>See also: <code>Edge::firstVertex()</code>.</p> <p>Utility:</p> <code>bool Edge::isBoundary()</code> <p>Returns true if the edge is along the boundary of the mesh. Note that edges which merely touch the boundary at one endpoint are not considered to be boundary edges.</p> <p>See boundaries for more information.</p> <code>bool Edge::isOriented()</code> <p>Returns true if the faces on either side have matching orientations. A nonmanifold edge is never oriented.</p> <code>size_t Edge::degree()</code> <p>Returns the number of faces indcident on the edge.</p>"},{"location":"surface/surface_mesh/elements/#face","title":"Face","text":"<p>A face is a 2-dimensional element formed by a loop of 3 or more edges. In general, our faces can be polygonal with d \\ge 3d \\ge 3 edges, though many of the routines in geometry central are only valid on triangular meshes.</p> <p>Traversal:</p> <code>Halfedge Face::halfedge()</code> <p>Returns any one of the halfedges inside of this face.</p> <code>BoundaryLoop Face::asBoundaryLoop()</code> <p>Reinterprets this element as a boundary loop. Only valid if the face is, in fact, a boundary loop.  See boundaries for more information.</p> <p>Utility:</p> <code>bool Face::isBoundaryLoop()</code> <p>Returns true if the face is really a boundary loop.  See boundaries for more information.</p> <code>bool Face::isTriangle()</code> <p>Returns true if the face has three sides.  </p> <code>size_t Face::degree()</code> <p>Returns the number of sides in the face. Complexity O(d)O(d), where dd is the resulting degree.</p>"},{"location":"surface/surface_mesh/elements/#boundary-loop","title":"Boundary Loop","text":"<p>A boundary loop is a special face-like element used to represent holes in the mesh due to surface boundary.  These are only defined on a <code>ManifoldSurfaceMesh</code>, which necessarily has coherent boundary loops.  See boundaries for more information.</p> <p>Traversal:</p> <code>Halfedge BoundaryLoop::halfedge()</code> <p>Returns any one of the halfedges inside of the boundary loop.</p> <p>Utility:</p> <code>size_t BoundaryLoop::degree()</code> <p>Returns the number of sides in the boundary loop. Complexity O(d)O(d), where dd is the resulting degree.</p>"},{"location":"surface/surface_mesh/elements/#corner","title":"Corner","text":"<p>A corner is a convenience type referring to a corner inside of a face. Tracking corners as a separate type is useful, because one often logically represents data defined at corners.</p> <p>Traversal:</p> <code>Halfedge Corner::halfedge()</code> <p>Returns the halfedge whose tail touches this corner. That is to say, <code>corner.halfedge().vertex() == corner.vertex()</code>.</p> <code>Vertex Corner::vertex()</code> <p>Returns the vertex which this corner is incident on.</p> <code>Face Corner::face()</code> <p>Returns the face that this corner sits inside of.</p>"},{"location":"surface/surface_mesh/indexing/","title":"Indexing","text":"<p>Several methods can be used to obtain integer indices associated with mesh elements.  Such indices are often needed for, e.g., building matrices.  These methods index elements from 0 through the number of elements of the same kind.  I.e., vertices are indexed 0, 1, 2, \u2026, up through the number of vertices.  In general nothing can/should be assumed about this ordering, except that it will remain fixed as long as the mesh connectivity is not changed.</p> <p>Note that in some cases, the most straightforward thing may be to just assign your own indices\u2014especially if the indexing scheme needed to build your matrix is different from a straightforward enumeration of mesh elements.  For instance, in the following example a boolean vertex attribute <code>skip</code> is provided, which determines whether each vertex is used in a linear system:</p> <pre><code>VertexData&lt;bool&gt; skip; // assume skip[v] is true if v is not used in the linear system\nVertexData&lt;size_t&gt; vertexIndex( mesh );\nint i = 0;\nfor( Vertex v : mesh.vertices() ) {\nif( !skip[v] ) {\nvertexIndex[v] = i;\ni++;\n}\n}\n</code></pre>"},{"location":"surface/surface_mesh/indexing/#uncached-index-arrays","title":"Uncached index arrays","text":"<p>These methods build and return an <code>ElementData&lt;size_t&gt;</code> array that indexes the mesh elements. Note that these arrays are not cached, and arrays are re-built each time the method is invoked.</p> <code>HalfedgeData&lt;size_t&gt; SurfaceMesh::getHalfedgeIndices()</code> <p>Returns an array that provides indices for all halfedges, with values between 0 and H-1, where H is the number of halfedges in the mesh.</p> <code>CornerData&lt;size_t&gt; SurfaceMesh::getCornerIndices()</code> <p>Returns an array that provides indices for all corners, with values between 0 and C-1, where C is the number of corners in the mesh.</p> <code>VertexData&lt;size_t&gt; SurfaceMesh::getVertexIndices()</code> <p>Returns an array that provides indices for all vertices, with values between 0 and V-1, where V is the number of vertices in the mesh.</p> <code>VertexData&lt;size_t&gt; SurfaceMesh::getInteriorVertexIndices()</code> <p>Returns an array that provides indices for all interior vertices, with values between 0 and I-1, where I is the number of interior vertices in the mesh.</p> <code>EdgeData&lt;size_t&gt; SurfaceMesh::getEdgeIndices()</code> <p>Returns an array that provides indices for all edges, with values between 0 and E-1, where E is the number of edges in the mesh.</p> <code>FaceData&lt;size_t&gt; SurfaceMesh::getFaceIndices()</code> <p>Returns an array that provides indices for all faces, with values between 0 and F-1, where F is the number of faces in the mesh.</p> <code>BoundaryLoopData&lt;size_t&gt; SurfaceMesh::getBoundaryLoopIndices()</code> <p>Returns an array that provides indices for all boundary loops, with values between 0 and B-1, where B is the number of boundary loops in the mesh.</p>"},{"location":"surface/surface_mesh/indexing/#cached-index-arrays","title":"Cached index arrays","text":"<p>These methods build the same arrays as the uncached methods, but cache them in a <code>Geometry</code> object. Note that indices of course do not relate to the actual geometry (i.e., shape and size) of the mesh\u2014however, this mechanism allows indices to be tracked with the geometry classes, so they can participate in the buffer management and dependency management.  Basic example usage:</p> <pre><code>SurfaceMesh mesh;\nVertexPositionGeometry geometry( mesh );\ngeometry-&gt;requireVertexIndices();\nfor( Vertex v : mesh-&gt;vertices() ) {\nint i = geometry-&gt;vertexIndices[v];\n// do science\n}\n</code></pre> <code>void BaseGeometryInterface::requireHalfedgeIndices()</code> <p>Builds and maintains the array <code>BaseGeometryInterface::halfedgeIndices</code> that provides indices for all halfedges, with values between 0 and H-1, where H is the number of halfedges in the mesh.</p> <code>void BaseGeometryInterface::requireCornerIndices()</code> <p>Builds and maintains the array <code>BaseGeometryInterface::cornerIndices</code> that provides indices for all corners, with values between 0 and C-1, where C is the number of halfedges in the mesh.</p> <code>void BaseGeometryInterface::requireVertexIndices()</code> <p>Builds and maintains the array <code>BaseGeometryInterface::vertexIndices</code> that provides indices for all vertices, with values between 0 and V-1, where V is the number of vertices in the mesh.</p> <code>void BaseGeometryInterface::requireInteriorVertexIndices()</code> <p>Builds and maintains the array <code>BaseGeometryInterface::interiorVertexIndices</code> that provides indices for all interior vertices, with values between 0 and I-1, where I is the number of interior vertices in the mesh.</p> <code>void BaseGeometryInterface::requireEdgeIndices()</code> <p>Builds and maintains the array <code>BaseGeometryInterface::edgeIndices</code> that provides indices for all edges, with values between 0 and E-1, where E is the number of edges in the mesh.</p> <code>void BaseGeometryInterface::requireFaceIndices()</code> <p>Builds and maintains the array <code>BaseGeometryInterface::faceIndices</code> that provides indices for all faces, with values between 0 and F-1, where F is the number of faces in the mesh.</p> <code>void BaseGeometryInterface::requireBoundaryLoopIndices()</code> <p>Builds and maintains the array <code>BaseGeometryInterface::boundaryLoopIndices</code> that provides indices for all boundary loops, with values between 0 and B-1, where B is the number of boundary loops in the mesh.</p>"},{"location":"surface/surface_mesh/indexing/#per-element-indices","title":"Per element indices","text":"<p>Warning</p> <p>The routines in this section are valid only when the mesh is compressed.</p> <p>These methods access the index directly from the mesh element itself.  For example:</p> <pre><code>Edge e;\nsize_t i = e.getIndex();\n</code></pre> <code>size_t Halfedge::getIndex() const</code> <p>Returns an index between 0 and H-1, where H is the number of halfedges in the mesh.</p> <code>size_t Corner::getIndex() const</code> <p>Returns an index between 0 and C-1, where C is the number of corners in the mesh.</p> <code>size_t Vertex::getIndex() const</code> <p>Returns an index between 0 and V-1, where V is the number of vertices in the mesh.</p> <code>size_t Edge::getIndex() const</code> <p>Returns an index between 0 and E-1, where E is the number of edges in the mesh.</p> <code>size_t Face::getIndex() const</code> <p>Returns an index between 0 and F-1, where F is the number of faces in the mesh.</p>"},{"location":"surface/surface_mesh/internals/","title":"Halfedge mesh internals","text":"<p>This section contains details about the internal implementation of the halfedge mesh data structure. Typical users should not need to care about these details, but they may be useful for extension and debugging.</p> <p>The halfedge mesh structure is designed to simultaneously satisfy two core principles:</p> <ol> <li>contiguous storage: elements and mesh data are stored in flat buffers of memory. This makes traversing and storing data on the mesh fast.</li> <li>O(1) updates: dynamic operations that add and remove new elements must be supported in (amortized) constant time. This makes modifying the mesh fast.</li> </ol> <p>The solution to these two requirements is a dynamically-resizing, array-based mesh. Like a <code>std::vector</code>, elements are stored in contiguous buffers of memory, which are transparently expanded and copied sporadically. Of course, this expansion is largely hidden from the user.</p> <p>Philosophically, our halfedge mesh aims to be as-implicit-as-possible: whenever we can, we represent connectivity and properties implicitly by indices. Although this strategy runs the risk of being \u201coverly clever\u201d programming, it has proven effective for two reasons. First, anything tracked explicitly and stored an array is a liability if that array is not updated properly\u2014conversely implicit relationships can be abstracted away behind helper functions, and need not be carefully maintained. Second, implicit relationships tend to lead fast implementations out of the box, avoiding performance hacking which runs a huge risk of breaking correctness.</p>"},{"location":"surface/surface_mesh/internals/#permutation-halfedge-mesh","title":"Permutation halfedge mesh","text":"<p>Here\u2019s a neat fact: a halfedge mesh can be represented by a single permutation of length <code>nHalfedges</code>. </p> <p>How? First, consider an enumeration of the halfedges. We can implicitly encode the <code>twin()</code> relationship by storing twinned halfedges adjacent to one another\u2013 that is, the twin of an even-numbered halfedge numbered <code>he</code> is <code>he+1</code>, and the twin of and odd-numbered halfedge is <code>he-1</code>. We then use the permutation to encode the <code>next()</code> relationships. The faces are the orbits of the <code>next()</code> operation, enumerated in the order they are encountered. The edges are the orbits of the <code>twin()</code> operation, which can be enumerated implicitly from the index. The vertices are the orbits of the <code>twin().next()</code> operation, again enumerated in the order they are encountered.</p> <p>This idea of a permutation is essentially the representation used for our halfedge mesh data structure: a single permutation array encodes the <code>next()</code> map, while the <code>twin()</code>, <code>edge()</code>, and <code>edge.halfedge()</code> maps are implicitly defined. However, although vertices and faces could be represented implicitly by an enumeration of orbits, doing so is inconvenient and expensive to update. Instead, we include additional arrays storing the <code>he.vertex()</code>, <code>he.face()</code>, <code>v.halfedge()</code> and <code>f.halfedge()</code> maps which are explicitly maintained.</p>"},{"location":"surface/surface_mesh/internals/#basic-structures","title":"Basic structures","text":"<p>Our halfedge mesh is index-based. Each {halfedge,edge,vertex,face} is identified by a 0-based index. The <code>SurfaceMesh</code> class then holds the following explicit arrays encoding the connectivity between these indexed elements (the remaining relationships are implicitly defined).</p> <pre><code>class SurfaceMesh {\n  ...\n  private:\n    std::vector&lt;size_t&gt; heNext;     // for he.next()\n    std::vector&lt;size_t&gt; heVertex;   // for he.vertex()\n    std::vector&lt;size_t&gt; heFace;     // for he.face()\n    std::vector&lt;size_t&gt; vHalfedge;  // for v.halfedge()\n    std::vector&lt;size_t&gt; fHalfedge;  // for f.face()\n  ...\n};\n</code></pre> <p>The <code>Halfedge</code>, <code>Vertex</code>, etc. classes serve as typed wrappers referring to a mesh element. These wrappers store the index of the underlying element, as well as pointer to the mesh object itself. Traversal operations like <code>he.next()</code> are either implemented implicitly via index arithmetic, or by lookup in to the appropriate array. <pre><code>class Halfedge {\n  ...\n  size_t ind;\n  SurfaceMesh* mesh;\n  Halfedge next() { return Halfedge{mesh-&gt;heNext[ind], mesh}; }   // explicit\n  Halfedge twin() { return Halfedge{ind ^ 1, mesh}; }             // implicit\n  ...\n};\n</code></pre></p> <p>Why not pointers?</p> <p>One potential drawback to the index-based design is that each element must store its index as well as a pointer to the underlying mesh data structure. For instance, the smallest possible data layout of <code>Halfedge</code> would look something like <code>struct Halfedge { size_t ind; SurfaceMesh* mesh; };</code>, because the <code>ind</code> is useless unless we know what arrays to index in to (e.g., to implement <code>next()</code>).</p> <p>This extra storage could be avoided by replacing <code>size_t ind</code> with a pointer directly to memory encoding data about the halfedge. This design would reduce the <code>sizeof(Halfedge)</code> from 16 bytes to 8, as well as potentially avoiding some offset index instructions. So why don\u2019t we do that instead?</p> <p>In fact, the first implementation of this library used exactly that pointer-based design. However, it turned out to have two main downsides:</p> <ul> <li>semantics of pointer invalidation: In C++, doing nearly anything with an invalid pointer incurs undefined behavior, and expanding our buffers invalidates pointers. This meant that an \u201cunder the hood\u201d resize event would invalidate all of the user\u2019s <code>Halfedge</code> objects, necessitating frequent expensive use of <code>DynamicHalfedge</code>, rather than just around <code>compress()</code> as in the current design.  </li> <li>implementation complexity: Working with raw pointers makes a lot of easy things hard. Significant pointer gymnastics were needed to internally implement resize operations without running afoul of invalid pointer rules. Simple operations like copying meshes and mesh data required pointer translation. Indexing in to a container essentially required a dense index from the element, so the codebase ended up littered with operations to construct indices from pointer offsets. The cumulative effect was quite error-prone.</li> </ul> <p>Ultimately, the index-based design seems preferrable.</p>"},{"location":"surface/surface_mesh/internals/#invariants","title":"Invariants","text":"<p>In addition to the basic properties of the <code>twin()</code> and <code>next()</code> maps, the halfedge mesh data structure offers a few useful invariants about its indexing scheme which must be maintained by all operations.</p> <ul> <li>on a boundary edge, <code>e.halfedge()</code> is the interior halfedge</li> <li>on a boundary vertex, <code>v.halfedge()</code> is the unique real interior halfedge along the boundary (so <code>v.halfedge().twin()</code> is necessarily exterior, and traversing in CCW order walks the wedge)</li> </ul> <p>The <code>validateConnectivity()</code> function is extremely useful for checking invariants while developing the data structure.</p> <code>void SurfaceMesh::validateConnectivity()</code> <p>Perform a lot of sanity checks about the halfedge mesh. Throws if any fail.</p>"},{"location":"surface/surface_mesh/internals/#resizing-and-deleting","title":"Resizing and deleting","text":"<p>To enable (amortized) \\mathcal{O}(1) mutation, the buffers containing mesh data are lazily reallocated like a <code>std::vector</code> when needed. As such the actual buffers like <code>mesh.heNext</code> might be larger than the current number of elements in the mesh; we separately track the count of real, valid elements to avoid accessing the extra regions of the array. The special index value <code>INVALID_IND</code> (which happens to be <code>std::numeric_limits&lt;size_t&gt;::max()</code>) is used to fill index values that have no meaning.</p> <p>A similar issue arises with deletion. When a mesh element is deleted, it would be too expensive to shift the indices of all subsequent elements. Instead, we simply mark the element as deleted, leaving a hole in our index space. Deleted halfedges and their edges are implicitly encoded by <code>heNext[he] == INVALID_IND</code>, while deleted edges and vertices are encoded by <code>vHalfedge[v] == INVALID_IND</code> and <code>fHalfedge[f] == INVALID_IND</code>.</p> <p>Thus at any point in time, some indices may be invalid elements, left from previous deletions, and other array entries might correspond to extra elements allocated during the last resizing, waiting to be used. In all iterators and counts, explicit logic ensures that invalid elements are skipped. Traversal functions do not need any such logic, as it should be impossible to traverse from a valid element to an invalid element. The <code>SurfaceMesh::compress()</code> function is provided to re-index all mesh elements, and ensure a dense packing with no deleted elements.</p> <p>The following diagram lays out what this index space might look like.</p> <p></p>"},{"location":"surface/surface_mesh/internals/#general-surface-meshes","title":"General Surface Meshes","text":"<p>To represent more general surfaces meshes which might be nonmanifold or oriented, we augment our representation with a few extra arrays of data. In particular, we depart from implicit indexing schemes, and explicitly store halfedge siblings and edges, as well as each edge\u2019s halfedge. We also store an orientation bit for each halfedge along its edge, and and in implicit linked list of halfedges incident on each vertex. The last of which is particularly unsatisfying, but otherwise iterating around vertices is quite difficult.</p>"},{"location":"surface/surface_mesh/internals/#exterior-boundary-elements","title":"Exterior boundary elements","text":"<p>(<code>ManifoldSurfaceMesh</code> only)</p> <p>One complexity in our implementation is the existence of exterior boundary elements. Recall that boundaries of our mesh are represented by filling each hole with a single, many-sided boundary loop; the halfedges incident on this face are \u201cexterior\u201d. This definition is convenient because it saves us from constantly special-casing elements on the boundary, but introduces some complexity because the user probably doesn\u2019t want to think about these boundary loops as faces most of the time.</p> <p>Exterior halfedges are enumerated alongside their interior counterparts, and generally are treated just like normal interior halfedges; most routines do not distinguish between the two.</p> <p>In contrast, although boundary loops are just faces internally, the API provides the illusion that they are a distinct type from the faces of the mesh. To enable this treatment, boundary loops are always stored at the back of the face index space. In general, the layout of the allocated index space will consist of first actual mesh faces, then any extra not-yet-used space, and finally boundary loops. </p>"},{"location":"surface/surface_mesh/internals/#resize-callbacks","title":"Resize callbacks","text":"<p>As the halfedge mesh is mutated, all <code>MeshData&lt;&gt;</code> containers automatically resize to stay in sync. This is implemented under the hood with a system of callback functions registered with the mesh itself. Whenever the mesh resizes or compresses one of its index spaces, it invokes a callback for each associated <code>MeshData&lt;&gt;</code> to do the same.</p> <p><code>DynamicHalfedge</code> and friends also register themselves with the callback system, to stay valid as the mesh resizes. However, this results in a callback per dynamic element, which is why the dynamic elements are more expensive. Fortunately, dynamic elements can be used sparingly.</p>"},{"location":"surface/surface_mesh/mutation/","title":"Mutation","text":"<p>These routines allow modification of the mesh connectivity and insertion/deletion of elements.</p> <p>Geometry-central is designed from the ground up to have good support for mesh mutation. The underlying <code>SurfaceMesh</code> data structure is index-based, with lazy expansion and deletion, so all operations run in (amortized) constant time with respect to the number of mesh elements, and usually do not incur any memory allocations. Containers automatically update after mesh operations.</p> <p>As much as possible, these routines will check for validity before executing and throw an exception if something isn\u2019t right. The <code>NGC_SAFETY_CHECKS</code> define disables this behavior for a modest increase in performance, but checks are enabled by default even in release builds.</p> <p>Note that aggressive use of these routines may reduce a mesh from a simplicial complex to a \\Delta-complex. For instance, flipping enough edges in a mesh might create self-edges, which connect a vertex to itself. See the \\Delta\\Delta-complex section for details, and an explanation of why these complexes are important.</p> <p>General <code>SurfaceMesh</code></p> <p>Many of these operations could be defined for a general <code>SurfaceMesh</code>, but are currently only implemented on the <code>ManifoldSurfaceMesh</code>. Future releases of geometry-central will gradually port them over.</p>"},{"location":"surface/surface_mesh/mutation/#compressed-mode","title":"Compressed mode","text":"<p>Internally, the halfedge mesh is represented by dense arrays of indices which are lazily expanded (see interals for details). To support fast deletion operations, we simply mark elements as deleted, without re-packing the index space. We say that the mesh is compressed if the index space is dense, with no such marked elements. When a mesh is not compressed, the <code>index</code> of a mesh element no longer serves as a proper enumeration from <code>[0,N)</code>, but merely as a unique ID.</p> <p>There are two consequences to being non-compressed:</p> <ul> <li>Some operations cannot be implemented efficiently/correctly (e.g., random access of the i\u2019th vertex), as noted in the documentation. Calling such function will generally throw an error in Debug mode, but may fail silently in Release.</li> <li>Storage space is wasted by deleted elements.</li> </ul> <p>All meshes are compressed after construction, and only become non-compressed if the user performs an insertion or deletion operation. The <code>compress()</code> function can be called to re-index the elements of the mesh as a proper enumeration from <code>[0,N)</code>.</p> <p>The <code>compress()</code> function invalidates pointers, and incurs an update of existing containers. As such, it is recommended to be called sporadically, after a sequence of operations is completed.</p> <code>bool SurfaceMesh::isCompressed()</code> <p>Returns true if the mesh is compressed.</p> <code>void SurfaceMesh::compress()</code> <p>Re-index the elements of the mesh to yield a dense enumeration. Invalidates all <code>Vertex</code>, <code>Edge</code> (etc) objects. All <code>VertexData&lt;&gt;</code>, <code>FaceData&lt;&gt;</code>, etc containers are automatically resized and re-indexed.</p> <p>Does nothing if the mesh is already compressed.</p> <p>Preserving notable elements</p> <p>In some rare situations, you might want to manually keep track of a significant mesh elements (vertices, faces, etc) through a call to <code>compress()</code> (which invalidates all element references).</p> <p>One way to do this is to leverage the <code>MeshData&lt;&gt;</code> containers, which automatically stay valid through updates:</p> <pre><code>SurfaceMesh&amp; mesh; // our mesh\nVertex vA, vB; // two special vertices we want to keep track of\n\n// Label the special vertices\nVertexData&lt;int&gt; specialVerts(mesh, 0);\nspecialVerts[vA] = 1;\nspecialVerts[vB] = 2;\n\n// Compress the mesh\n// (invalidating the Vertex objects)\nmesh.compress();   // specialVerts is automatically maintained through the compression\n\n// Find the interesting vertices by label\nfor(Vertex v : mesh.vertices()) {\nif(specialVerts[v] == 1) vA = v;\nif(specialVerts[v] == 2) vB = v;\n}\n</code></pre> <p>This is an intentionally simplistic example, but generally speaking the <code>MeshData&lt;&gt;</code> arrays can be used to track mesh elements and other data through a <code>compress()</code>.</p>"},{"location":"surface/surface_mesh/mutation/#in-place-modifications","title":"In-place modifications","text":"<p>These routines modify a mesh, but do not require inserting or deleting elements.</p> <code>bool SurfaceMesh::flip(Edge e, bool preventSelfEdges = true)</code> <p>Flip an edge by rotating counter-clockwise.</p> <p>An edge cannot be combinatorially flipped if it is:</p> <ul> <li>a boundary edge</li> <li>incident on a degree-1 vertex.</li> </ul> <p>If <code>true</code> is passed as the optional argument <code>preventSelfEdges</code>, then the edge will also not be flipped if it would result in both endpoints of the edge becoming the same vertex. </p> <p>Return: true if the edge was actually flipped </p>"},{"location":"surface/surface_mesh/mutation/#insertions","title":"Insertions","text":"<p>These routines modify a mesh by inserting new elements. Elements (like <code>Vertex</code>) and containers (like <code>VertexData&lt;&gt;</code>) will remain valid through insertions and automatically resize themselves to accommodate the new elements. However, the mesh will no longer be compressed.</p> <p>Note that some operations my re-use existing elements to create their output. For instance, <code>splitEdge()</code> turns a single edge in to two; the input edge will be re-used as one of the two output edges, and data along that edge will be unchanged in any containers.</p> <code>Halfedge ManifoldSurfaceMesh::insertVertexAlongEdge(Edge e)</code> <p>Adds a degree 2 vertex along an edge. Unlike <code>splitEdge()</code>, this does not triangulate the adjacent faces; the degree of adjacent faces will be increased by 1. Works as expected on boundary edges.</p> <p>Returns a halfedge <code>he</code> along the newly created edge, which points in the same direction as <code>e.halfedge()</code>, and such that <code>he.vertex()</code> is the newly inserted vertex.</p> <p>Preserves canonical direction of edge.halfedge() for both halves of new edge. The original edge is repurposed as one of the two new edges (same for original halfedges).</p> <code>Halfedge ManifoldSurfaceMesh::splitEdgeTriangular(Edge e)</code> <p>Inserts a vertex along an edge, and triangulates the adjacent faces. On a triangle mesh, the newly inserted vertex will be a degree 4 vertex.  Works as expected on boundary edges.</p> <p>Returns a halfedge <code>he</code> along the newly created edge, which points in the same direction as <code>e.halfedge()</code>, and such that <code>he.vertex()</code> is the newly inserted vertex.</p> <p>Preserves canonical direction of edge.halfedge() for both halves of new edge. The original edge is repurposed as one of the new edges (same for original halfedges).</p> <code>Vertex ManifoldSurfaceMesh::insertVertex(Face f)</code> <p>Add vertex inside face and triangulate. Returns new vertex.</p> <code>Halfedge connectVertices(Halfedge heA, Halfedge heB)</code> <p>Call to add an edge to a face, splitting it to two faces.</p> <p>Creates a new edge connecting <code>heA.vertex()</code> to <code>heB.vertex()</code>. The initial shared face will be repurposed as one of the two resulting faces.</p> <p><code>heA</code> and <code>heB</code> must be distinct halfedges in the same face, and their vertices must not already be adjacent in that face.</p> <p>Returns new halfedge with <code>heA.vertex()</code> at tail, and <code>he.twin().face()</code> is the new face.</p> <code>std::vector&lt;Face&gt; ManifoldSurfaceMesh::triangulate(Face face)</code> <p>Triangulate a face in the mesh, returning all of the resulting faces.</p> <p>One of the returned faces will be the input face, repurposed as a face in the triangulation.</p>"},{"location":"surface/surface_mesh/mutation/#deletions","title":"Deletions","text":"<p>These routines delete mesh elements. Elements (like <code>Vertex</code>) and containers (like <code>VertexData&lt;&gt;</code>) will remain valid through deletions. However, performing any deletion will cause the mesh to no longer be compressed.</p> <code>Vertex ManifoldSurfaceMesh::collapseEdgeTriangular(Edge e)</code> <p>Collapse an edge. Returns the vertex adjacent to that edge which still exists. Returns Vertex() if not collapsible.</p> <code>bool ManifoldSurfaceMesh::removeFaceAlongBoundary(Face f)</code> <p>Remove a face which is adjacent to the boundary of the mesh (along with its edge on the boundary). Face must have exactly one boundary edge. Returns true if could remove.</p>"},{"location":"surface/surface_mesh/navigation/","title":"Navigation and Iteration","text":""},{"location":"surface/surface_mesh/navigation/#collection-iterators","title":"Collection Iterators","text":"<p>Use these routines to iterate over all of the elements in the mesh.</p> <p>Note: Generally, modifying the mesh while iterating is allowed, but the new elements may or may not be iterated over, and previous elements might even appear again later later in the iteration after modifying.</p> <code>SurfaceMesh::vertices()</code> <p>Iterate over the vertices in a mesh. <pre><code>for(Vertex v : mesh.vertices()) {\n// do science here\n}\n</code></pre></p> <code>SurfaceMesh::halfedges()</code> <p>Iterate over all of the halfedges in a mesh (both interior and exterior, if the mesh has boundary). <pre><code>for(Halfedge he : mesh.halfedges()) {\n// do science here\n}\n</code></pre></p> <code>SurfaceMesh::interiorHalfedges()</code> <p>Iterate over the interior halfedges in a mesh. <pre><code>for(Halfedge he : mesh.interiorHalfedges()) {\n// do science here\n}\n</code></pre> Note that on a boundary edge between vertices <code>i &lt;--&gt; j</code>, this set will only include a halfedge from <code>i --&gt; j</code>, but not from <code>j --&gt; i</code> (or vice versa).</p> <code>SurfaceMesh::exteriorHalfedges()</code> <p>Iterate over the exterior halfedges in a mesh. (only useful on <code>ManifoldSurfaceMesh</code>) <pre><code>for(Halfedge he : mesh.exteriorHalfedges()) {\n// do science here\n}\n</code></pre> Note that on a boundary edge between vertices <code>i &lt;--&gt; j</code>, this set will only include a halfedge from <code>i --&gt; j</code>, but not from <code>j --&gt; i</code> (or vice versa).</p> <code>SurfaceMesh::edges()</code> <p>Iterate over the edges in a mesh. <pre><code>for(Edge e : mesh.edges()) {\n// do science here\n}\n</code></pre></p> <code>SurfaceMesh::faces()</code> <p>Iterate over the faces in a mesh. <pre><code>for(Face f : mesh.faces()) {\n// do science here\n}\n</code></pre></p> <code>SurfaceMesh::boundaryLoops()</code> <p>Iterate over the boundary loops for a mesh.</p> <p>Remember that only <code>ManifoldSurfaceMesh</code>s have well-defined boundary loops.</p> <pre><code>for(BoundaryLoop bl : mesh.boundaryLoops()) {\n// do science here\n}\n</code></pre>"},{"location":"surface/surface_mesh/navigation/#neighborhood-iterators","title":"Neighborhood Iterators","text":"<p>Use these routines to iterate over the neighbors of a mesh element.</p> Note: neighborhoods on \\Delta-complexes <p>The iterators in this section may have unexpected behavior in the advanced case of a \\Delta\\Delta-complex, when there are (e.g.) self-edges, or multiple edges between a pair of vertices. Essentially, these iterators always naively traverse the local neighborhood, even if that neighborhood might include duplicate elements. </p> <p>For instance, if a \\Delta\\Delta-complex has multiple edges connecting vertex <code>va</code> to vertex <code>vb</code>, then iterating <code>va.adjacentVertices()</code> will return <code>vb</code> multiple times.</p> <p>Of course, for ordinary triangle mesh they will behave as expected. See the Delta complex section for more information.</p>"},{"location":"surface/surface_mesh/navigation/#around-a-vertex","title":"Around a vertex","text":"<code>Vertex::outgoingHalfedges()</code> <p>Iterate over the halfedges which point outward from a vertex. <pre><code>for(Halfedge he : vert.outgoingHalfedges()) {\nassert(he.vertex() == vert); // true\n// do science here\n}\n</code></pre></p> <code>Vertex::incomingHalfedges()</code> <p>Iterate over the halfedges which point inward at a vertex. <pre><code>for(Halfedge he : vert.incomingHalfedges()) {\nassert(he.twin().vertex() == vert); // true\n// do science here\n}\n</code></pre></p> <code>Vertex::adjacentVertices()</code> <p>Iterate over the vertices edge-connected to this vertex. <pre><code>for(Vertex v : vert.adjacentVertices()) {\n// do science here\n}\n</code></pre></p> <code>Vertex::adjacentEdges()</code> <p>Iterate over the edges incident on this vertex. <pre><code>for(Edge e : vert.adjacentEdges()) {\n// do science here\n}\n</code></pre></p> <code>Vertex::adjacentFaces()</code> <p>Iterate over the faces incident on this vertex. <pre><code>for(Face f : vert.adjacentFaces()) {\n// do science here\n}\n</code></pre></p>"},{"location":"surface/surface_mesh/navigation/#around-an-edge","title":"Around an edge","text":"<code>Edge::adjacentHalfedges()</code> <p>Iterate over the halfedges incident on this edge. <pre><code>for(Halfedge he : edge.adjacentHalfedges()) {\n// do science here\n}\n</code></pre></p> <code>Edge::adjacentFaces()</code> <p>Iterate over the (one or two) faces incident on this edge. <pre><code>for(Face f : edge.adjacentFaces()) {\n// do science here\n}\n</code></pre></p> <code>Edge::adjacentVertices()</code> <p>Iterate over the (two) vertices which are endpoints of the edge. <pre><code>for (Vertex v : edge.adjacentVertices()) {\n// do science here\n}\n</code></pre></p> <p>Note: unlike most navigators, this routine actually returns a fixed-size array, so you can alternately write things like: <pre><code>std::array&lt;Vertex, 2&gt; verts = edge.adjacentVertices();\n</code></pre></p> <code>Edge::diamondBoundary()</code> <p>Iterate over the four halfedges bounding the diamond with this edge as its center diagonal.</p> <p>More precisely, for an interior edge on a manifold triangle mesh, this returns <pre><code>Halfedge he = edge.halfedge();\nreturn {he.next(), he.next().next(), he.twin().next(), he.twin().next().next()}\n</code></pre></p> <p>Example: <pre><code>for (Halfedge he : edge.diamondBoundary()) {\n// do science here\n}\n</code></pre></p> <p>Throws an exception if there are non-triangular faces, the edge is on the boundary, or if the edge is nonmanifold.</p> <p>Note: unlike most navigators, this routine actually returns a fixed-size array, so you can alternately write things like: <pre><code>std::array&lt;Halfedge, 4&gt; halfedges = edge.diamondBoundary();\n</code></pre></p>"},{"location":"surface/surface_mesh/navigation/#around-a-face","title":"Around a face","text":"<code>Face::adjacentVertices()</code> <p>Iterate over the vertices adjacent to a face. <pre><code>for(Vertex v : face.adjacentVertices()) {\n// do science here\n}\n</code></pre></p> <code>Face::adjacentHalfedges()</code> <p>Iterate over the halfedges incident on a face. <pre><code>for(Halfedge he : face.adjacentHalfedges()) {\n// do science here\n}\n</code></pre></p> <code>Face::adjacentEdges()</code> <p>Iterate over the edges on the boundary of a face. <pre><code>for(Edge e : face.adjacentEdges()) {\n// do science here\n}\n</code></pre></p> <code>Face::adjacentFaces()</code> <p>Iterate over the faces adjacent to a face, across each edge. <pre><code>for(Face f : face.adjacentFaces()) {\n// do science here\n}\n</code></pre></p>"},{"location":"surface/surface_mesh/navigation/#around-a-boundary-loop","title":"Around a boundary loop","text":"<code>BoundaryLoop::adjacentVertices()</code> <p>Iterate over the vertices adjacent to a boundary loop. <pre><code>for(Vertex v : boundaryLoop.adjacentVertices()) {\n// do science here\n}\n</code></pre></p> <code>BoundaryLoop::adjacentHalfedges()</code> <p>Iterate over the (exterior) halfedges incident on a boundary loop. <pre><code>for(Halfedge he : boundaryLoop.adjacentHalfedges()) {\n// do science here\n}\n</code></pre></p> <code>BoundaryLoop::adjacentEdges()</code> <p>Iterate over the edges on the boundary of a boundary loop. <pre><code>for(Edge e : boundaryLoop.adjacentEdges()) {\n// do science here\n}\n</code></pre></p>"},{"location":"surface/surface_mesh/navigation/#accessors","title":"Accessors","text":"<p>Use these routines to access elements of the mesh by their index.</p> <p>Warning</p> <p>The indexing routines in the section are only valid when the mesh is compressed.</p> <code>Halfedge SurfaceMesh::halfedge(size_t index)</code> <p>Constructs a reference to the i\u2019th halfedge in the mesh. <code>0 &lt;= index &lt; nHalfedges()</code>.</p> <code>Vertex SurfaceMesh::vertex(size_t index)</code> <p>Constructs a reference to the i\u2019th vertex in the mesh. <code>0 &lt;= index &lt; nVertices()</code>.</p> <code>Face SurfaceMesh::face(size_t index)</code> <p>Constructs a reference to the i\u2019th face in the mesh. <code>0 &lt;= index &lt; nFaces()</code>.</p> <code>Edge SurfaceMesh::edge(size_t index)</code> <p>Constructs a reference to the i\u2019th edge in the mesh. <code>0 &lt;= index &lt; nEdges()</code>.</p> <code>Face SurfaceMesh::face(size_t index)</code> <p>Constructs a reference to the i\u2019th face in the mesh. <code>0 &lt;= index &lt; nFaces()</code>.</p> <code>Face SurfaceMesh::boundaryLoop(size_t index)</code> <p>Constructs a reference to the i\u2019th boundary loop in the mesh. <code>0 &lt;= index &lt; nBoundaryLoops()</code>.</p>"},{"location":"surface/utilities/barycentric_vector/","title":"Barycentric Vector","text":"<p>A <code>BarycentricVector</code> is a vector that lies along a surface. This vector can lie within a face, along an edge, or at a single vertex (in which case it is simply a zero vector.) Barycentric vectors represent the difference between two barycentric points on the surface, hence their coordinates always sum to 0. (Barycentric points are implemented as SurfacePoint in geometry-central.) Currently, barycentric points and vectors are only supported on triangle meshes.</p> <p></p> <p>Although a barycentric vector can be constructed as the difference of two barycentric points, a barycentric vector technically does not define a single unique vector along the surface but rather a constant vector field within a face.</p> <p>Using barycentric vectors, one can easily do vector arithmetic on a surface. Barycentric vectors are especially useful when working with an intrinsic representation of a surface; they can be used to do computations on vectors that depend only on intrinsic geometry, such as inner products.</p> <p><code>#include \"geometrycentral/surface/barycentric_vector.h\"</code></p> <p>The field <code>BarycentricVector::type</code> is an enum: <pre><code>enum class BarycentricVectorType { Face = 0, Edge, Vertex };\n</code></pre></p> <p>which indicates what kind of vector it is.</p> <ul> <li> <p>If the barycentric vector is inside a face, the field <code>BarycentricVector::face</code> indicates which face. Otherwise it is the null default face. The field <code>BarycentricVector::faceCoords</code> stores the coordinates of the vector, expressed in barycentric coordinates of the face. If one thinks of a barycentric vector as being the difference of two barycentric points, the order of the vector coordinates can be thought of as corresponding to the usual iteration order of vertices about the face. More technically, the vector coordinates represent vectors in the tangent plane of the standard triangle (see Section 2.3 of these notes.)</p> </li> <li> <p>If the barycentric vector is along an edge, the field <code>BarycentricVector::edge</code> indicates which edge. Otherwise it is the null default edge. The field <code>BarycentricVector::edgeCoords</code> stores the coordinates of the vector, expressed in barycentric coordinates of the edge (ordered according to the usual order of vertices on the edge, i.e. the first component corresponds to <code>edge.halfedge().vertex() == edge.firstVertex()</code>.)</p> </li> <li> <p>If the barycentric vector is on a vertex, the field <code>BarycentricVector::vertex</code> indicates which vertex. Otherwise it is the null default vertex. There are no corresponding coordinates, since a vector on a vertex is always considered to have zero length.</p> </li> </ul>"},{"location":"surface/utilities/barycentric_vector/#construction","title":"Construction","text":"<code>BarycentricVector::BarycentricVector(Face f, Vector3 faceCoords)</code> <p>Construct a barycentric vector that lies along the given face <code>f</code>, with the given barycentric coordinates <code>faceCoords</code>.</p> <code>BarycentricVector::BarycentricVector(Edge e, Vector2 edgeCoords)</code> <p>Construct a barycentric vector that lies along the given edge <code>e</code>, with the given barycentric coordinates <code>edgeCoords</code>.</p> <code>BarycentricVector::BarycentricVector(Vertex v)</code> <p>Construct a (zero-length) barycentric vector that lies on the given vertex <code>v</code>.</p> <code>BarycentricVector::BarycentricVector(SurfacePoint pA, SurfacePoint pB)</code> <p>Construct a barycentric vector from the given surface points, i.e. barycentric points. The vector direction goes from <code>pA</code> to <code>pB</code>.</p> <p>Note that there do not exist unique barycentric endpoints for a given barycentric vector, except for the degenerate case of a vertex-type vector where both endpoints are the vertex itself. Perhaps a more straightforward way to say this is that barycentric vectors really are vectors (displacements), not rays.</p>"},{"location":"surface/utilities/barycentric_vector/#arithmetic","title":"Arithmetic","text":"<p>Barycentric vectors support addition, subtraction, scalar multiplication, and scalar division.</p>"},{"location":"surface/utilities/barycentric_vector/#member-operations","title":"Member operations","text":"<code>double BarycentricVector::norm(IntrinsicGeometryInterface&amp; geom) const</code> <p>Returns the norm (length) of the vector. Because the norm depends on the geometry, you must pass in the geometry (either intrinsic or extrinsic) on which the vector is defined.</p> <code>double BarycentricVector::norm2(IntrinsicGeometryInterface&amp; geom) const</code> <p>Returns the squared norm of the vector. Because the norm depends on the geometry, you must pass in the geometry (either intrinsic or extrinsic) on which the vector is defined.</p> <code>BarycentricVector BarycentricVector::rotated90(IntrinsicGeometryInterface&amp; geom) const</code> <p>Rotate the vector 90 degrees counter-clockwise within the face it belongs to. This requires the geometry, since the meaning of \u201c90 degrees\u201d depends on the geometry of the triangle.</p> <p>Barycentric vectors also have a few utility functions:</p> <code>BarycentricVector BarycentricVector::BarycentricVector inSomeFace() const</code> <p>All barycentric vectors (vertex, edge, face) have an equivalent vector in one or many adjacent faces. This function reeturns one of the equivalent barycentric vectors in a face (chosen arbitrarily). If the vector is already a face vector, the output is a copy of the vector.</p> <code>BarycentricVector BarycentricVector::BarycentricVector inFace(Face f) const</code> <p>Returns the barycentric vector as a face vector in face <code>f</code>. If the vector is not on or adjacent to the requested face, throws an error.</p> <code>BarycentricVector BarycentricVector::BarycentricVector inEdge(Edge e) const</code> <p>Returns the barycentric vector as an edge-type vector in edge <code>e</code>. If the vector is already an edge vector, the output is a copy of the vector. If the the barycentric vector is not on <code>e</code> or one of its adjacent vertices, throws an error.</p>"},{"location":"surface/utilities/barycentric_vector/#function-operations","title":"Function operations","text":"<code>double norm(IntrinsicGeometryInterface&amp; geom, const BarycentricVector&amp; v)</code> <p>Returns the norm of the input vector <code>v</code>.</p> <p>Also available as <code>vec.norm()</code>.</p> <code>double norm2(IntrinsicGeometryInterface&amp; geom, const BarycentricVector&amp; v)</code> <p>Returns the squared norm of the input vector <code>v</code>.</p> <p>Also available as <code>vec.norm2()</code>.</p> <code>double dot(IntrinsicGeometryInterface&amp; geom, const BarycentricVector&amp; u, const BarycentricVector&amp; v)</code> <p>Returns the inner product between <code>u</code> and <code>v</code>.</p> <code>Face sharedFace(const BarycentricVector&amp; u, const BarycentricVector&amp; v)</code> <p>Returns an arbitrary face shared by the two vectors <code>u</code> and <code>v</code>, if one exists; returns the null default face if none.</p> <code>Edge sharedEdge(const BarycentricVector&amp; u, const BarycentricVector&amp; v)</code> <p>Returns the edge shared by the two vectors <code>u</code> and <code>v</code>, if one exists; return the null default edge if none.</p>"},{"location":"surface/utilities/io/","title":"I/O","text":"<p><code>#include \"geometrycentral/surface/meshio.h\"</code></p>"},{"location":"surface/utilities/io/#reading-meshes","title":"Reading meshes","text":"<p>Construct a surface mesh from a file on disk, or more generally any <code>std::istream</code>.</p> <pre><code>#include \"geometrycentral/surface/meshio.h\"\nusing namespace geometrycentral::surface;\n\n// Load a surface mesh which is required to be manifold\nstd::unique_ptr&lt;ManifoldSurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readManifoldSurfaceMesh(\"spot.obj\"); // Load a more general surface mesh, which might be nonmanifold\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh2;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry2;\nstd::tie(mesh2, geometry2) = readSurfaceMesh(\"spot_messy.obj\"); </code></pre> Why use <code>std::unique_ptr&lt;&gt;</code>? <p>The mesh loader, like many functions in geometry-central, returns constructed objects via a <code>unique_ptr</code>. Unique pointers are an important tool for memory management in modern C++; if you haven\u2019t used them before, we suggest you give them a try!</p> <p>In most ways, a <code>unique_ptr</code> acts just like a normal C++ pointer. You can dereference it with <code>*uPtr</code>, and access its members and function like <code>uPtr-&gt;function()</code>. However, the <code>unique_ptr</code> helps prevent common memory-management mistakes, and communicates the programmer\u2019s intent about object lifetime. This is accomplished with two properties:</p> <ul> <li> <p>You don\u2019t need to call <code>delete</code> on a <code>unique_ptr</code>, it happens automatically when the pointer is destructed, e.g. when it goes out of scope at the end of a function, or when the object it is a member of gets deleted. This helps prevent memory leaks where you forget to deallocate the object.</p> </li> <li> <p>You cannot copy the <code>unique_ptr</code>; hence it is \u201cunique\u201d! You can still pass around references, or <code>std::move()</code> the pointer, which are sufficient for most reasonable uses. This helps prevent you from creating a copy, and then accidentally deleting the pointer twice.</p> </li> </ul> <p>The general paradigm in geometry-central (and a recommended style in modern C++) is to return long-lived, allocated objects with a <code>unique_ptr</code>, and pass these objects in to functions and dependent classes by reference.</p> <p>For instance, we might write a function which takes a mesh as an argument like</p> <pre><code>void processMesh(SurfaceMesh&amp; inputMesh) { /* do stuff */}\n</code></pre> <p>and call it by dereferencing the unique pointer to pass a reference</p> <pre><code>std::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readSurfaceMesh(\"spot.obj\"); processMesh(*mesh);\n</code></pre> <p>For more details about unique pointers, see the language documentation, or many tutorials around the web.</p> <p>If you really don\u2019t want to use unique pointers, you can simply release the unique pointer to an ordinary pointer:</p> <pre><code>std::unique_ptr&lt;SurfaceMesh&gt; mesh /* populated as above */;\nSurfaceMesh* meshPtr = mesh.release();\n</code></pre> <p>The <code>meshPtr</code> now points the mesh object, and you are responsible for eventually deleting this pointer. After calling <code>release()</code>, the unique pointer points to nothing and will no longer deallocate the object.</p> <code>std::tuple&lt;std::unique_ptr&lt;SurfaceMesh&gt;, std::unique_ptr&lt;VertexPositionGeometry&gt;&gt; readSurfaceMesh(std::string filename, std::string type = \"\")</code> <p>Load a general, not-necessarily-manifold mesh from file. Returns both a <code>SurfaceMesh</code> representing the connectivity, and a <code>Geometry</code> representing the geometry. See the example above to concisely unpack.</p> <p>If the file includes vertices which do not appear in any face, they will be stripped from the vertex listing and ignored.</p> <p>The <code>type</code> parameter determines the type of file to load. For example, <code>type=\"ply\"</code> will attempt to read the target file as a .ply file. If no type is given, the type will be inferred from the file extension. </p> <p>See the matrix below for all supported file types.</p> <code>std::tuple&lt;std::unique_ptr&lt;SurfaceMesh&gt;, std::unique_ptr&lt;VertexPositionGeometry&gt;&gt; readSurfaceMesh(std::istream&amp; in, std::string type)</code> <p>Same as above, but reads from a general <code>istream</code> object rather than a filename. </p> <p>When reading from a stream, the type must be specified and cannot be automatically inferred.</p> <code>std::tuple&lt;std::unique_ptr&lt;ManifoldSurfaceMesh&gt;, std::unique_ptr&lt;VertexPositionGeometry&gt;&gt; readManifoldSurfaceMesh(std::string filename, std::string type = \"\")</code> <p>Load a manifold mesh from file. Returns both a <code>ManifoldSurfaceMesh</code> representing the connectivity, and a <code>Geometry</code> representing the geometry. See the example above to concisely unpack. If the mesh to be loaded is not manifold, an exception will be thrown.</p> <p>If the file includes vertices which do not appear in any face, they will be stripped from the vertex listing and ignored.</p> <p>The <code>type</code> parameter determines the type of file to load. For example, <code>type=\"ply\"</code> will attempt to read the target file as a .ply file. If no type is given, the type will be inferred from the file extension. </p> <p>See the matrix below for all supported file types.</p> <code>std::tuple&lt;std::unique_ptr&lt;ManifoldSurfaceMesh&gt;, std::unique_ptr&lt;VertexPositionGeometry&gt;&gt; readManifoldSurfaceMesh(std::istream&amp; in, std::string type)</code> <p>Same as above, but reads from a general <code>istream</code> object rather than a filename. </p> <p>When reading from a stream, the type must be specified and cannot be automatically inferred.</p> <code>std::tuple&lt;std::unique_ptr&lt;ManifoldSurfaceMesh&gt;, std::unique_ptr&lt;VertexPositionGeometry&gt;, std::unique_ptr&lt;CornerData&lt;Vector2&gt;&gt;&gt; readParameterizedManifoldSurfaceMesh(std::string filename, std::string type=\"\")</code> <p>Loads a manifold surface mesh plus UV (texture) coordinates from a file.  See other variants for details.</p> <p>Currently only OBJ files are supported.</p> <code>std::tuple&lt;std::unique_ptr&lt;SurfaceMesh&gt;, std::unique_ptr&lt;VertexPositionGeometry&gt;, std::unique_ptr&lt;CornerData&lt;Vector2&gt;&gt;&gt; readParameterizedSurfaceMesh(std::string filename, std::string type=\"\")</code> <p>Loads a general surface mesh plus UV (texture) coordinates from a file.  See other variants for details.</p> <p>Currently only OBJ files are supported.</p>"},{"location":"surface/utilities/io/#writing-meshes","title":"Writing meshes","text":"<p>Write a mesh to file, or more generally any <code>std::ostream</code>. </p> <pre><code>#include \"geometrycentral/surface/meshio.h\"\nusing namespace geometrycentral::surface;\n\n// Write a surface mesh\n// Recall that ManifoldSurfaceMesh is a subclass of SurfaceMesh, so\n// it can be used just the same\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nwriteSurfaceMesh(*mesh, *geometry, \"my_mesh.obj\"); </code></pre> <code>void writeSurfaceMesh(SurfaceMesh&amp; mesh, EmbeddedGeometryInterface&amp; geometry, std::string filename, std::string type = \"\")</code> <p>Write a mesh to file. </p> <p>The <code>type</code> parameter determines the type of file to write. For example, <code>type=\"obj\"</code> will write the target file as a .obj file. If no type is given, the type will be inferred from the file extension. </p> <p>See the matrix below for all supported file types.</p> <code>void writeSurfaceMesh(SurfaceMesh&amp; mesh, EmbeddedGeometryInterface&amp; geometry, CornerData&lt;Vector2&gt;&amp; texCoords, std::string filename, std::string type = \"\")</code> <p>Write a mesh to file as above, except corner per-corner coordinates are also written, if supported by the file format.</p> <code>void writeSurfaceMesh(SurfaceMesh&amp; mesh, EmbeddedGeometryInterface&amp; geometry, std::ostream&amp; out, std::string type)</code> <p>Write a mesh to file as above, to a general <code>std::ostream</code> rather than directly to a named file.</p> <p>When writing to a stream, the type must be specified and cannot be automatically inferred.</p> <code>void writeSurfaceMesh(SurfaceMesh&amp; mesh, EmbeddedGeometryInterface&amp; geometry, CornerData&lt;Vector2&gt;&amp; texCoords, std::ostream&amp; out, std::string type)</code> <p>Write a mesh to file as above, to a general <code>std::ostream</code> and with the specified texture coordinates, if the file format supports it.</p> <p>When writing to a stream, the type must be specified and cannot be automatically inferred.</p>"},{"location":"surface/utilities/io/#packing-scalar-data","title":"Packing scalar data","text":"<p>A handy trick for transferring data between programs (e.g., to create visualizations) is to pack scalar data in to texture coordinates when writing a mesh to file. To make this easier, the helper <code>packToParam()</code> stores data as corner coordinates which can be passed to the writers.</p> <pre><code>#include \"geometrycentral/surface/meshio.h\"\nusing namespace geometrycentral::surface;\n\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh; // some mesh\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry; // some geometry\nVertexData&lt;double&gt; vals; // some values at vertices\n\nwriteSurfaceMesh(*mesh, *geometry, packToParam(*mesh, vals), \"my_mesh.obj\"); </code></pre> <code>CornerData&lt;Vector2&gt; packToParam(SurfaceMesh&amp; mesh, VertexData&lt;double&gt;&amp; vals)</code> <p>Create a <code>CornerData</code> with the value from <code>vals</code> stored in the first coordinate at each corner. The second coordinate will hold <code>0</code>s.</p> <code>CornerData&lt;Vector2&gt; packToParam(SurfaceMesh&amp; mesh, VertexData&lt;double&gt;&amp; valsX, VertexData&lt;double&gt;&amp; valsY)</code> <p>Create a <code>CornerData</code> with the value from <code>valsX</code> stored in the first coordinate at each corner, and <code>valsY</code> stored in the second coordinate.</p>"},{"location":"surface/utilities/io/#supported-file-types","title":"Supported file types","text":"key reading writing tex coords notes <code>obj</code> \u2705 \u2705 \u2705 <code>ply</code> \u2705 <code>off</code> \u2705 <code>stl</code> \u2705 Exactly colocated vertices are automatically merged"},{"location":"surface/utilities/io/#rich-surface-mesh-data","title":"Rich Surface Mesh Data","text":"<p>The <code>RichSurfaceMeshData</code> offers advanced IO which interoperates directly with the geometry-central mesh data structures. In particular, it has two useful features:</p> <ul> <li>Data stored in <code>MeshData&lt;&gt;</code> containers (<code>VertexData&lt;&gt;</code>, <code>EdgeData&lt;&gt;</code>, etc.) can be automatically written to and read from file</li> <li>The internal representation used by <code>SurfaceMesh</code> is directly written to file, improving performance and supporting meshes which cannot be represented as face index lists.</li> </ul> <p>The written files can hold mesh\u2019s connectivity, associated geometry and/or any number of properties. These files can be used to load/save a whole mesh from file, or to load/save individual properties associated with some existing mesh.</p> <p>Internally, data is stored as additional custom fields of a <code>.ply</code> file.  Here, we\u2019re using the <code>.ply</code> format as a general container for structured data\u2014other software will not automatically understand the additional fields in these files.  A benefit of the <code>ply</code> format is that data can be written in both efficient binary or plaintext ascii formats\u2014the default is binary.  The <code>RichSurfaceMeshData</code> class is used to read and write these souped-up <code>.ply</code> files, and is distinct from the simple mesh-loading <code>.ply</code> interface above. </p> <p><code>#include \"geometrycentral/surface/rich_surface_mesh_data.h\"</code></p> <p>Example: loading and saving data on a surface</p> <pre><code>#include \"geometrycentral/surface/rich_surface_mesh_data.h\"\nusing namespace geometrycentral::surface;\n\n// Open a file and load the mesh therein\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::unique_ptr&lt;RichSurfaceMeshData&gt; richData;\nstd::tie(mesh, richData) = RichSurfaceMeshData::readMeshAndData(\"archive.ply\"); geometry = richData-&gt;getGeometry();\n\n// Read a stored value\nFaceData&lt;double&gt; faceValues = richData-&gt;getFaceProperty&lt;double&gt;(\"name_a\");\n\n// Do some science\nCornerData&lt;double&gt; cornerValues = /* something important */\nEdgeData&lt;int&gt; edgeValues = /* something else important */\n\n// Add these values to the reader/writer\n// Note: alternately you could create a new record like\n// RichSurfaceMeshData newData(*mesh);\nrichData-&gt;addCornerProperty(\"name_b\", cornerValues);\nrichData-&gt;addEdgeProperty(\"name_c\", edgeValues);\n\n// Write the data to file\nrichData-&gt;write(\"new_archive.ply\")\n</code></pre> <p>Example: saving and loading a surface along with some properties</p> <pre><code>#include \"geometrycentral/surface/rich_surface_mesh_data.h\"\nusing namespace geometrycentral::surface;\n\n// Your existing mesh and data\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh; // your mesh\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry; // your geometry\nEdgeData&lt;double&gt; data; // your data\n\n// Store data\nRichSurfaceMeshData richData(*mesh);\nrichData.addMeshConnectivity();\nrichData.addGeometry(*geometry);\nrichData.addEdgeProperty(\"my prop\", data);\n\n// Write to file\nrichData.write(\"file.ply\");\n</code></pre> <p>later, when loading\u2026</p> <pre><code>// Load the mesh and the data from file\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh; std::unique_ptr&lt;RichSurfaceMeshData&gt; richData;\nstd::tie(mesh, richData) = RichSurfaceMeshData::readMeshAndData(\"file.ply\");  std::unique_ptr&lt;VertexPositionGeometry&gt; geometry = richData-&gt;getGeometry();\n\nEdgeData&lt;double&gt; data = richData-&gt;getEdgeProperty&lt;double&gt;(\"my prop\");\n</code></pre>"},{"location":"surface/utilities/io/#writing-rich-data","title":"Writing rich data","text":"<p>These methods add properties to the <code>RichSurfaceMeshData</code> object, which will be written when <code>write()</code> is called. The set of scalar types supported is the same as the .ply format, including list types.  For instance, a property of type <code>double</code> on vertices could written to a new <code>ply</code> file with.</p> <pre><code>RichSurfaceMeshData richData(*mesh);\nVertexData&lt;double&gt; values = /* incredibly important data */\nrichData.addVertexProperty(\"important_values\", values);\nrichData.write(\"my_file.ply\");\n</code></pre> <p>The following routines can create the data object and write it to file:</p> <code>RichSurfaceMeshData::RichSurfaceMeshData(SurfaceMesh&amp; mesh)</code> <p>Construct a data object from an existing mesh.</p> <code>void RichSurfaceMeshData::write(std::string filename)</code> <p>Write the object to file. The binary/ascii writing mode is determined by the <code>RichSurfaceMeshData::outputFormat</code> option.</p> <p>Note that if this reader/writer was created by loading a file, and is later written using <code>write()</code> all fields from the initial file will be automatically written out.</p> <code>void RichSurfaceMeshData::write(std::ostream&amp; out)</code> <p>Write the object to stream. The binary/ascii writing mode is determined by the <code>RichSurfaceMeshData::outputFormat</code> option.</p> <p>Note that if this reader/writer was created by loading a file, and is later written using <code>write()</code> all fields from the initial file will be automatically written out.</p> <p>To store the mesh connectivity itself in the file, call <code>addMeshConnectivity()</code>\u2014this is required if you want to load the mesh from the file later. Similarly, the <code>addGeometry()</code> helpers will store geometry as vertex positions or edge lengths.</p> <code>void RichSurfaceMeshData::addMeshConnectivity()</code> <p>Store the meshes connectivity in the file.</p> <p>This routine always stores both the internal <code>SurfaceMesh</code> representation (for use with geometry-central), and a traditional face-index list representation (for use with other software).</p> <code>void RichSurfaceMeshData::addGeometry(const EmbeddedGeometryInterface&amp; geometry)</code> <p>Add geometry to the record, which will written as <code>double</code> vertex coordinates properties named \u201cx\u201d, \u201cy\u201d, and \u201cz\u201d.</p> <code>void RichSurfaceMeshData::addIntrinsicGeometry(const IntrinsicGeometryInterface&amp; geometry)</code> <p>Add geometry to the record, which will written as a <code>double</code> edge propery called <code>intrinsic_edge_lengths</code>.</p> <p>General properties can then be written as:</p> <code>void RichSurfaceMeshData::addVertexProperty&lt;&gt;(std::string name, const VertexData&lt;&gt;&amp; data)</code> <p>Add a property for writing. </p> <ul> <li><code>name</code> A user-defined name with which the property will be written to file. Must be unique within the file.</li> <li><code>data</code> The data to be written, such a <code>VertexData&lt;double&gt;</code>.</li> </ul> <code>void RichSurfaceMeshData::addHalfedgeProperty&lt;&gt;(std::string name, const HalfedgeData&lt;&gt;&amp; data)</code> <p>Add a property for writing. </p> <ul> <li><code>name</code> A user-defined name with which the property will be written to file. Must be unique within the file.</li> <li><code>data</code> The data to be written, such a <code>HalfedgeData&lt;double&gt;</code>. </li> </ul> <code>void PlyCornerMeshData::addCornerProperty&lt;&gt;(std::string name, const CornerData&lt;&gt;&amp; data)</code> <p>Add a property for writing. </p> <ul> <li><code>name</code> A user-defined name with which the property will be written to file. Must be unique within the file.</li> <li><code>data</code> The data to be written, such a <code>CornerData&lt;double&gt;</code>. </li> </ul> <code>void RichSurfaceMeshData::addEdgeProperty&lt;&gt;(std::string name, const EdgeData&lt;&gt;&amp; data)</code> <p>Add a property for writing. </p> <ul> <li><code>name</code> A user-defined name with which the property will be written to file. Must be unique within the file.</li> <li><code>data</code> The data to be written, such a <code>EdgeData&lt;double&gt;</code>.</li> </ul> <code>void RichSurfaceMeshData::addFaceProperty&lt;&gt;(std::string name, const FaceData&lt;&gt;&amp; data)</code> <p>Add a property for writing. </p> <ul> <li><code>name</code> A user-defined name with which the property will be written to file. Must be unique within the file.</li> <li><code>data</code> The data to be written, such a <code>FaceData&lt;double&gt;</code>. </li> </ul> <code>void RichSurfaceMeshData::addBoundaryLoopProperty&lt;&gt;(std::string name, const BoundaryLoopData&lt;&gt;&amp; data)</code> <p>Add a property for writing. </p> <ul> <li><code>name</code> A user-defined name with which the property will be written to file. Must be unique within the file.</li> <li><code>data</code> The data to be written, such a <code>BoundaryLoopData&lt;double&gt;</code>. </li> </ul>"},{"location":"surface/utilities/io/#reading-rich-data","title":"Reading rich data","text":"<p>When reading a <code>RichSurfaceMeshData</code> object, you have two options:</p> <p>Option A Open the object on an existing mesh, like <code>RichSurfaceMeshData(*mesh, \"file.ply\")</code>. All resulting properties will be defined on this mesh. The existing mesh must be the \u201csame\u201d as the one the file was saved from, with the same number of elements in the same semantic ordering.</p> <code>RichSurfaceMeshData::RichSurfaceMeshData(SurfaceMesh&amp; mesh, std::string filename)</code> <p>Open a <code>ply</code> file, and interpret its fields as living on the existing halfedge mesh <code>mesh</code>. Any read properties will be returned in containers defined on <code>mesh</code>.</p> <code>RichSurfaceMeshData::RichSurfaceMeshData(SurfaceMesh&amp; mesh, std::istream&amp; in)</code> <p>Same as above, loading from a general <code>istream</code>.</p> <p>Option B Simultaneously construct a new mesh from the file, and open the file on that mesh, via <code>readMeshAndData(...)</code>. The file must have been saved with mesh connectivity included by calling <code>addMeshConnectivity()</code>.</p> <code>static std::tuple&lt;std::unique_ptr&lt;SurfaceMesh&gt;, std::unique_ptr&lt;RichSurfaceMeshData&gt;&gt; RichSurfaceMeshData::readMeshAndData(std::string filename)</code> <p>Convenience factory function to open a rich <code>.ply</code> file and load the mesh contained within, as well as creating a <code>RichSurfaceMeshData</code> reader/writer to access any other properties stored in the file.</p> <p>The base class of the created <code>SurfaceMesh</code> will match the mesh from which is was created.</p> <code>static std::tuple&lt;std::unique_ptr&lt;SurfaceMesh&gt;, std::unique_ptr&lt;RichSurfaceMeshData&gt;&gt; RichSurfaceMeshData::readMeshAndData(std::istream&amp; in)</code> <p>Same as above, loading from a stream.</p> <code>static std::tuple&lt;std::unique_ptr&lt;ManifoldSurfaceMesh&gt;, std::unique_ptr&lt;RichSurfaceMeshData&gt;&gt; RichSurfaceMeshData::readManifoldMeshAndData(std::string filename)</code> <p>Convenience factory function to open a rich <code>.ply</code> file and load the mesh contained within, as well as creating a <code>RichSurfaceMeshData</code> reader/writer to access any other properties stored in the file.</p> <p>Returns a manifold mesh, erroring out out if the file was not saved from a <code>ManifoldSurfaceMesh</code>.</p> <code>static std::tuple&lt;std::unique_ptr&lt;ManifoldSurfaceMesh&gt;, std::unique_ptr&lt;RichSurfaceMeshData&gt;&gt; RichSurfaceMeshData::readManifoldMeshAndData(std::istream&amp; in)</code> <p>Same as above, loading from a stream.</p> <p>Once the <code>RichSurfaceMeshData</code> has been opened, properties can then be read from the file like <code>getVertexProperty&lt;double&gt;(name)</code>, etc.  The template argument to this function will likely be necessary to resolve the expected type of the data. For instance, a property of type <code>double</code> on vertices could be accessed with.</p> <pre><code>RichSurfaceMeshData data(mesh, \"my_file.ply\");\nVertexData&lt;double&gt; values = data.getVertexProperty&lt;double&gt;(\"important_values\");\n</code></pre> <p>The automatic type promotion in hapPLY gives some flexibility in specifying the type of the read data\u2014 for instance if property <code>\"propName\"</code> in the example above was stored as a <code>float</code>, it could still be read as a <code>double</code>. See the documentation there for details.</p> <p>Properties can then be read as:</p> <code>VertexData&lt;T&gt; RichSurfaceMeshData::getVertexProperty&lt;T&gt;(std::string name)</code> <p>Read a property from a loaded file. </p> <ul> <li><code>name</code> A user-defined name with which the property will be read from the file. Throws if no such property exists.</li> <li>Return: The requested container.</li> </ul> <code>HalfedgeData&lt;T&gt; RichSurfaceMeshData::getHalfedgeProperty&lt;T&gt;(std::string name)</code> <p>Read a property from a loaded file. </p> <ul> <li><code>name</code> A user-defined name with which the property will be read from the file. Throws if no such property exists.</li> <li>Return: The requested container.</li> </ul> <code>CornerData&lt;T&gt; PlyCornerMeshData::getCornerProperty&lt;T&gt;(std::string name)</code> <p>Read a property from a loaded file. </p> <ul> <li><code>name</code> A user-defined name with which the property will be read from the file. Throws if no such property exists.</li> <li>Return: The requested container.</li> </ul> <code>EdgeData&lt;T&gt; RichSurfaceMeshData::getEdgeProperty&lt;T&gt;(std::string name)</code> <p>Read a property from a loaded file. </p> <ul> <li><code>name</code> A user-defined name with which the property will be read from the file. Throws if no such property exists.</li> <li>Return: The requested container.</li> </ul> <code>FaceData&lt;T&gt; RichSurfaceMeshData::getFaceProperty&lt;T&gt;(std::string name)</code> <p>Read a property from a loaded file. </p> <ul> <li><code>name</code> A user-defined name with which the property will be read from the file. Throws if no such property exists.</li> <li>Return: The requested container.</li> </ul> <code>BoundaryLoopData&lt;T&gt; RichSurfaceMeshData::getBoundaryLoopProperty&lt;T&gt;(std::string name)</code> <p>Read a property from a loaded file. </p> <ul> <li><code>name</code> A user-defined name with which the property will be read from the file. Throws if no such property exists.</li> <li>Return: The requested container.</li> </ul> <code>std::unique_ptr&lt;VertexPositionGeometry&gt; RichSurfaceMeshData::getGeometry()</code> <p>Build a new geometry object from vertex postions stored in a file (by <code>addGeometry()</code>).</p> <code>std::unique_ptr&lt;EdgeLengthGeometry&gt; RichSurfaceMeshData::getIntrinsicGeometry()</code> <p>Build a new geometry object from edge lengths stored in a file (by <code>addIntrinsicGeometry()</code>).</p>"},{"location":"surface/utilities/io/#factory-constructors","title":"Factory constructors","text":"<p>These simultaneously construct the connectivity and geometry of a mesh, and are used internally in many of the subroutines above.</p> <p><code>#include \"geometrycentral/surface/surface_mesh_factories.h\"</code></p> <p>Construct a mesh and geometry from a list of polygons and vertex positions:</p> <code>std::tuple&lt;std::unique_ptr&lt;SurfaceMesh&gt;, std::unique_ptr&lt;VertexPositionGeometry&gt;&gt; makeSurfaceMeshAndGeometry(const std::vector&lt;std::vector&lt;size_t&gt;&gt;&amp; polygons, const std::vector&lt;Vector3&gt; vertexPositions)</code> <p>Construct a new surface mesh and geometry from a list of face indices and a list of vertex positions. See the constructors of <code>SurfaceMesh</code> and <code>VertexPositionGeometry</code> for more details about their semantics.</p> <ul> <li><code>polygons</code> is a nested list of zero-indexed face indices </li> <li><code>vertexPositions</code> is a list of 3D vertex positions</li> </ul> <code>std::tuple&lt;std::unique_ptr&lt;ManifoldSurfaceMesh&gt;, std::unique_ptr&lt;VertexPositionGeometry&gt;&gt; makeManifoldSurfaceMeshAndGeometry(const std::vector&lt;std::vector&lt;size_t&gt;&gt;&amp; polygons, const std::vector&lt;Vector3&gt; vertexPositions)</code> <p>Same as above, but the result is a <code>ManifoldSurfaceMesh</code> (and thus the connectivity must describe a manifold mesh).</p> <p>Construct a mesh and geometry from face indices and vertex positions, stored in dense (Eigen) matrices:</p> <pre><code>#include \"geometrycentral/surface/surface_mesh_factories.h\"\n\n// matrices describing mesh (populated somehow)\nEigen::MatrixXd vMat = /* ... */;  // V x 3 array of vertex positions\nEigen::MatrixXi fMat = /* ... */;  // F x 3 array of zero-indexed face indices \n// (or F x 4 for quads, etc)\n\n// construct geometry-central mesh types\nstd::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = makeSurfaceMeshAndGeometry(vMat, fMat);\n\n// OR to construct a mesh which must be manifold\nstd::unique_ptr&lt;ManifoldSurfaceMesh&gt; meshManifold;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometryManifold;\nstd::tie(meshManifold, geometryManifold) = makeManifoldSurfaceMeshAndGeometry(vMat, fMat);\n</code></pre> <code>std::tuple&lt;std::unique_ptr&lt;SurfaceMesh&gt;, std::unique_ptr&lt;VertexPositionGeometry&gt;&gt; makeSurfaceMeshAndGeometry(const Eigen::MatrixBase&lt;Scalar_V&gt;&amp; vMat, const Eigen::MatrixBase&lt;Scalar_F&gt;&amp; fMat)</code> <p>Construct a new surface mesh and geometry from a list of face indices and a list of vertex positions. See the constructors of <code>SurfaceMesh</code> and <code>VertexPositionGeometry</code> for more details about their semantics. Note that these arguments are ordered <code>V,F</code> to match MATLAB &amp; friends conventions.</p> <ul> <li><code>vMat</code> is a <code>Vx3</code> floating-point valued matrix of vertex positions. Any floating point type can be used.</li> <li><code>fMat</code> is an <code>FxD</code> index valued matrix of zero-indexed face indices (e.g. an Fx3 array of triangles, of Fx4 array of quads). The index type can be any integer type (like <code>size_t</code> or <code>int</code>).</li> </ul> <p>The <code>Eigen:MatrixBase&lt;T&gt;</code> type is just a general type which accepts most Eigen matrix types as input, including geometry-central\u2019s nicely-named wrapper <code>DenseMatrix&lt;T&gt;</code>.</p> <code>std::tuple&lt;std::unique_ptr&lt;ManifoldSurfaceMesh&gt;, std::unique_ptr&lt;VertexPositionGeometry&gt;&gt; makeManifoldSurfaceMeshAndGeometry(const Eigen::MatrixBase&lt;Scalar_V&gt;&amp; vMat, const Eigen::MatrixBase&lt;Scalar_F&gt;&amp; fMat)</code> <p>Same as above, but the result is a <code>ManifoldSurfaceMesh</code> (and thus the connectivity must describe a manifold mesh).</p>"},{"location":"surface/utilities/simple_polygon_mesh/","title":"Simple Polygon Mesh","text":"<p><code>SimplePolygonMesh</code> is small mesh helper class which stores vertex positions, and indexed list of faces, and (optionally) texture coordinates. Used mainly as an intermediate representation for input and output.</p> <p><code>#include \"geometrycentral/surface/simple_polygon_mesh.h\"</code></p> <p>This is not the mesh you\u2019re looking for</p> <p><code>SurfaceMesh</code> is the main mesh class in geometry-central. It supports a wide range of traversals, geometry, and other operations, and is used in all higher-level algorithms. </p> <p>This class, <code>SimplePolygonMesh</code>, is a small utility used mainly for input/output and occasionally as an implementation detail for other algorithms.</p> <p>If you are implementing any nontrivial algorithm, you should almost certainly be using <code>SurfaceMesh</code> instead.</p> <p>PolygonSoupMesh deprecation</p> <p>In a previous version of geometry-central, this class was called <code>PolygonSoupMesh</code>\u2014that name was potentially misleading. To avoid breaking existing code, <code>polygon_soup_mesh.h</code> now simply typedefs <code>PolygonSoupMesh</code> as <code>SimplePolygonMesh</code>. Please use <code>SimplePolygonMesh</code> in all new code.</p>"},{"location":"surface/utilities/simple_polygon_mesh/#members","title":"Members","text":"<ul> <li><code>std::vector&lt;Vector3&gt; vertexCoordinates</code> 3D positions for each vertex in the mesh. </li> <li><code>std::vector&lt;std::vector&lt;size_t&gt;&gt; polygons</code> The list of polygonal faces comprising the mesh. Each inner vector is a face, given by the 0-based vertex indices in to the <code>vertexCoordinates</code> array. The ordering of these indices is interpreted as the orientation of the face, via a counter-clockwise ordering of the vertices.</li> <li><code>std::vector&lt;std::vector&lt;Vector2&gt;&gt; paramCoordinates</code> (optional) 2D parameterization coordinates associated with each corner of each face. If non-empty, the dimensions of this array should be exactly the same as <code>polygons</code>; each coordinate corresponds to the matching polygon corner in <code>polygons</code>.</li> </ul>"},{"location":"surface/utilities/simple_polygon_mesh/#constructors","title":"Constructors","text":"<code>SimplePolygonMesh::SimplePolygonMesh()</code> <p>Create an empty mesh.</p> <code>SimplePolygonMesh::SimplePolygonMesh(std::string filename, std::string type = \"\")</code> <p>Load a mesh from file. See documentation for <code>readMeshFromFile()</code> below.</p> <code>SimplePolygonMesh::SimplePolygonMesh(std::istream&amp; in, std::string type)</code> <p>Load a mesh from file. See documentation for <code>readMeshFromFile()</code> below.</p> <code>SimplePolygonMesh::SimplePolygonMesh(const std::vector&lt;std::vector&lt;size_t&gt;&gt;&amp; polygons_, const std::vector&lt;Vector3&gt;&amp; vertexCoordinates_)</code> <p>Construct a mesh from a list of polygons and vertex coordinates.</p> <code>SimplePolygonMesh::SimplePolygonMesh(const std::vector&lt;std::vector&lt;size_t&gt;&gt;&amp; polygons_, const std::vector&lt;Vector3&gt;&amp; vertexCoordinates_, const std::vector&lt;std::vector&lt;Vector2&gt;&gt;&amp; paramCoordinates_)</code> <p>Construct a mesh from a list of polygons, vertex coordinates, and parameterization coordinates.</p> <code>std::unique_ptr&lt;SimplePolygonMesh&gt; unionMeshes(const std::vector&lt;SimplePolygonMesh&gt;&amp; meshes)</code> <p>Union a collection of polygon meshes in to a single mesh.</p>"},{"location":"surface/utilities/simple_polygon_mesh/#input-output","title":"Input &amp; Output","text":"<p>Currently the following mesh types are supported for reading:</p> <ul> <li><code>obj</code></li> <li><code>ply</code> (using hapPLY)</li> <li><code>stl</code></li> <li><code>off</code></li> </ul> <p>Currently, UV coordinates are only read from file for the <code>obj</code> format.</p> <p>For writing, only <code>obj</code> is supported. Note that <code>RichSurfaceMeshData</code> provides additional ply writing routines for surface meshes, including storing buffers of data.</p> <p>The desired file type can be passed as the <code>type</code> to any of the routines below as an unpunctuated lower-case string, like <code>readMeshFromFile(myFilename, \"stl\")</code>. </p> <code>void SimplePolygonMesh::readMeshFromFile(std::istream&amp; in, std::string type);</code> <p>Read a mesh from an input stream. Type must be specificed (see above). </p> <p>Clears any existing data from the file before loading.</p> <code>void SimplePolygonMesh::readMeshFromFile(std::string filename, std::string type = \"\");</code> <p>Read a mesh from a file. <code>filename</code> should be the full path to the file. The type can be manually specified (see above), or given as the empty string (<code>\"\"</code>) to attempt to auto-detect from the filename extension.</p> <p>Clears any existing data from the file before loading.</p> <code>void SimplePolygonMesh::writeMesh(std::ostream&amp; out, std::string type);</code> <p>Write a mesh to an input stream. Type must be specificed (see above).</p> <code>void SimplePolygonMesh::writeMesh(std::string filename, std::string type = \"\");</code> <p>Write a mesh to file. <code>filename</code> should be the full path to the file. The type can be manually specified (see above), or given as the empty string (<code>\"\"</code>) to attempt to auto-detect from the filename extension.</p>"},{"location":"surface/utilities/simple_polygon_mesh/#accessors","title":"Accessors","text":"<code>size_t SimplePolygonMesh::nFaces()</code> <p>The number of faces in the mesh.</p> <code>size_t SimplePolygonMesh::nVertices()</code> <p>The number of vertices in the mesh.</p> <code>bool SimplePolygonMesh::hasParameterization()</code> <p>True if the mesh has a 2D corner parameterization in the <code>paramCoordinates</code> member.</p>"},{"location":"surface/utilities/simple_polygon_mesh/#modification","title":"Modification","text":"<code>void SimplePolygonMesh::mergeIdenticalVertices()</code> <p>Vertices with identical coordinates are merged to be a single vertex entry, and the face indices are updated accordingly.</p> <p>Identity is tested using a simple exact floating-point comparison test, no radius or threshold is supported.</p> <code>std::vector&lt;size_t&gt; SimplePolygonMesh::stripUnusedVertices()</code> <p>Remove vertices from <code>vertexCoordinates</code> which do not appear in any face. Face indices are updated accordingly. </p> <p>Returns an index translation vector mapping old indices to new, such that <code>vec[ind_old] == ind_new</code>. Holds <code>INVALID_IND</code> for any old indices which were stripped.</p> <code>void SimplePolygonMesh::stripFacesWithDuplicateVertices()</code> <p>Remove any faces from <code>polygons</code> for which some vertex index appears multiple times.</p> <code>void SimplePolygonMesh::triangulate()</code> <p>All faces with more than 3 sides are triangulated, replacing the original face with multiple triangular faces. Currently uses a naive fan triangulation strategy.</p> <p>An error is thrown for any faces with &lt; 3 sides.</p> <code>void SimplePolygonMesh::clear()</code> <p>Empty all data arrays for the mesh.</p>"},{"location":"surface/utilities/surface_point/","title":"Surface Point","text":"<p>A <code>SurfacePoint</code> is a generic location on a surface, which might be at a vertex, along an edge, or inside a face. Surface points are used throughout geometry-central for methods that input or output arbitrary locations on surfaces.</p> <p><code>#include \"geometrycentral/surface/surface_point.h\"</code></p> <p>The field <code>SurfacePoint::type</code> is an enum: <pre><code>enum class SurfacePointType { Vertex = 0, Edge, Face };\n</code></pre></p> <p>which indicates what kind of point this is.</p> <ul> <li> <p>if the surface point is a vertex, the field <code>SurfacePoint::vertex</code> indicates which vertex. Otherwise it is the null default vertex.</p> </li> <li> <p>if the surface point is along an edge, the field <code>SurfacePoint::edge</code> indicates which edge. Otherwise it is the null default edge. The field <code>SurfacePoint::tEdge</code> indicates the location along that edge, in the range <code>[0,1]</code>, with <code>0</code> at <code>edge.halfedge().vertex()</code>.</p> </li> <li> <p>if the surface point is inside a face, the field <code>SurfacePoint::face</code> indicates which face. Otherwise it is the null default face. The field <code>SurfacePoint::faceCoords</code> indicates the location inside that face, as barycentric coordinates (numbered according to the iteration order of vertices about the face, as usual).</p> </li> </ul> <p>Surface points have a few useful utility methods:</p> <code>T SurfacePoint::interpolate(const VertexData&lt;T&gt;&amp; data)</code> <p>Given data of tempalte type <code>T</code> defined at vertices, linearly interpolates to a value at this location.</p> <code>SurfacePoint SurfacePoint::inSomeFace()</code> <p>All surface points (vertex, edge, face) have an equivalent point in one or many adjacent faces. For instance, a vertex could be equivalently a point in any of the incident faces, with a single <code>1</code> barycentric coordinate, or a point on an edge could be a point in either of the two adjacent faces.</p> <p>This function returns one of the equivalent surface points in a face (chosen arbitrarily). If this point is a face point, the output is a copy of this point.</p> <code>Vertex SurfacePoint::nearestVertex()</code> <p>Returns the nearest vertex which is adjacent to this point.</p> <p>For surface points which are vertices, it will return the same vertex.  For surface points which are along edges, it will return one of the two incident vertices.  For surface points which are inside faces, it will return one of the three incident vertices.</p> <p>In addition, surface points can be used to construct barycentric vectors.</p>"},{"location":"tutorials/basic_mutation/","title":"Basic Mutation","text":"<p>This tutorial explores the surface mesh data structure in geometry-central, via a simple example which splits and flips edges to perform 4:1 subidivision of a triangle mesh.</p> <p>View full, runnable source code in the tutorial repository.</p>"},{"location":"tutorials/basic_mutation/#basic-setup","title":"Basic setup","text":"<p>To begin we include headers, bring in namespaces, See the first tutorial for more info on these steps.</p> <pre><code>#include \"geometrycentral/surface/manifold_surface_mesh.h\"\n#include \"geometrycentral/surface/meshio.h\"\n#include \"geometrycentral/surface/surface_mesh.h\"\n\n#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n\nusing namespace geometrycentral;\nusing namespace geometrycentral::surface;\n</code></pre> <p>Again as before, load an input mesh from file, and visualize it using Polyscope. Here, we\u2019ll require that the mesh be manifold.</p> <pre><code>std::unique_ptr&lt;ManifoldSurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readManifoldSurfaceMesh(args::get(inputFilename));\n\npolyscope::init();\npolyscope::registerSurfaceMesh(\"input mesh\", geometry-&gt;vertexPositions,\nmesh-&gt;getFaceVertexList());\n\n// call polyscope::show(); to inspect the mesh at this point\n</code></pre> <p>Now, we\u2019ll evaluate a 4:1 sudivision via the following algorithm:</p> <ul> <li>split each edge and connect to opposite vertices</li> <li>flip any new edge connecting a new to old vertex</li> </ul> <p>First, we\u2019ll create two <code>MeshData&lt;&gt;</code> containers. They associate data with mesh elements. We initialize them both with <code>true</code> values, because initially all vertices (resp. edges) are original. We\u2019ll also track a list of edges to flip in the second phase.</p> <pre><code>VertexData&lt;bool&gt; isOrigVert(*mesh, true);\nEdgeData&lt;bool&gt; isOrigEdge(*mesh, true);\nstd::vector&lt;Edge&gt; toFlip;\n</code></pre> <p>Now our main algorithm loop (commented inline).</p> <pre><code>for (Edge e : mesh-&gt;edges()) { // loop over all edges\nif (!isOrigEdge[e]) continue; // don't keep processing new edges\n\n// gather both vertices incident on the edge, and their positions\nVertex oldA = e.halfedge().tipVertex();\nVertex oldB = e.halfedge().tailVertex();\nVector3 oldAPos = geometry-&gt;vertexPositions[oldA];\nVector3 oldBPos = geometry-&gt;vertexPositions[oldB];\n\n// split the edge\nVertex newV = mesh-&gt;splitEdgeTriangular(e).vertex();\nisOrigVert[newV] = false;\n\n// position the new vertex\nVector3 newPos = 0.5 * (oldAPos + oldBPos);\ngeometry-&gt;vertexPositions[newV] = newPos;\n\n// iterate through the edges incident on the new vertex\nfor (Edge e : newV.adjacentEdges()) {\nisOrigEdge[e] = false;                  // mark the new edges\nVertex otherV = e.otherVertex(newV);    // other side of edge\n\n// if this is a new edge between an old an new vertex, save for flipping\nif (isOrigVert[otherV] &amp;&amp; otherV != oldA &amp;&amp; otherV != oldB) {\ntoFlip.push_back(e);\n}\n}\n}\n</code></pre> <p>and finally, we can actually flip the edges to complete the second phase</p> <pre><code>for (Edge e : toFlip) {\nmesh-&gt;flip(e);\n}\n</code></pre> <p>we now register this new mesh with geometry-central</p> <pre><code>auto* psMesh =\npolyscope::registerSurfaceMesh(\"subdiv mesh\", geometry-&gt;vertexPositions, mesh-&gt;getFaceVertexList());\n\npolyscope::show();\n</code></pre> <p>and as expected get the subdivided mesh.</p> <p>Before: </p> <p>After: </p>"},{"location":"tutorials/direction_fields/","title":"Direction fields","text":"<p>This tutorial shows a higher-level example in geometry-central, where we use a built-in routine to visualize a direction field.</p> <p>View full, runnable source code in the tutorial repository.</p>"},{"location":"tutorials/direction_fields/#basic-setup","title":"Basic setup","text":"<p>To begin we include headers, bring in namespaces, See the first tutorial for more info on these steps.</p> <pre><code>#include \"geometrycentral/surface/manifold_surface_mesh.h\"\n#include \"geometrycentral/surface/meshio.h\"\n#include \"geometrycentral/surface/surface_mesh.h\"\n#include \"geometrycentral/surface/direction_fields.h\"\n\n#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n\nusing namespace geometrycentral;\nusing namespace geometrycentral::surface;\n</code></pre> <p>Again, load an input mesh from file, and visualize it using Polyscope. We\u2019ll require that the mesh be manifold so we have obvious vertex tangent spaces.</p> <pre><code>std::unique_ptr&lt;ManifoldSurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readManifoldSurfaceMesh(args::get(inputFilename));\n\npolyscope::init();\nauto* psMesh =\npolyscope::registerSurfaceMesh(\"input mesh\",\ngeometry-&gt;vertexPositions, mesh-&gt;getFaceVertexList());\n</code></pre> <p>Now, computing the direction field itself amoutns to a single function call <pre><code>VertexData&lt;Vector2&gt; field = computeSmoothestVertexDirectionField(*geometry);\n</code></pre></p> <p>Before we visualize this direction field, we need to do a little more setup. The tangent vectors are defined in an abritrary, intrinsic tangent space at each vertex. We need to tell Polyscope how these tangent spaces sit in 3D space.</p> <pre><code>geometry-&gt;requireVertexTangentBasis();\nVertexData&lt;Vector3&gt; vBasisX(*mesh);\nfor (Vertex v : mesh-&gt;vertices()) {\nvBasisX[v] = geometry-&gt;vertexTangentBasis[v][0];\n}\npsMesh-&gt;setVertexTangentBasisX(vBasisX);\n</code></pre> <p>Now we can add the vector field to Polyscope and inspect it! <pre><code>psMesh-&gt;addVertexIntrinsicVectorQuantity(\"vectors\", field);\npolyscope::show();\n</code></pre></p> <p>Result: </p>"},{"location":"tutorials/load_mesh/","title":"Load & navigate a mesh","text":"<p>This tutorial walks through some basics with geometry-central, showing how to load a mesh from file and iterate through its elements.</p> <p>View full, runnable source code in the tutorial repository.</p>"},{"location":"tutorials/load_mesh/#basic-setup","title":"Basic setup","text":"<p>To begin, we include the relevant headers, including some for visualization using Polyscope.</p> <pre><code>#include \"geometrycentral/surface/manifold_surface_mesh.h\"\n#include \"geometrycentral/surface/meshio.h\"\n#include \"geometrycentral/surface/surface_mesh.h\"\n\n#include \"polyscope/polyscope.h\"\n#include \"polyscope/surface_mesh.h\"\n</code></pre> <p>All functionality of geometry-central is contained within the <code>geometrycentral</code> namespace; surface meshes live in <code>geometrycentral::surface</code>. We will bring both in to scope so we can just type <code>SurfaceMesh</code> instead of <code>geometrycentral::surface::SurfaceMesh</code>, etc.</p> <pre><code>using namespace geometrycentral;\nusing namespace geometrycentral::surface;\n</code></pre> <p>Now, we use the mesh loaders to construct a surface mesh\u2019s connectivity and geometry from file. Many common file formats like <code>.obj</code>, <code>.ply</code>, and <code>.stl</code> are supported. By default, this mesh class represents very general polygonal meshes, including nonmanifold meshes.</p> <pre><code>  std::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readSurfaceMesh(\"spot.obj\");\n</code></pre> <p>Alternately, you could construct a mesh which is required to be manifold. <pre><code>  std::tie(mesh, geometry) = readManifoldSurfaceMesh(\"spot.obj\");\n</code></pre></p> <p>If you\u2019r not already familiar with <code>std::unique_ptr&lt;&gt;</code>, the following gives a bit more context (click to expand).</p> Why use <code>std::unique_ptr&lt;&gt;</code>? <p>The mesh loader, like many functions in geometry-central, returns constructed objects via a <code>unique_ptr</code>. Unique pointers are an important tool for memory management in modern C++; if you haven\u2019t used them before, we suggest you give them a try!</p> <p>In most ways, a <code>unique_ptr</code> acts just like a normal C++ pointer. You can dereference it with <code>*uPtr</code>, and access its members and function like <code>uPtr-&gt;function()</code>. However, the <code>unique_ptr</code> helps prevent common memory-management mistakes, and communicates the programmer\u2019s intent about object lifetime. This is accomplished with two properties:</p> <ul> <li> <p>You don\u2019t need to call <code>delete</code> on a <code>unique_ptr</code>, it happens automatically when the pointer is destructed, e.g. when it goes out of scope at the end of a function, or when the object it is a member of gets deleted. This helps prevent memory leaks where you forget to deallocate the object.</p> </li> <li> <p>You cannot copy the <code>unique_ptr</code>; hence it is \u201cunique\u201d! You can still pass around references, or <code>std::move()</code> the pointer, which are sufficient for most reasonable uses. This helps prevent you from creating a copy, and then accidentally deleting the pointer twice.</p> </li> </ul> <p>The general paradigm in geometry-central (and a recommended style in modern C++) is to return long-lived, allocated objects with a <code>unique_ptr</code>, and pass these objects in to functions and dependent classes by reference.</p> <p>For instance, we might write a function which takes a mesh as an argument like</p> <pre><code>void processMesh(SurfaceMesh&amp; inputMesh) { /* do stuff */}\n</code></pre> <p>and call it by dereferencing the unique pointer to pass a reference</p> <pre><code>std::unique_ptr&lt;SurfaceMesh&gt; mesh;\nstd::unique_ptr&lt;VertexPositionGeometry&gt; geometry;\nstd::tie(mesh, geometry) = readSurfaceMesh(\"spot.obj\"); processMesh(*mesh);\n</code></pre> <p>For more details about unique pointers, see the language documentation, or many tutorials around the web.</p> <p>If you really don\u2019t want to use unique pointers, you can simply release the unique pointer to an ordinary pointer:</p> <pre><code>std::unique_ptr&lt;SurfaceMesh&gt; mesh /* populated as above */;\nSurfaceMesh* meshPtr = mesh.release();\n</code></pre> <p>The <code>meshPtr</code> now points the mesh object, and you are responsible for eventually deleting this pointer. After calling <code>release()</code>, the unique pointer points to nothing and will no longer deallocate the object.</p>"},{"location":"tutorials/load_mesh/#traverse-the-mesh","title":"Traverse the mesh","text":"<p>As a simple demonstration of the mesh data structure, lets iterate through the vertices of the mesh, and for each vertex print the adjacent faces.  <pre><code>  for (Vertex v : mesh-&gt;vertices()) {\nstd::cout &lt;&lt; \"Vertex \" &lt;&lt; v &lt;&lt; \" has degree \" &lt;&lt; v.degree() &lt;&lt; \"\\n\";\nfor (Face fn : v.adjacentFaces()) {\nstd::cout &lt;&lt; \"  incident on face \" &lt;&lt; fn &lt;&lt; \"\\n\";\n}\n}\n</code></pre></p> <p>This prints something like:</p> <pre><code>...\nVertex v_2907 has degree 6\n  incident on face f_5815\n  incident on face f_2885\n  incident on face f_2887\n  incident on face f_5812\n  incident on face f_5813\n  incident on face f_5814\nVertex v_2908 has degree 6\n  incident on face f_5822\n  incident on face f_2888\n...\n</code></pre>"},{"location":"tutorials/load_mesh/#visualize-the-mesh-with-polyscope","title":"Visualize the mesh with Polyscope","text":"<p>Finally, we can easily visualize the mesh we loaded via Polyscope.</p> <pre><code>  polyscope::init(); // initialize the gui\n\n// add the mesh to the gui\npolyscope::registerSurfaceMesh(\"my mesh\", geometry-&gt;vertexPositions, mesh-&gt;getFaceVertexList());\n\npolyscope::show(); // pass control to the gui until the user exits\n</code></pre>"},{"location":"utilities/eigenmap/","title":"Utilities for Eigen Interoperability","text":"<p>Helper functions to interface with Eigen data in interesting ways.</p> <p><code>#include \"geometrycentral/utilities/eigen_interop_helpers.h\"</code></p>"},{"location":"utilities/eigenmap/#expanding-a-homogenous-pod-type-into-an-eigenmatrix","title":"Expanding a homogenous POD type into an <code>Eigen::Matrix</code>","text":"<code>Eigen::Map&lt;Eigen::Matrix&lt;T, Eigen::Dynamic, k, Options&gt;, Alignment&gt; EigenMap(MeshData&lt;E,O&gt; &amp;data)</code> <p>Given <code>MeshData</code> storing a POD type <code>O</code> like <code>Vector3</code> which can be meaningfully decomposed into a set of <code>k</code> other types <code>T</code>, this function maps the memory of the vector of <code>O</code> as a <code>Matrix&lt;T, Dynamic, k&gt;</code>. E.g., <code>MeshData&lt;Vertex, Vector3&gt;</code> (N x 1) -&gt; <code>Map&lt;Matrix&lt;double, Dynamic, 3&gt;&gt;</code> (N x 3). The template <code>Options</code> allows you to specify is the underlying data should be bound in RowMajor or ColMajor order.</p> <pre><code>VertexData&lt;Vector3&gt; pos;\n// auto resolves to Eigen::Map&lt;Eigen::Matrix&lt;double, Eigen::Dynamic, 3, Eigen::RowMajor&gt;, Alignment&gt;\nauto mapped_position_matrix = EigenMap&lt;double, 3, Eigen::RowMajor&gt;(pos);\n</code></pre> <p>Note that it is unnecessary to specify <code>Eigen::RowMajor</code> in this example since it is the default template option. Furthermore template options <code>E</code> and <code>O</code> corresponding to the Mesh Element and Data Type need not be explicitly specified since the compiler can infer it for us.</p> <p>Most important, modifications to <code>mapped_position_matrix</code> will be reflected in <code>pos</code> since they share the same memory!</p> <code>Eigen::Map&lt;const Eigen::Matrix&lt;T, Eigen::Dynamic, k, Options&gt;, Alignment&gt; EigenMap(const MeshData&lt;E,O&gt; &amp;data)</code> <p>Const version of the above.</p>"},{"location":"utilities/eigenmap/#flattening-a-homogeneous-pod-type-into-an-eigenvector","title":"Flattening a homogeneous POD type into an <code>Eigen::Vector</code>","text":"<code>Eigen::Map&lt;Eigen::Matrix&lt;T, Eigen::Dynamic, 1, Options&gt;, Alignment&gt; FlattenedEigenMap(MeshData&lt;E,O&gt; &amp;data)</code> <p>Given <code>MeshData</code> storing a POD type <code>O</code> like <code>Vector3</code> which can be meaningfully decomposed into a set of <code>k</code> other types <code>T</code>, this function maps the memory of the vector of <code>O</code> as a vector of <code>T</code> (<code>Matrix&lt;T, Dynamic, 1&gt;</code>). E.g., <code>MeshData&lt;Vertex, Vector3&gt;</code> (N x 1) -&gt; <code>Map&lt;Matrix&lt;double, Dynamic, 1&gt;&gt;</code> (3N x 1). The template <code>Options</code> allows you to specify is the underlying data should be bound in RowMajor or ColMajor order.</p> <pre><code>VertexData&lt;Vector3&gt; pos;\n// auto resolves to Eigen::Map&lt;Eigen::Matrix&lt;double, Eigen::Dynamic, 1, Eigen::ColMajor&gt;, Alignment&gt;\nauto mapped_flat_position_matrix = FlattenedEigenMap&lt;double, 3&gt;(pos);\n</code></pre> <p>Note that the return defaults to <code>ColMajor</code> order. The template options <code>E</code> and <code>O</code> corresponding to the Mesh Element and Data Type need not be explicitly specified since the compiler can infer it for us.</p> <p>Most important, modifications to <code>mapped_flat_position_matrix</code> will be reflected in <code>pos</code> since they share the same memory! </p> <code>Eigen::Map&lt;const Eigen::Matrix&lt;T, Eigen::Dynamic, 1, Options&gt;, Alignment&gt; FlattenedEigenMap(const MeshData&lt;E,O&gt; &amp;data)</code> <p>Const version of the above.</p>"},{"location":"utilities/miscellaneous/","title":"Miscellaneous","text":"<p>Miscellaneous utility functions.</p> <p><code>#include \"geometrycentral/utilities/utilities.h\"</code></p>"},{"location":"utilities/miscellaneous/#constants","title":"Constants","text":"<ul> <li><code>size_t INVALID_IND</code> Used to represent invalid indices. Defined as <code>std::numeric_limits&lt;size_t&gt;::max()</code></li> <li><code>double PI</code> Defined to be <code>3</code>. Just kidding.</li> </ul>"},{"location":"utilities/miscellaneous/#angles-and-arithmetic","title":"Angles and arithmetic","text":"<code>T clamp(T val, T low, T high)</code> <p>Returns <code>val</code> clamped to lie bewteen <code>low</code> and <code>high</code> (using comparison operators).</p> <code>double regularizeAngle(double theta)</code> <p>Shifts an angle to lie in the range [0, 2 \\pi2 \\pi].</p>"},{"location":"utilities/miscellaneous/#random-numbers","title":"Random numbers","text":"<p>All random values are drawn from a generator seeded at program initialization. The generator is seeded via <code>std::random_device</code>, so results will not be consistent between repeated runs of the program.</p> <code>double unitRand()</code> <p>Returns a uniformly-distributed value on [0,1][0,1].</p> <code>double randomReal()</code> <p>Returns a uniformly-distributed value on [0,1][0,1].</p> <code>double randomNormal(double mean=0.0, double stddev = 1.0)</code> <p>Returns a normally-distributed value from the specified mean and variance.</p> <code>int randomInt(int lower, int upper)</code> <p>Returns a uniformly-distributed integer on the INCLUSIVE range <code>[lower, upper]</code></p> <code>size_t randomIndex(size_t size)</code> <p>Returns a uniformly-distributed integer on the range <code>[0, size)</code>.</p>"},{"location":"utilities/miscellaneous/#indices-and-lists","title":"Indices and lists","text":"<code>std::vector&lt;T&gt; applyPermutation(const std::vector&lt;T&gt;&amp; sourceData, const std::vector&lt;size_t&gt;&amp; permOldToNew)</code> <p>Apply a permutation to reorder a vector, such that <code>output[i] = sourceData[permOldToNew[i]]</code>.</p> <p>The permutation should be an injection to <code>[0,sourceData.size())</code>. The <code>sourceData</code>, <code>permOldToNew</code>, and the output should all have same size.</p>"},{"location":"utilities/miscellaneous/#printing-and-strings","title":"Printing and strings","text":"<code>std::string to_string(std::vector&lt;T&gt; const&amp; v)</code> <p>Print the elements of vector to a string using the <code>&lt;&lt;</code> operator for each element.</p> <code>std::string str_printf(const std::string&amp; format, Args... args)</code> <p>Print directly to a string, where <code>format</code> and <code>args</code> obey <code>printf</code> semantics.</p>"},{"location":"utilities/miscellaneous/#memory-management","title":"Memory management","text":"<code>void safeDelete(T*&amp; x)</code> <p>Call <code>delete</code> on a pointer. If the pointer is <code>nullptr</code>, does nothing. If it is non-null, sets to <code>nullptr</code> after deleting.</p> <code>void safeDeleteArray(T*&amp; x)</code> <p>Like <code>safeDelete()</code>, but for arrays.</p>"},{"location":"utilities/miscellaneous/#type-names","title":"Type names","text":"<p>Useful for debugging templated code. Uses <code>typeid()</code> from <code>&lt;typeinfo&gt;</code>.</p> <code>std::string typeNameString(T&amp; x)</code> <p>Returns the name of a type as a string. </p> <code>std::string typeNameString(T* x)</code> <p>Like <code>typeNameString(T&amp; x)</code>, but for pointers.</p>"},{"location":"utilities/vector2/","title":"Vector2","text":"<p><code>geometrycentral::Vector2</code> is the basic 2D vector type in geometry central. Like a good turkey sandwich, it aims to be unsurprising yet satisfying.</p> <p>Of particular interest, <code>Vector2</code> is also used to encode 2D rotations, by supporting multiplication as a complex number. See the rotations section.</p> <p><code>#include \"geometrycentral/utilities/vector2.h\"</code></p>"},{"location":"utilities/vector2/#construction","title":"Construction","text":"<p><code>Vector2</code> is a POD type, so you should use brace-initialization sytax:</p> <pre><code>#include \"geometrycentral/utilities/vector2.h\nusing namespace geometrycentral;\n\nVector2 myVec{3.8, 2.9}; //create\nmyVec = Vector2{1.1, 2.2}; // reassign\n</code></pre> <p>Factory methods can construct a few common values:</p> <code>static Vector2 Vector2::zero()</code> <p>Returns the zero vector</p> <code>static Vector2 Vector2::constant(double c)</code> <p>Returns a vector with all components set to c</p> <code>static Vector2 Vector2::infinity()</code> <p>Returns the infinite vector (\\infty, \\infty)(\\infty, \\infty).</p> <code>static Vector2 Vector2::undefined()</code> <p>Returns the undefined vector <code>(NaN, NaN)</code>.</p> <p>And serve as constructors:</p> <code>static Vector2 Vector2::fromAngle(double theta)</code> <p>Returns the vector (\\cos(\\theta), \\sin(\\theta))(\\cos(\\theta), \\sin(\\theta)).</p> <code>static Vector2 Vector2::fromComplex(std::complex&lt;double&gt; c)</code> <p>Converts a <code>std::complex&lt;double&gt;</code> to a <code>Vector2</code>.</p>"},{"location":"utilities/vector2/#access","title":"Access","text":"<p>The two elements of the vector can be accessed as <code>vec.x</code> and <code>vec.y</code>.</p> <p>Alternately, the two elements can be indexed as <code>vec[0]</code> and <code>vec[1]</code>.</p>"},{"location":"utilities/vector2/#conversion","title":"Conversion","text":"<code>Vector2::operator std::complex&lt;double&gt;()</code> <p><code>Vector2</code> is implicitly convertible to <code>std::complex&lt;double&gt;</code>.</p> <code>Vector2::operator&lt;&lt;()</code> <p><code>Vector2</code> can be serialized.</p> <pre><code>Vector2 v{1.2, 3.4};\nstd::cout &lt;&lt; v &lt;&lt; std::endl;\n// prints something like: &lt;1.2, 3.4&gt;\n</code></pre>"},{"location":"utilities/vector2/#arithmetic","title":"Arithmetic","text":"<p>Vector2 supports the element-wise addition, subraction, and scalar multiplication you would probably expect.</p>"},{"location":"utilities/vector2/#rotations-and-complex-multiplication","title":"Rotations and complex multiplication","text":"<p>Our <code>Vector2</code> types further obey the multiplication and division rules of complex arithmetic, and thus can be used to represent rotations. For instance, a unit 2D vector representing a rotation can be used to rotate another vector like: <pre><code>Vector2 v = /* your vector */\nVector2 r = Vector2::fromAngle(PI/4); // rotation by 45 degrees\nVector2 vRot = r * v;\n</code></pre> This is fundamentally no different from using 2x2 rotation matrices, but leads to much cleaner code (try using division to compute relative rotations!).</p>"},{"location":"utilities/vector2/#member-operations","title":"Member operations","text":"<p>These methods do not change the underlying <code>Vector2</code>, but return a new <code>Vector2</code>. <pre><code>Vector2 vec{1., 2.};\nvec.rotate90();         // does nothing\nvec = vec.rotate90();   // much better\n</code></pre></p> <code>Vector2 Vector2::normalize()</code> <p>Returns a unit-norm vector with the same direction. If the input is the zero vector, the result will contain NaNs.</p> <code>Vector2 Vector2::normalizeCutoff(double mag = 0.)</code> <p>Returns a unit-norm vector with the same direction. If the input has magnitude less <code>&lt;= mag</code>, the vector is unchanged.</p> <code>Vector2 Vector2::unit()</code> <p>Alias for <code>normalize()</code>. </p> <code>Vector2 Vector2::rotate(double theta)</code> <p>Rotate the vector by angle \\theta\\theta in the counter-clockwise direction.</p> <code>Vector2 Vector2::rotate90()</code> <p>Rotate the vector by 90^{\\circ}90^{\\circ} in the counter-clockwise direction.</p> <code>Vector2 Vector2::pow(double p)</code> <p>Raise the vector to a real power, in the sense of complex arithmetic. (see std::pow)</p> <code>Vector2 Vector2::pow(Vector2 p)</code> <p>Raise the vector to a complex power, in the sense of complex arithmetic. (see std::pow)</p> <code>Vector2 Vector2::conj()</code> <p>Transform the vector to its complex conjugate, negating the <code>y</code> component.</p> <code>Vector2 Vector2::inv()</code> <p>Invert the vector, in the sense of complex arithmetic. Equivalent to <code>Vector2{1., 0.} / v</code>.</p>"},{"location":"utilities/vector2/#function-operations","title":"Function operations","text":"<p>These operations do not change the vector on which they are called.</p> <code>double norm(Vector2 v)</code> <p>Returns the magnitude of the vector.</p> <p>Also available as <code>v.norm()</code>.</p> <code>double norm2(Vector2 v)</code> <p>Returns the squared magnitude of the vector.</p> <p>Also available as <code>v.norm()</code>.</p> <code>Vector2 normalize(Vector2 v)</code> <p>Returns normalized copy of the vector.</p> <code>Vector2 normalizeCutoff(Vector2 v, double mag = 0.)</code> <p>Returns a normalized copy of the vector. If the input has magnitude less <code>&lt;= mag</code>, the vector is unchanged.</p> <code>Vector2 unit(Vector2 v)</code> <p>Alias for <code>normalize(v)</code>.</p> <code>double arg(Vector2 v)</code> <p>Returns the argument in the sense of complex arithmetic (i.e., the angle against the xx-axis).</p> <p>Also available as <code>v.arg()</code>.</p> <code>double dot(Vector2 u, Vector2 v)</code> <p>Returns the dot product between two vectors.</p> <code>double cross(Vector2 u, Vector2 v)</code> <p>Returns the \u201ccross\u201d product between two vectors, that is <code>u.x * v.y - u.y * v.x</code>. Intuitively, the zz-component of the 3D cross product of vectors in the plane.</p> <code>Vector3 cross3(Vector2 u, Vector2 v)</code> <p>Returns the 3D cross product of vectors in the plane.</p> <code>double angle(Vector2 u, Vector2 v)</code> <p>Returns the angle between two not-necessarily-unit vectors. Output in the range [0, \\pi][0, \\pi].</p> <code>Vector2 clamp(Vector2 val, Vector2 low, Vector2 high)</code> <p>Returns returns a a vector where each component has been clamped to be between the corresponding compnents of <code>low</code> and <code>high</code>.</p> <code>Vector2 componentwiseMin(Vector2 u, Vector2 v)</code> <p>Returns a new vector, each component of which is the minimum of that component in <code>u</code> and <code>v</code>.</p> <code>Vector2 componentwiseMax(Vector2 u, Vector2 v)</code> <p>Returns a new vector, each component of which is the maximum of that component in <code>u</code> and <code>v</code>.</p>"},{"location":"utilities/vector2/#properties","title":"Properties","text":"<code>bool isfinite(Vector2 u)</code> <p>Returns true if both of the components of the vector are finite.</p> <p>Note: this function is intentionally not camel-cased out of solidarity with <code>std::isfinite()</code>.</p> <p>Also available as <code>u.isFinite()</code>.</p> <code>bool isDefined(Vector2 u)</code> <p>Returns true if both of the components of the vector are not NaN.</p> <p>Also available as <code>u.isDefined()</code>.</p>"},{"location":"utilities/vector3/","title":"Vector3","text":"<p><code>geometrycentral::Vector3</code> is the basic 3D vector type in geometry central. There are many like it, but this one is ours.</p> <p><code>#include \"geometrycentral/utilities/vector3.h\"</code></p>"},{"location":"utilities/vector3/#construction","title":"Construction","text":"<p><code>Vector3</code> is a POD type, so you should use brace-initialization sytax:</p> <pre><code>#include \"geometrycentral/utilities/vector3.h\nusing namespace geometrycentral;\n\nVector3 myVec{3.8, 2.9, 1.1}; //create\nmyVec = Vector3{1.1, 2.2, 3.3}; // reassign\n</code></pre> <p>Factory methods can construct a few common values:</p> <code>static Vector3 Vector3::zero()</code> <p>Returns the zero vector</p> <code>static Vector3 Vector3::constant(double c)</code> <p>Returns a vector with all components set to c</p> <code>static Vector3 Vector3::infinity()</code> <p>Returns the infinite vector (\\infty, \\infty, \\infty)(\\infty, \\infty, \\infty).</p> <code>static Vector3 Vector3::undefined()</code> <p>Returns the undefined vector <code>(NaN, NaN, NaN)</code>.</p>"},{"location":"utilities/vector3/#access","title":"Access","text":"<p>The three elements of the vector can be accessed as <code>vec.x</code> and <code>vec.y</code> and <code>vec.z</code>.</p> <p>Alternately, the elements can be indexed as <code>vec[0]</code> and <code>vec[1]</code> and <code>vec[2]</code>.</p>"},{"location":"utilities/vector3/#conversion","title":"Conversion","text":"<code>Vector3::operator&lt;&lt;()</code> <p><code>Vector3</code> can be serialized.</p> <pre><code>Vector3 v{1.2, 3.4, 5.6};\nstd::cout &lt;&lt; v &lt;&lt; std::endl;\n// prints something like: &lt;1.2, 3.4, 5.6&gt;\n</code></pre>"},{"location":"utilities/vector3/#arithmetic","title":"Arithmetic","text":"<p>Vector3 supports the element-wise addition, subtraction, and scalar multiplication you would probably expect.</p>"},{"location":"utilities/vector3/#member-operations","title":"Member operations","text":"<p>These methods do not change the underlying <code>Vector3</code>, but return a new <code>Vector3</code>. <pre><code>Vector3 vec{1., 2., 3.};\nvec.normalize();        // does nothing\nvec = vec.normalize();  // much better\n</code></pre></p> <code>Vector3 Vector3::normalize()</code> <p>Returns a unit-norm vector pointing in the same direction. If the input is the zero vector, the result will contain NaNs.</p> <code>Vector3 Vector3::normalizeCutoff(double mag = 0.)</code> <p>Returns a unit-norm vector with the same direction. If the input has magnitude less <code>&lt;= mag</code>, the vector is unchanged.</p> <code>Vector3 Vector3::unit()</code> <p>Alias for <code>normalize()</code>.</p> <code>Vector3 Vector3::rotateAround(Vector3 axis, double theta)</code> <p>Rotate the vector by angle \\theta\\theta around <code>axis</code> in the right-handed direction. <code>axis</code> need not be a unit vector.</p> <code>Vector3 Vector3::removeComponent(Vector3 unitDir)</code> <p>Removes any component of this vector in the direction <code>unitDir</code>, making the result orthogonal to <code>unitDir</code>. As the name suggests, <code>unitDir</code> must be a unit vector.</p> <code>double Vector3::norm()</code> <p>Returns the magnitude of the vector.</p> <p>Also available as <code>norm(v)</code>.</p> <code>double Vector3::norm2()</code> <p>Returns the squared magnitude of the vector.</p> <p>Also available as <code>norm2(v)</code>.</p>"},{"location":"utilities/vector3/#function-operations","title":"Function operations","text":"<p>These operations do not change the vector on which they are called.</p> <code>double norm(Vector3 v)</code> <p>Returns the magnitude of the vector.</p> <p>Also available as <code>v.norm()</code>.</p> <code>double norm2(Vector3 v)</code> <p>Returns the squared magnitude of the vector.</p> <p>Also available as <code>v.norm2()</code>.</p> <code>Vector3 normalize(Vector3 v)</code> <p>Returns normalized copy of the vector.</p> <code>Vector3 normalizeCutoff(Vector3 v, double mag = 0.)</code> <p>Returns a normalized copy of the vector. If the input has magnitude less <code>&lt;= mag</code>, the vector is unchanged.</p> <code>Vector3 unit(Vector3 v)</code> <p>Alias for <code>normalize(v)</code>.</p> <code>double dot(Vector3 u, Vector3 v)</code> <p>Returns the dot product between two vectors.</p> <code>double sum(Vector3 u)</code> <p>Returns the sum of the coordinates of a vector</p> <code>Vector3 cross(Vector3 u, Vector3 v)</code> <p>Returns the cross product between two vectors.</p> <code>double angle(Vector3 u, Vector3 v)</code> <p>Returns the angle between two not-necessarily-unit vectors. Output in the range [0, \\pi][0, \\pi].</p> <code>double angleInPlane(Vector3 u, Vector3 v, Vector3 normal)</code> <p>Returns the signed angle between two not-necessarily-unit vectors, measured in the plane defined by <code>normal</code> (which need not be a unit vector). Output is in the range [-\\pi, \\pi][-\\pi, \\pi], as in <code>atan2</code>.</p> <code>Vector3 clamp(Vector3 val, Vector3 low, Vector3 high)</code> <p>Returns returns a a vector where each component has been clamped to be between the corresponding compnents of <code>low</code> and <code>high</code>.</p> <code>Vector3 componentwiseMin(Vector3 u, Vector3 v)</code> <p>Returns a new vector, each component of which is the minimum of that component in <code>u</code> and <code>v</code>.</p> <code>Vector3 componentwiseMax(Vector3 u, Vector3 v)</code> <p>Returns a new vector, each component of which is the maximum of that component in <code>u</code> and <code>v</code>.</p>"},{"location":"utilities/vector3/#properties","title":"Properties","text":"<code>bool isfinite(Vector3 u)</code> <p>Returns true if all of the components of the vector are finite.</p> <p>Note: this function is intentionally not camel-cased out of solidarity with <code>std::isfinite()</code>.</p> <p>Also available as <code>u.isFinite()</code>.</p> <code>bool isDefined(Vector3 u)</code> <p>Returns true if all of the components of the vector are not NaN.</p> <p>Also available as <code>u.isDefined()</code>.</p>"}]}