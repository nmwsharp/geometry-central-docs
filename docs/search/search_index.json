{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Geometry Central Geometry-central is a modern C++ library of data structures and algorithms for geometry processing, with a particular focus on surface meshes. Features include: A polished surface mesh class, with efficient support for mesh modification, and a system of containers for associating data with mesh elements. Implementations of canonical geometric quantities on surfaces, ranging from normals and curvatures to tangent vector bases to operators from discrete differential geometry. A suite of powerful algorithms , including computing distances on surface, generating direction fields, and manipulating intrinsic Delaunay triangulations. A coherent set of sparse linear algebra tools , based on Eigen and augmented to automatically utilize better solvers if available on your system. Sample: // Load a mesh std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readSurfaceMesh ( \"spot.obj\" ); // Compute vertex areas VertexData < double > vertexAreas ( * mesh ); geometry -> requireFaceAreas (); for ( Vertex v : mesh -> vertices ()) { double A = 0. ; for ( Face f : v . adjacentFaces ()) { A += geometry -> faceAreas [ f ] / v . degree (); } vertexAreas [ v ] = A ; } For more, see the tutorials . To get started with the code, see building . Use the sample project to get started with a build system and a gui. Related alternatives: CGAL , libIGL , OpenMesh , Polygon Mesh Processing Library , CinoLib Credits Geometry-central is developed by Nicholas Sharp , with many contributions from Keenan Crane , Yousuf Soliman , Mark Gillespie , Rohan Sawhney , and many others. If geometry-central contributes to an academic publication, cite it as: @misc { geometrycentral , title = {geometry-central} , author = {Nicholas Sharp and Keenan Crane and others} , note = {www.geometry-central.net} , year = {2019} } Development of this software was funded in part by NSF Award 1717320, an NSF graduate research fellowship, and gifts from Adobe Research and Autodesk, Inc.","title":"Home"},{"location":"#welcome-to-geometry-central","text":"Geometry-central is a modern C++ library of data structures and algorithms for geometry processing, with a particular focus on surface meshes. Features include: A polished surface mesh class, with efficient support for mesh modification, and a system of containers for associating data with mesh elements. Implementations of canonical geometric quantities on surfaces, ranging from normals and curvatures to tangent vector bases to operators from discrete differential geometry. A suite of powerful algorithms , including computing distances on surface, generating direction fields, and manipulating intrinsic Delaunay triangulations. A coherent set of sparse linear algebra tools , based on Eigen and augmented to automatically utilize better solvers if available on your system. Sample: // Load a mesh std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readSurfaceMesh ( \"spot.obj\" ); // Compute vertex areas VertexData < double > vertexAreas ( * mesh ); geometry -> requireFaceAreas (); for ( Vertex v : mesh -> vertices ()) { double A = 0. ; for ( Face f : v . adjacentFaces ()) { A += geometry -> faceAreas [ f ] / v . degree (); } vertexAreas [ v ] = A ; } For more, see the tutorials . To get started with the code, see building . Use the sample project to get started with a build system and a gui. Related alternatives: CGAL , libIGL , OpenMesh , Polygon Mesh Processing Library , CinoLib Credits Geometry-central is developed by Nicholas Sharp , with many contributions from Keenan Crane , Yousuf Soliman , Mark Gillespie , Rohan Sawhney , and many others. If geometry-central contributes to an academic publication, cite it as: @misc { geometrycentral , title = {geometry-central} , author = {Nicholas Sharp and Keenan Crane and others} , note = {www.geometry-central.net} , year = {2019} } Development of this software was funded in part by NSF Award 1717320, an NSF graduate research fellowship, and gifts from Adobe Research and Autodesk, Inc.","title":"Welcome to Geometry Central"},{"location":"build/building/","text":"Building geometry-central uses CMake for to configure the build system. The basic workflow for downloading and compiling geometry-central via a terminal is: git clone --recurse-submodules https://github.com/nmwsharp/geometry-central.git cd geometry-central mkdir build && cd build cmake -DCMAKE_BUILD_TYPE = Release .. make -j4 However, since geometry-central is just a library, this does not build any executables, it merely compiles the library. You can add geometry-central to an existing project\u2019s CMakeLists.txt like add_subdirectory ( \"path/to/geometry-central\" ) # wherever you put it target_link_libraries ( your-project-target geometry-central ) Example For a simple example project using geometry-central (with Polyscope for visualization), see gc-polyscope-project-template . This is a good starting point for new projects using geometry-central. On Windows When using Visual Studio on Windows, CMake can be used (either via the terminal or gui) to generate Visual Studio project and solution files. The project has been verified to compile out of the box with Visual Studio 2017 & 2019 (older versions not tested). Compile flags & options The library includes a few optional safety checks which are performed at runtime, even in release mode. Such checks are generally very cheap yet quite useful. Nonetheless, adding the NGC_SAFETY_CHECKS define will disable all optional safety checks, for a very small increase in performance.","title":"Building"},{"location":"build/building/#building","text":"geometry-central uses CMake for to configure the build system. The basic workflow for downloading and compiling geometry-central via a terminal is: git clone --recurse-submodules https://github.com/nmwsharp/geometry-central.git cd geometry-central mkdir build && cd build cmake -DCMAKE_BUILD_TYPE = Release .. make -j4 However, since geometry-central is just a library, this does not build any executables, it merely compiles the library. You can add geometry-central to an existing project\u2019s CMakeLists.txt like add_subdirectory ( \"path/to/geometry-central\" ) # wherever you put it target_link_libraries ( your-project-target geometry-central )","title":"Building"},{"location":"build/building/#example","text":"For a simple example project using geometry-central (with Polyscope for visualization), see gc-polyscope-project-template . This is a good starting point for new projects using geometry-central.","title":"Example"},{"location":"build/building/#on-windows","text":"When using Visual Studio on Windows, CMake can be used (either via the terminal or gui) to generate Visual Studio project and solution files. The project has been verified to compile out of the box with Visual Studio 2017 & 2019 (older versions not tested).","title":"On Windows"},{"location":"build/building/#compile-flags-options","text":"The library includes a few optional safety checks which are performed at runtime, even in release mode. Such checks are generally very cheap yet quite useful. Nonetheless, adding the NGC_SAFETY_CHECKS define will disable all optional safety checks, for a very small increase in performance.","title":"Compile flags &amp; options"},{"location":"build/dependencies/","text":"Dependencies geometry-central manages its dependenices via a mix of git submodules, configure-time downloading, and system libraries. However, the build system is explicitly set up such that cloning and building should immediately work on any vaguely reasonable machine, without chasing down dependencies. Remember, clone with: git clone --recurse-submodules https://github.com/nmwsharp/geometry-central.git to ensure you resolve git submodules. If you cloned without submodules, you can get them afterwards with: git submodule update --init --recursive Eigen Eigen is used for linear algebra within geometry-central. Eigen presents a bit of a special challenge as a dependency because many programmers already have Eigen in the project or system, and intermingling multiple copies of Eigen can be problematic. As such, the build system uses the following strategies in order to resolve Eigen: The target Eigen3::Eigen is already defined somewhere. Use the predefined target over any hints from the user Using Eigen in any directory passed via the GC_EIGEN_LOCATION CMake cache variable (empty by default, see note below) Using Eigen from your system libraries, as resolved via find_package(Eigen3 3.3) Downloading a copy of Eigen in to the deps/downloads/ directory For instance, if your project already has a copy of Eigen in its source tree, you can use it with (2) by setting GC_EIGEN_LOCATION . If not, many programmers have installed Eigen, which will be found in (3). Finally, as a last resort the build system will download a copy of Eigen as in (4). geometry-central is known to work with version 3.3 of Eigen; other versions have not been tested (but recent versions probably work). setting GC_EIGEN_LOCATION The joys of CMake: if you are trying to set GC_EIGEN_LOCATION from some higher-level CMake script, you need to set it as a cache variable, which are different from \u2018normal\u2019 variables in CMake. As an example: set ( GC_EIGEN_LOCATION \"full/path/to/eigen\" CACHE PATH \"my path\" ) add_subdirectory ( geometry-central ) Suitesparse Suitesparse is an optional dependency which improves the performance and robustness of geometry-central\u2019s sparse linear solver routines. If Suitesparse is detected at configure time, linear solves will automatically use Suitesparse under the hood, and otherwise they will default to Eigen\u2019s solvers. The output of the CMake script will indicate whether or not Suitesparse was found. At any time, setting the SUITESPARSE CMake variable to false will stop the build system from using Suitesparse, even if it is availble. Installing suitesparse is up to the user. If using homebrew on OSX, brew install suitesparse should be sufficient. On Ubuntu, try apt-get install libsuitesparse-dev . Suitesparse is notoriously difficult to install on Windows\u2014if you find a good method, let us know!","title":"Dependencies"},{"location":"build/dependencies/#dependencies","text":"geometry-central manages its dependenices via a mix of git submodules, configure-time downloading, and system libraries. However, the build system is explicitly set up such that cloning and building should immediately work on any vaguely reasonable machine, without chasing down dependencies. Remember, clone with: git clone --recurse-submodules https://github.com/nmwsharp/geometry-central.git to ensure you resolve git submodules. If you cloned without submodules, you can get them afterwards with: git submodule update --init --recursive","title":"Dependencies"},{"location":"build/dependencies/#eigen","text":"Eigen is used for linear algebra within geometry-central. Eigen presents a bit of a special challenge as a dependency because many programmers already have Eigen in the project or system, and intermingling multiple copies of Eigen can be problematic. As such, the build system uses the following strategies in order to resolve Eigen: The target Eigen3::Eigen is already defined somewhere. Use the predefined target over any hints from the user Using Eigen in any directory passed via the GC_EIGEN_LOCATION CMake cache variable (empty by default, see note below) Using Eigen from your system libraries, as resolved via find_package(Eigen3 3.3) Downloading a copy of Eigen in to the deps/downloads/ directory For instance, if your project already has a copy of Eigen in its source tree, you can use it with (2) by setting GC_EIGEN_LOCATION . If not, many programmers have installed Eigen, which will be found in (3). Finally, as a last resort the build system will download a copy of Eigen as in (4). geometry-central is known to work with version 3.3 of Eigen; other versions have not been tested (but recent versions probably work). setting GC_EIGEN_LOCATION The joys of CMake: if you are trying to set GC_EIGEN_LOCATION from some higher-level CMake script, you need to set it as a cache variable, which are different from \u2018normal\u2019 variables in CMake. As an example: set ( GC_EIGEN_LOCATION \"full/path/to/eigen\" CACHE PATH \"my path\" ) add_subdirectory ( geometry-central )","title":"Eigen"},{"location":"build/dependencies/#suitesparse","text":"Suitesparse is an optional dependency which improves the performance and robustness of geometry-central\u2019s sparse linear solver routines. If Suitesparse is detected at configure time, linear solves will automatically use Suitesparse under the hood, and otherwise they will default to Eigen\u2019s solvers. The output of the CMake script will indicate whether or not Suitesparse was found. At any time, setting the SUITESPARSE CMake variable to false will stop the build system from using Suitesparse, even if it is availble. Installing suitesparse is up to the user. If using homebrew on OSX, brew install suitesparse should be sufficient. On Ubuntu, try apt-get install libsuitesparse-dev . Suitesparse is notoriously difficult to install on Windows\u2014if you find a good method, let us know!","title":"Suitesparse"},{"location":"build/tests/","text":"Building and running tests Compile and run the tests with: cd test mkdir build && cd build cmake -DCMAKE_BUILD_TYPE = Debug .. make -j12 && ./bin/geometry-central-test Tests organization All tests are stored in the test/ subdirectory, which is not touched by the usual build system. googletest We use googletest as a testing framework. Most users do not need the tests, so rather than packing it as a git submodule which would unavoidably be cloned, the build system downloads a binary of the googletest when the tests are built\u2014a consequence is that you must have a network connection to build tests for the first time (TODO: enable using a system install of googletest). Assets The tests/assets/ directory contains a handful of input files for various tests. The absolute paths to these files are baked in to the test executable by the build system, so moving this directory after compiling tests may cause problems. The disk footprint of assets should be kept as small as possible since they are stored in the library repository.","title":"Tests"},{"location":"build/tests/#building-and-running-tests","text":"Compile and run the tests with: cd test mkdir build && cd build cmake -DCMAKE_BUILD_TYPE = Debug .. make -j12 && ./bin/geometry-central-test","title":"Building and running tests"},{"location":"build/tests/#tests-organization","text":"All tests are stored in the test/ subdirectory, which is not touched by the usual build system.","title":"Tests organization"},{"location":"build/tests/#googletest","text":"We use googletest as a testing framework. Most users do not need the tests, so rather than packing it as a git submodule which would unavoidably be cloned, the build system downloads a binary of the googletest when the tests are built\u2014a consequence is that you must have a network connection to build tests for the first time (TODO: enable using a system install of googletest).","title":"googletest"},{"location":"build/tests/#assets","text":"The tests/assets/ directory contains a handful of input files for various tests. The absolute paths to these files are baked in to the test executable by the build system, so moving this directory after compiling tests may cause problems. The disk footprint of assets should be kept as small as possible since they are stored in the library repository.","title":"Assets"},{"location":"build/versions/","text":"Changes in main branch since last version Change the semantics of MeshData<>::size() to match what size() usually means July 3, 2020 This version: Generalize the main halfedge mesh type to support nonmanifold meshes in routines where they make sense. The old HalfedgeMesh is now ManifoldSurfaceMesh , which is a subclass of the new more general SurfaceMesh , offering many of the same operations. The header halfedge_mesh.h typedef\u2019s HalfedgeMesh as ManifoldSurfaceMesh so existing code will mostly still work. Renamed PolygonSoupMesh to SimplePolygonMesh , and simplified some methods of this class. For now, the old type PolygonSoupMesh is typedef\u2019d to SimplePolygonMesh , and the header polygon_soup_mesh.h includes simple_polygon_mesh.h so existing code should work. Please use SimplePolygonMesh in any new code. Renamed PlyHalfedgeMeshData to RichSurfaceMeshData , and changed its workings to apply to more general meshes. Changed underlying storage of MeshData<> containers from std::vector<> to Eigen::VectorX_ . Moved halfedge_containers.h to utilities/mesh_data.h , along with reorganizing various mesh element headers (you shouldn\u2019t need to include any of these headers in user code anyway, just including surface_mesh.h is sufficient)","title":"Versions"},{"location":"build/versions/#changes-in-main-branch-since-last-version","text":"Change the semantics of MeshData<>::size() to match what size() usually means","title":"Changes in main branch since last version"},{"location":"build/versions/#july-3-2020","text":"This version: Generalize the main halfedge mesh type to support nonmanifold meshes in routines where they make sense. The old HalfedgeMesh is now ManifoldSurfaceMesh , which is a subclass of the new more general SurfaceMesh , offering many of the same operations. The header halfedge_mesh.h typedef\u2019s HalfedgeMesh as ManifoldSurfaceMesh so existing code will mostly still work. Renamed PolygonSoupMesh to SimplePolygonMesh , and simplified some methods of this class. For now, the old type PolygonSoupMesh is typedef\u2019d to SimplePolygonMesh , and the header polygon_soup_mesh.h includes simple_polygon_mesh.h so existing code should work. Please use SimplePolygonMesh in any new code. Renamed PlyHalfedgeMeshData to RichSurfaceMeshData , and changed its workings to apply to more general meshes. Changed underlying storage of MeshData<> containers from std::vector<> to Eigen::VectorX_ . Moved halfedge_containers.h to utilities/mesh_data.h , along with reorganizing various mesh element headers (you shouldn\u2019t need to include any of these headers in user code anyway, just including surface_mesh.h is sufficient)","title":"July 3, 2020"},{"location":"numerical/linear_algebra_utilities/","text":"Linear algebra utilities Construct and convert SparseMatrix < T > identityMatrix ( size_t N ) Construct and N x N identity matrix of the requested type. void shiftDiagonal ( SparseMatrix < T >& m , T shiftAmount = 1e-4 ) Shift the diagonal of matrix, by adding A + shiftDiagonal * identityMatrix() . SparseMatrix < T > verticalStack ( const std :: vector < SparseMatrix < T >>& mats ) Vertically stack sparse matrices like A,B,C \\to \\begin{bmatrix} A \\\\ B \\\\ C \\end{bmatrix} A,B,C \\to \\begin{bmatrix} A \\\\ B \\\\ C \\end{bmatrix} all matrices must have the same number of columns. Example: SparseMatrix < double > matA = /* 35 x N */ SparseMatrix < double > matB = /* 10 x N */ SparseMatrix < double > matC = /* 2 x N */ SparseMatrix < double > stacked = verticalStack < double > ({ matA , matB , matC }); SparseMatrix < T > horizontalStack ( const std :: vector < SparseMatrix < T >>& mats ) Vertically stack sparse matrices like A,B,C \\to \\begin{bmatrix} A & B & C \\end{bmatrix} A,B,C \\to \\begin{bmatrix} A & B & C \\end{bmatrix} all matrices must have the same number of rows.. Example: SparseMatrix < double > matA = /* N x 35 */ SparseMatrix < double > matB = /* N x 10 */ SparseMatrix < double > matC = /* N x 2 */ SparseMatrix < double > stacked = horizontalStack < double > ({ matA , matB , matC }); SparseMatrix < double > complexToReal ( const SparseMatrix < std :: complex < double >>& m ) Convert an N x M complex matrix to a 2N x 2M real matrix, expanding each complex component in to a 2 x 2 block to evaluate the complex product. Vector < double > complexToReal ( const Vector < std :: complex < double >>& v ) Convert an length N complex vector to a length 2N real vector, expanding each complex component in to consecutive real and imaginary components. Validate matrix properties void checkFinite ( const Eigen :: Matrix <>& m ) Verify that all entries in an matrix are finite, throwing if not. Defined for all Eigen matrix, vector, and sparse matrix types. void checkSymmetric ( const Eigen :: SparseMatrix <>& m , double absoluteEPS = -1. ) Verify that a matrix is symmetric, throwing if not. Defined for all Eigen sparse matrix types. absoluteEPS is an epsilon to use for the element-wise comparison test. If the default value of -1 is given, a reasonable epsilon is automatically computed from the matrix entries. void checkHermitian ( const Eigen :: SparseMatrix <>& m , double absoluteEPS = -1. ) Verify that a matrix is Hermitian, throwing if not. Defined for all Eigen sparse matrix types. For real matrices, identical to check symmetric. absoluteEPS is an epsilon to use for the element-wise comparison test. If the default value of -1 is given, a reasonable epsilon is automatically computed from the matrix entries. Block decomposition These routines assist with decomposing a square matrix in to interleaved submatrix blocks, where the blocks might not necessarily be contiguous. One common usage is extracting boundary components of a finite element matrix to apply boundary conditions, as in the example below. Example usage: // Hypothetical input data SparseMatrix < double > mat = /* your square matrix */ ; size_t N = mat . rows (); size_t NBoundary = /* ... */ ; Vector < double > rhsVals = Vector < double >:: Zero ( N ); // rhs for the system Vector < double > bcVals = Vector < double >:: Ones ( NBoundary ); // boundary values at // some nodes // Build the membership vector, which indicates which entries should be separated // in to set \"A\" (others are in \"B\") Vector < bool > setAMembership ( N ); for ( size_t i = 0 ; i < N ; i ++ ) { if ( /* element i is boundary */ ) { setAMembership ( i ) = true ; } else { setAMembership ( i ) = false ; } } // Construct the decomposition BlockDecompositionResult < double > decomp = blockDecomposeSquare ( mat , setAMembership , true ); // The four sub-blocks of the matrix are now in // decomp.AA, decomp.AB, decomp.BA, decomp.BB // Split up the rhs vector Vector < double > rhsValsA , rhsValsB ; decomposeVector ( decomp , rhsVals , rhsValsA , rhsValsB ); // Solve problem Vector < double > combinedRHS = rhsValsA - decomp . AB * bcVals ; Vector < double > Aresult = solve ( decomp . AA , combinedRHS ); // Combine the two boundary conditions and interior solution to a full vector Vector < double > result = reassembleVector ( decomp , Aresult , bcVals ); BlockDecompositionResult < T > blockDecomposeSquare ( const SparseMatrix < T >& m , const Vector < bool >& Aset , bool buildBuildBside = true ) Build a block decomposition of a matrix. void decomposeVector ( BlockDecompositionResult < T >& decomp , const Vector < T >& vec , Vector < T >& vecAOut , Vector < T >& vecBOut ) Use an existing block decomposition to partition a vector. Vector < T > reassembleVector ( BlockDecompositionResult < T >& decomp , const Vector < T >& vecA , const Vector < T >& vecB ) Use an existing block decomposition to build a vector from partitioned pieces.","title":"Linear Algebra Utilities"},{"location":"numerical/linear_algebra_utilities/#linear-algebra-utilities","text":"","title":"Linear algebra utilities"},{"location":"numerical/linear_algebra_utilities/#construct-and-convert","text":"SparseMatrix < T > identityMatrix ( size_t N ) Construct and N x N identity matrix of the requested type. void shiftDiagonal ( SparseMatrix < T >& m , T shiftAmount = 1e-4 ) Shift the diagonal of matrix, by adding A + shiftDiagonal * identityMatrix() . SparseMatrix < T > verticalStack ( const std :: vector < SparseMatrix < T >>& mats ) Vertically stack sparse matrices like A,B,C \\to \\begin{bmatrix} A \\\\ B \\\\ C \\end{bmatrix} A,B,C \\to \\begin{bmatrix} A \\\\ B \\\\ C \\end{bmatrix} all matrices must have the same number of columns. Example: SparseMatrix < double > matA = /* 35 x N */ SparseMatrix < double > matB = /* 10 x N */ SparseMatrix < double > matC = /* 2 x N */ SparseMatrix < double > stacked = verticalStack < double > ({ matA , matB , matC }); SparseMatrix < T > horizontalStack ( const std :: vector < SparseMatrix < T >>& mats ) Vertically stack sparse matrices like A,B,C \\to \\begin{bmatrix} A & B & C \\end{bmatrix} A,B,C \\to \\begin{bmatrix} A & B & C \\end{bmatrix} all matrices must have the same number of rows.. Example: SparseMatrix < double > matA = /* N x 35 */ SparseMatrix < double > matB = /* N x 10 */ SparseMatrix < double > matC = /* N x 2 */ SparseMatrix < double > stacked = horizontalStack < double > ({ matA , matB , matC }); SparseMatrix < double > complexToReal ( const SparseMatrix < std :: complex < double >>& m ) Convert an N x M complex matrix to a 2N x 2M real matrix, expanding each complex component in to a 2 x 2 block to evaluate the complex product. Vector < double > complexToReal ( const Vector < std :: complex < double >>& v ) Convert an length N complex vector to a length 2N real vector, expanding each complex component in to consecutive real and imaginary components.","title":"Construct and convert"},{"location":"numerical/linear_algebra_utilities/#validate-matrix-properties","text":"void checkFinite ( const Eigen :: Matrix <>& m ) Verify that all entries in an matrix are finite, throwing if not. Defined for all Eigen matrix, vector, and sparse matrix types. void checkSymmetric ( const Eigen :: SparseMatrix <>& m , double absoluteEPS = -1. ) Verify that a matrix is symmetric, throwing if not. Defined for all Eigen sparse matrix types. absoluteEPS is an epsilon to use for the element-wise comparison test. If the default value of -1 is given, a reasonable epsilon is automatically computed from the matrix entries. void checkHermitian ( const Eigen :: SparseMatrix <>& m , double absoluteEPS = -1. ) Verify that a matrix is Hermitian, throwing if not. Defined for all Eigen sparse matrix types. For real matrices, identical to check symmetric. absoluteEPS is an epsilon to use for the element-wise comparison test. If the default value of -1 is given, a reasonable epsilon is automatically computed from the matrix entries.","title":"Validate matrix properties"},{"location":"numerical/linear_algebra_utilities/#block-decomposition","text":"These routines assist with decomposing a square matrix in to interleaved submatrix blocks, where the blocks might not necessarily be contiguous. One common usage is extracting boundary components of a finite element matrix to apply boundary conditions, as in the example below. Example usage: // Hypothetical input data SparseMatrix < double > mat = /* your square matrix */ ; size_t N = mat . rows (); size_t NBoundary = /* ... */ ; Vector < double > rhsVals = Vector < double >:: Zero ( N ); // rhs for the system Vector < double > bcVals = Vector < double >:: Ones ( NBoundary ); // boundary values at // some nodes // Build the membership vector, which indicates which entries should be separated // in to set \"A\" (others are in \"B\") Vector < bool > setAMembership ( N ); for ( size_t i = 0 ; i < N ; i ++ ) { if ( /* element i is boundary */ ) { setAMembership ( i ) = true ; } else { setAMembership ( i ) = false ; } } // Construct the decomposition BlockDecompositionResult < double > decomp = blockDecomposeSquare ( mat , setAMembership , true ); // The four sub-blocks of the matrix are now in // decomp.AA, decomp.AB, decomp.BA, decomp.BB // Split up the rhs vector Vector < double > rhsValsA , rhsValsB ; decomposeVector ( decomp , rhsVals , rhsValsA , rhsValsB ); // Solve problem Vector < double > combinedRHS = rhsValsA - decomp . AB * bcVals ; Vector < double > Aresult = solve ( decomp . AA , combinedRHS ); // Combine the two boundary conditions and interior solution to a full vector Vector < double > result = reassembleVector ( decomp , Aresult , bcVals ); BlockDecompositionResult < T > blockDecomposeSquare ( const SparseMatrix < T >& m , const Vector < bool >& Aset , bool buildBuildBside = true ) Build a block decomposition of a matrix. void decomposeVector ( BlockDecompositionResult < T >& decomp , const Vector < T >& vec , Vector < T >& vecAOut , Vector < T >& vecBOut ) Use an existing block decomposition to partition a vector. Vector < T > reassembleVector ( BlockDecompositionResult < T >& decomp , const Vector < T >& vecA , const Vector < T >& vecB ) Use an existing block decomposition to build a vector from partitioned pieces.","title":"Block decomposition"},{"location":"numerical/linear_solvers/","text":"This section covers the solvers available in geometry central for sparse linear algebra problems. All solvers support real and complex matrices, and can be templated on a float , double , or std :: complex < double > . #include \"geometrycentral/numerical/linear_solvers.h\" Direct solvers These solvers provide a simple interface for solving sparse linear Ax = b Ax = b . A key feature is that these solvers abstract over the underlying numerical library. In their most basic form, Eigen\u2019s sparse solvers will be used, and are always available. However, if present, the more-powerful Suitesprase solvers will be used intead. See the dependencies section for instruction to build with Suitesparse support. As always, be sure to compile with optimizations for meaningful performance. In particular, Eigen\u2019s built-in solvers will be very slow in debug mode (though the Eigen QR solver is always slow). Quick solves These are one-off routines for quick solves. Vector < T > solve ( SparseMatrix < T >& matrix , const Vector < T >& rhs ) Solve a system with a general matrix. Uses a QR decomposition interally. Warning: The Eigen built-in sparse QR solver is very inefficient for many problems. Also, it doesn\u2019t work well for underdetermined systems. Vector < T > solveSquare ( SparseMatrix < T >& matrix , const Vector < T >& rhs ) Solve a system with a square matrix. Uses an LU decomposition interally. Vector < T > solvePositiveDefinite ( SparseMatrix < T >& matrix , const Vector < T >& rhs ) Solve a system with a symmetric positive (semi-)definite matrix. Uses an LDLT decomposition interally. Retain factorizations When solving many linear systems Ax=b Ax=b with the same matrix A A but different b b , it is dramatically more efficient to retain and reuse the factorization of A A . The following solver classes are stateful, storing the factorization to be re-used for may solves. SparseMatrix < double > A = /* ... some matrix ... */ ; // Build the solver Solver < double > solver ( A ); // Solve a problem Vector < double > rhs1 = /* ... */ ; Vector < double > sol = solver . solve ( rhs1 ); // Solve another problem Vector < double > rhs2 = /* ... */ ; Vector < double > sol2 = solver . solve ( rhs2 ); // Can place solution in existing vector Vector < double > rhs3 = /* ... */ ; solver . solve ( sol , rhs3 ); // Some solvers have extra powers. // Solver<> can compute matrix rank, since it uses QR under the hood. std :: cout << \"matrix rank is \" << solver . rank () << std :: endl ; template < typename < T >> class Solver Solve a system with a general matrix. Uses a QR decomposition interally. Supports methods: Sovler :: Solver ( SparseMatrix < T >& mat ) construct from a matrix Vector < T > Sovler :: solve ( const Vector < T >& rhs ) solve and return result in new vector void Sovler :: solve ( Vector < T >& result , const Vector < T >& rhs ) solve and place result in existing vector size_t Sovler :: rank () report the rank of the matrix. Some solvers may give only an approximate rank. Warning: The Eigen built-in sparse QR solver is very inefficient for many problems. Also, it doesn\u2019t work well for underdetermined systems. template < typename < T >> class SquareSolver Solve a system with a square matrix. Uses an LU decomposition interally. Supports methods: SquareSovler :: Solver ( SparseMatrix < T >& mat ) construct from a matrix Vector < T > SquareSovler :: solve ( const Vector < T >& rhs ) solve and return result in new vector void SquareSovler :: solve ( Vector < T >& result , const Vector < T >& rhs ) solve and place result in existing vector template < typename < T >> class PositiveDefiniteSolver Supports methods: PositiveDefiniteSolver :: Solver ( SparseMatrix < T >& mat ) construct from a matrix Vector < T > PositiveDefiniteSolver :: solve ( const Vector < T >& rhs ) solve and return result in new vector void PositiveDefiniteSolver :: solve ( Vector < T >& result , const Vector < T >& rhs ) solve and place result in existing vector Solve a system with a symmetric positive (semi-)definite matrix. Uses an LDLT decomposition interally. Eigenproblem solvers These routines build on top of the direct solvers to solve eigenvalue problems using power methods. Vector < T > smallestEigenvectorPositiveDefinite ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the smallest-eigenvalue\u2019d nontrivial eigenvector x x of a positive definite sparse matrix A A . std :: vector < Vector < T >> smallestKEigenvectorsPositiveDefinite ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t kEigenvalues , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the first k k smallest-eigenvalue\u2019d nontrivial eigenvectors x x of a positive definite sparse matrix A A . Vector < T > smallestEigenvectorSquare ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the smallest-eigenvalue\u2019d nontrivial eigenvector x x of a square matrix A A . Vector < T > largestEigenvector ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the largest-eigenvalue\u2019d nontrivial eigenvector x x of a square matrix A A . Utilities double residual ( const SparseMatrix < T >& matrix , const Vector < T >& lhs , const Vector < T >& rhs ) Measure the L2 residual of a linear system as ||Ax - b||_2 ||Ax - b||_2 .","title":"Linear Solvers"},{"location":"numerical/linear_solvers/#direct-solvers","text":"These solvers provide a simple interface for solving sparse linear Ax = b Ax = b . A key feature is that these solvers abstract over the underlying numerical library. In their most basic form, Eigen\u2019s sparse solvers will be used, and are always available. However, if present, the more-powerful Suitesprase solvers will be used intead. See the dependencies section for instruction to build with Suitesparse support. As always, be sure to compile with optimizations for meaningful performance. In particular, Eigen\u2019s built-in solvers will be very slow in debug mode (though the Eigen QR solver is always slow).","title":"Direct solvers"},{"location":"numerical/linear_solvers/#quick-solves","text":"These are one-off routines for quick solves. Vector < T > solve ( SparseMatrix < T >& matrix , const Vector < T >& rhs ) Solve a system with a general matrix. Uses a QR decomposition interally. Warning: The Eigen built-in sparse QR solver is very inefficient for many problems. Also, it doesn\u2019t work well for underdetermined systems. Vector < T > solveSquare ( SparseMatrix < T >& matrix , const Vector < T >& rhs ) Solve a system with a square matrix. Uses an LU decomposition interally. Vector < T > solvePositiveDefinite ( SparseMatrix < T >& matrix , const Vector < T >& rhs ) Solve a system with a symmetric positive (semi-)definite matrix. Uses an LDLT decomposition interally.","title":"Quick solves"},{"location":"numerical/linear_solvers/#retain-factorizations","text":"When solving many linear systems Ax=b Ax=b with the same matrix A A but different b b , it is dramatically more efficient to retain and reuse the factorization of A A . The following solver classes are stateful, storing the factorization to be re-used for may solves. SparseMatrix < double > A = /* ... some matrix ... */ ; // Build the solver Solver < double > solver ( A ); // Solve a problem Vector < double > rhs1 = /* ... */ ; Vector < double > sol = solver . solve ( rhs1 ); // Solve another problem Vector < double > rhs2 = /* ... */ ; Vector < double > sol2 = solver . solve ( rhs2 ); // Can place solution in existing vector Vector < double > rhs3 = /* ... */ ; solver . solve ( sol , rhs3 ); // Some solvers have extra powers. // Solver<> can compute matrix rank, since it uses QR under the hood. std :: cout << \"matrix rank is \" << solver . rank () << std :: endl ; template < typename < T >> class Solver Solve a system with a general matrix. Uses a QR decomposition interally. Supports methods: Sovler :: Solver ( SparseMatrix < T >& mat ) construct from a matrix Vector < T > Sovler :: solve ( const Vector < T >& rhs ) solve and return result in new vector void Sovler :: solve ( Vector < T >& result , const Vector < T >& rhs ) solve and place result in existing vector size_t Sovler :: rank () report the rank of the matrix. Some solvers may give only an approximate rank. Warning: The Eigen built-in sparse QR solver is very inefficient for many problems. Also, it doesn\u2019t work well for underdetermined systems. template < typename < T >> class SquareSolver Solve a system with a square matrix. Uses an LU decomposition interally. Supports methods: SquareSovler :: Solver ( SparseMatrix < T >& mat ) construct from a matrix Vector < T > SquareSovler :: solve ( const Vector < T >& rhs ) solve and return result in new vector void SquareSovler :: solve ( Vector < T >& result , const Vector < T >& rhs ) solve and place result in existing vector template < typename < T >> class PositiveDefiniteSolver Supports methods: PositiveDefiniteSolver :: Solver ( SparseMatrix < T >& mat ) construct from a matrix Vector < T > PositiveDefiniteSolver :: solve ( const Vector < T >& rhs ) solve and return result in new vector void PositiveDefiniteSolver :: solve ( Vector < T >& result , const Vector < T >& rhs ) solve and place result in existing vector Solve a system with a symmetric positive (semi-)definite matrix. Uses an LDLT decomposition interally.","title":"Retain factorizations"},{"location":"numerical/linear_solvers/#eigenproblem-solvers","text":"These routines build on top of the direct solvers to solve eigenvalue problems using power methods. Vector < T > smallestEigenvectorPositiveDefinite ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the smallest-eigenvalue\u2019d nontrivial eigenvector x x of a positive definite sparse matrix A A . std :: vector < Vector < T >> smallestKEigenvectorsPositiveDefinite ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t kEigenvalues , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the first k k smallest-eigenvalue\u2019d nontrivial eigenvectors x x of a positive definite sparse matrix A A . Vector < T > smallestEigenvectorSquare ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the smallest-eigenvalue\u2019d nontrivial eigenvector x x of a square matrix A A . Vector < T > largestEigenvector ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the largest-eigenvalue\u2019d nontrivial eigenvector x x of a square matrix A A .","title":"Eigenproblem solvers"},{"location":"numerical/linear_solvers/#utilities","text":"double residual ( const SparseMatrix < T >& matrix , const Vector < T >& lhs , const Vector < T >& rhs ) Measure the L2 residual of a linear system as ||Ax - b||_2 ||Ax - b||_2 .","title":"Utilities"},{"location":"numerical/matrix_types/","text":"Eigen Generally, geometry central uses Eigen for all matrix types. Though we build additional solvers and utilities on top of Eigen. See the Eigen section of dependencies for instructions about getting Eigen and integrating with existing build systems. Note that the Vector2 and Vector3 low-dimensional scalar types are entirely separate from these high-dimensional linear algebra types; Vector2 and Vector3 do not use Eigen, and they cannot participate in arithmetic expressions with Eigen types. Two typedefs are used extensively throughout geometry central to make the default Eigen types slightly less verbose. Both are defined in linear_algebra_utilities.h . #include \"geometrycentral/numerical/linear_algebra_utilities.h\" Vector < T > A templated vector typedef, to Eigen\u2019s vector type. template < typename T > using Vector = Eigen :: Matrix < T , Eigen :: Dynamic , 1 > ; Use like Vector<double> or Vector<bool> . SparseMatrix < T > A templated sparse matrix typedef, to Eigen\u2019s sparse matrix type. template < typename T > using SparseMatrix = Eigen :: SparseMatrix < T > ; Use like SparseMatrix<double> or SparseMatrix<int> . Gotchas Be wary, Eigen\u2019s alignment rules make it efficient, but also impose requirements which can lead to hard-to-debug memory errors. A few particularly common pitfalls are: Avoid intermingling different versions of Eigen in the same program. Suppose some part of you codebase uses one version of Eigen, and a dependency uses a different version. Linking a function which returns an Eigen vector between these versions can lead to segfaults, because different alignment policies were used. Similar to the previous, linking Eigen programs compiled with different preprocessor directives and optimization flags can yield binary incompatibility. Be sure that all parts of your codebase using Eigen receive the same build options. Fixed-sized Eigen types (like Eigen::Vector4d , but not our Vector<T> or SparseMatrix<T> ) may not be passed by value to functions. The same applies transitively to classes which have Eigen types as members. See this (opinionated) note .","title":"Matrix Types"},{"location":"numerical/matrix_types/#eigen","text":"Generally, geometry central uses Eigen for all matrix types. Though we build additional solvers and utilities on top of Eigen. See the Eigen section of dependencies for instructions about getting Eigen and integrating with existing build systems. Note that the Vector2 and Vector3 low-dimensional scalar types are entirely separate from these high-dimensional linear algebra types; Vector2 and Vector3 do not use Eigen, and they cannot participate in arithmetic expressions with Eigen types. Two typedefs are used extensively throughout geometry central to make the default Eigen types slightly less verbose. Both are defined in linear_algebra_utilities.h . #include \"geometrycentral/numerical/linear_algebra_utilities.h\" Vector < T > A templated vector typedef, to Eigen\u2019s vector type. template < typename T > using Vector = Eigen :: Matrix < T , Eigen :: Dynamic , 1 > ; Use like Vector<double> or Vector<bool> . SparseMatrix < T > A templated sparse matrix typedef, to Eigen\u2019s sparse matrix type. template < typename T > using SparseMatrix = Eigen :: SparseMatrix < T > ; Use like SparseMatrix<double> or SparseMatrix<int> .","title":"Eigen"},{"location":"numerical/matrix_types/#gotchas","text":"Be wary, Eigen\u2019s alignment rules make it efficient, but also impose requirements which can lead to hard-to-debug memory errors. A few particularly common pitfalls are: Avoid intermingling different versions of Eigen in the same program. Suppose some part of you codebase uses one version of Eigen, and a dependency uses a different version. Linking a function which returns an Eigen vector between these versions can lead to segfaults, because different alignment policies were used. Similar to the previous, linking Eigen programs compiled with different preprocessor directives and optimization flags can yield binary incompatibility. Be sure that all parts of your codebase using Eigen receive the same build options. Fixed-sized Eigen types (like Eigen::Vector4d , but not our Vector<T> or SparseMatrix<T> ) may not be passed by value to functions. The same applies transitively to classes which have Eigen types as members. See this (opinionated) note .","title":"Gotchas"},{"location":"surface/algorithms/direction_fields/","text":"This section describes routines for computing n-direction fields on a surface. An n-direction field on a surface assigns n evenly-spaced unit tangent vectors to each point on the surface. For example, a 1-direction field is an ordinary direction field, a 2-direction field is a line field, and a 4-direction field is a cross field. Most of these routines only depend on the intrinsic geometry of a surface (via the IntrinsicGeometryInterface ). Therefore, you can run them on abstract geometric domains as well as traditional surfaces in 3D. However, a surface\u2019s principal curvatures depend on the extrinsic geometry, so you can only compute curvature-aligned fields for surfaces in 3D. #include \"geometrycentral/surface/direction_fields.h\" Smoothest Direction Fields These routines compute the smoothest possible n-direction field on the input surface. They place singularities automatically. If you need to find out where the singularities are, refer to the Index Computation section below. The two routines are almost identical. The only difference is that one discretizes direction fields using vectors at vertices, and the other uses vectors on faces. Example #include \"geometrycentral/surface/direction_fields.h\" #include \"geometrycentral/surface/meshio.h\" // Load a mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Compute a smooth direction field on vertices VertexData < Vector2 > directions = computeSmoothestVertexDirectionField ( * geometry ); /* do something useful */ VertexData < Vector2 > computeSmoothestVertexDirectionField ( IntrinsicGeometryInterface & geometry , int nSym = 1 ) Compute the smoothest n-direction field on the input surface. FaceData < Vector2 > computeSmoothestFaceDirectionField ( IntrinsicGeometryInterface & geometry , int nSym = 1 ) Compute the smoothest n-direction field on the input surface. Smoothest Boundary-Aligned Direction Fields This routine works like the previous ones, except it imposes Dirichlet boundary conditions to force the generated direction field to be aligned with the mesh\u2019s boundary. By default, the direction fields are aligned so that one of the field\u2019s vectors is perpendicular to the boundary at each boundary vertex. If you set normalAlign to false then the direction fields are aligned so that one of the field\u2019s vectors is parallel to the boundary instead. A direction field aligned with the boundary of the shape. VertexData < Vector2 > computeSmoothestBoundaryAlignedVertexDirectionField ( IntrinsicGeometryInterface & geometry , bool normalAlign = true , int nSym = 1 ) Compute the smoothest n-direction field on the input surface, but ensures that the field is aligned with the surface\u2019s boundary. FaceData < Vector2 > computeSmoothestBoundaryAlignedFaceDirectionField ( IntrinsicGeometryInterface & geometry , int nSym = 1 ) Compute the smoothest n-direction field on the input surface, but ensures that the field is aligned with the surface\u2019s boundary. Curvature-Aligned Direction Fields These routines compute smooth n-direction fields which align to the input surface\u2019s principal curvatures. Since the principal curvatures form a 4-direction field, these methods only generate 2-direction fields and 4-direction fields. A 4-symmetric, curvature aligned direction field, rendered by tracing streamlines. Principal directions depend on the extrinsic geometry Unlike the previous routines, computeCurvatureAlignedVertexDirectionField cannot operate using only the intrinsic geometry of its input surface. Since a surface\u2019s principal directions depend on its embedding in 3D, these routines must take in an ExtrinsicGeometryInterface . Curvature-alignment only works for 2- and 4-direction fields VertexData<Vector2> computeCurvatureAlignedVertexDirectionField(ExtrinsicGeometryInterface& geometry, int nSym = 2) Compute a smooth n-direction field on the input surface which is aligned to the surface\u2019s principal curvatures. By default, n = 2. FaceData<Vector2> computeCurvatureAlignedFaceDirectionField(ExtrinsicGeometryInterface& geometry, int nSym = 2) Compute a smooth n-direction field on the input surface which is aligned to the surface\u2019s principal curvatures. By default, n = 2. Index Computation These methods compute the index of a given n-direction field at every point of the input mesh. If the direction field is represented by vector at vertices, then the singularities live on faces and vice versa. FaceData<int> computeFaceIndex(IntrinsicGeometryInterface& geometry, const VertexData<Vector2>& directionField, int nSym = 1) Compute the singularities in the input n-direction field. Since the direction field is given as vectors at vertices, the singularities are located on faces. VertexData<int> computeVertexIndex(IntrinsicGeometryInterface& geometry, const FaceData<Vector2>& directionField, int nSym = 1) Compute the singularities in the input n-direction field. Since the direction field is given as vectors at faces, the singularities are located on vertices. Citation These algorithms are described in Globally Optimal Direction Fields , the appropriate citation is: @article { knoppel2013globally , title = {Globally optimal direction fields} , author = {Kn{\\\"o}ppel, Felix and Crane, Keenan and Pinkall, Ulrich and Schr{\\\"o}der, Peter} , journal = {ACM Transactions on Graphics (ToG)} , volume = {32} , number = {4} , pages = {1--10} , year = {2013} , publisher = {ACM New York, NY, USA} }","title":"Direction Fields"},{"location":"surface/algorithms/direction_fields/#smoothest-direction-fields","text":"These routines compute the smoothest possible n-direction field on the input surface. They place singularities automatically. If you need to find out where the singularities are, refer to the Index Computation section below. The two routines are almost identical. The only difference is that one discretizes direction fields using vectors at vertices, and the other uses vectors on faces. Example #include \"geometrycentral/surface/direction_fields.h\" #include \"geometrycentral/surface/meshio.h\" // Load a mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Compute a smooth direction field on vertices VertexData < Vector2 > directions = computeSmoothestVertexDirectionField ( * geometry ); /* do something useful */ VertexData < Vector2 > computeSmoothestVertexDirectionField ( IntrinsicGeometryInterface & geometry , int nSym = 1 ) Compute the smoothest n-direction field on the input surface. FaceData < Vector2 > computeSmoothestFaceDirectionField ( IntrinsicGeometryInterface & geometry , int nSym = 1 ) Compute the smoothest n-direction field on the input surface.","title":"Smoothest Direction Fields"},{"location":"surface/algorithms/direction_fields/#smoothest-boundary-aligned-direction-fields","text":"This routine works like the previous ones, except it imposes Dirichlet boundary conditions to force the generated direction field to be aligned with the mesh\u2019s boundary. By default, the direction fields are aligned so that one of the field\u2019s vectors is perpendicular to the boundary at each boundary vertex. If you set normalAlign to false then the direction fields are aligned so that one of the field\u2019s vectors is parallel to the boundary instead. A direction field aligned with the boundary of the shape. VertexData < Vector2 > computeSmoothestBoundaryAlignedVertexDirectionField ( IntrinsicGeometryInterface & geometry , bool normalAlign = true , int nSym = 1 ) Compute the smoothest n-direction field on the input surface, but ensures that the field is aligned with the surface\u2019s boundary. FaceData < Vector2 > computeSmoothestBoundaryAlignedFaceDirectionField ( IntrinsicGeometryInterface & geometry , int nSym = 1 ) Compute the smoothest n-direction field on the input surface, but ensures that the field is aligned with the surface\u2019s boundary.","title":"Smoothest Boundary-Aligned Direction Fields"},{"location":"surface/algorithms/direction_fields/#curvature-aligned-direction-fields","text":"These routines compute smooth n-direction fields which align to the input surface\u2019s principal curvatures. Since the principal curvatures form a 4-direction field, these methods only generate 2-direction fields and 4-direction fields. A 4-symmetric, curvature aligned direction field, rendered by tracing streamlines. Principal directions depend on the extrinsic geometry Unlike the previous routines, computeCurvatureAlignedVertexDirectionField cannot operate using only the intrinsic geometry of its input surface. Since a surface\u2019s principal directions depend on its embedding in 3D, these routines must take in an ExtrinsicGeometryInterface . Curvature-alignment only works for 2- and 4-direction fields VertexData<Vector2> computeCurvatureAlignedVertexDirectionField(ExtrinsicGeometryInterface& geometry, int nSym = 2) Compute a smooth n-direction field on the input surface which is aligned to the surface\u2019s principal curvatures. By default, n = 2. FaceData<Vector2> computeCurvatureAlignedFaceDirectionField(ExtrinsicGeometryInterface& geometry, int nSym = 2) Compute a smooth n-direction field on the input surface which is aligned to the surface\u2019s principal curvatures. By default, n = 2.","title":"Curvature-Aligned Direction Fields"},{"location":"surface/algorithms/direction_fields/#index-computation","text":"These methods compute the index of a given n-direction field at every point of the input mesh. If the direction field is represented by vector at vertices, then the singularities live on faces and vice versa. FaceData<int> computeFaceIndex(IntrinsicGeometryInterface& geometry, const VertexData<Vector2>& directionField, int nSym = 1) Compute the singularities in the input n-direction field. Since the direction field is given as vectors at vertices, the singularities are located on faces. VertexData<int> computeVertexIndex(IntrinsicGeometryInterface& geometry, const FaceData<Vector2>& directionField, int nSym = 1) Compute the singularities in the input n-direction field. Since the direction field is given as vectors at faces, the singularities are located on vertices.","title":"Index Computation"},{"location":"surface/algorithms/direction_fields/#citation","text":"These algorithms are described in Globally Optimal Direction Fields , the appropriate citation is: @article { knoppel2013globally , title = {Globally optimal direction fields} , author = {Kn{\\\"o}ppel, Felix and Crane, Keenan and Pinkall, Ulrich and Schr{\\\"o}der, Peter} , journal = {ACM Transactions on Graphics (ToG)} , volume = {32} , number = {4} , pages = {1--10} , year = {2013} , publisher = {ACM New York, NY, USA} }","title":"Citation"},{"location":"surface/algorithms/flip_geodesics/","text":"This algorithm takes as input a path (or loop/network of paths) along the edges of a triangle mesh, and as output straightens that path to be a geodesic (i.e. a straight line, or equivalently a locally-shortest path along a surface). The procedure runs in milliseconds, is quite robust, comes with a strong guarantee that no new crossings will be created in the path, and as an added benefit also generates a triangulation on the surface which conforms to the geodesic. Additionally, it even enables the construction of B\u00e9zier curves on a surface. See this repo for a demo application which wraps this implementation as a standalone application with a GUI. This is an implementation of the algorithm described in You Can Find Geodesic Paths in Triangle Meshes by Just Flipping Edges . #include \"geometrycentral/surface/flip_geodesics.h\" Example: #include \"geometrycentral/surface/flip_geodesics.h\" #include \"geometrycentral/surface/meshio.h\" using namespace geometrycentral ; using namespace geometrycentral :: surface ; // Load a mesh std :: unique_ptr < ManifoldSurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readManifoldSurfaceMesh ( \"my_mesh.obj\" ); // Create a path network as a Dijkstra path between endpoints std :: unique_ptr < FlipEdgeNetwork > edgeNetwork ; Vertex vStart = mesh -> vertex ( 0 ); Vertex vEnd = mesh -> vertex ( 7 ); edgeNetwork = FlipEdgeNetwork :: constructFromDijkstraPath ( * mesh , * geometry , vStart , vEnd ); // Make the path a geodesic edgeNetwork -> iterativeShorten (); // Extract the result as a polyline along the surface edgeNetwork -> posGeom = geometry . get (); std :: vector < std :: vector < Vector3 >> polyline = edgeNetwork -> getPathPolyline3D (); Constructing a path network The class stateful class FlipEdgeNetwork encapsulates all functionality in the algorithm; all of the methods below are members functions. This class wraps a SignpostIntrinsicTriangulation (as member FlipEdgeNetwork::tri ), and also manages a path network along the edges of that triangulation. The most direct construct takes as input a sequence of halfedges along the surface which comprise the path. FlipEdgeNetwork :: FlipEdgeNetwork ( ManifoldSurfaceMesh & mesh , IntrinsicGeometryInterface & inputGeom , std :: vector < std :: vector < Halfedge >> paths , VertexData < bool > extraMarkedVerts = VertexData < bool > ()) Construct a network of paths along the surface. mesh : the input manifold triangle mesh inputGeom : the input geometry (as always, a VertexPositionGeometry is valid input) paths : a collection of paths along the surface, each given as an ordered sequence of halfedges extraMarkedVerts : if given, boolean vector of vertices where the path is pinned, and should not be straightened Additionally, several factory methods are provided which assist in constructing a path network from common input data. static std :: unique_ptr < FlipEdgeNetwork > FlipEdgeNetwork :: constructFromDijkstraPath ( ManifoldSurfaceMesh & mesh , IntrinsicGeometryInterface & geom , Vertex startVert , Vertex endVert ) Construct a network consisting of a single path, generated by running Dijkstra\u2019s algorithm between two point. mesh : the input manifold triangle mesh inputGeom : the input geometry (as always, a VertexPositionGeometry is valid input) startVert , endVert : the source and target vertices from which to initialize a Dijkstra path along edges static std :: unique_ptr < FlipEdgeNetwork > FlipEdgeNetwork :: constructFromPiecewiseDijkstraPath ( ManifoldSurfaceMesh & mesh , IntrinsicGeometryInterface & geom , std :: vector < Vertex > points , bool closed = false , bool markInterior = false ) Construct a network consisting of a single path, generated by running Dijkstra\u2019s algorithm between consecutive pairs of vertices. mesh : the input manifold triangle mesh inputGeom : the input geometry (as always, a VertexPositionGeometry is valid input) points : the not-necessarily-adjacent vertices from which to initialize the Dijkstra path, by running Dijkstra\u2019s algorithm between each i\u2019th and (i+1)\u2019th points. closed : if true, the first point will be connected to the last to create a closed loop markInterior : if true, the path will be pinned at the specified points and not shortened there static std :: unique_ptr < FlipEdgeNetwork > FlipEdgeNetwork :: constructFromEdgeSet ( ManifoldSurfaceMesh & mesh , IntrinsicGeometryInterface & geom , const EdgeData < bool >& inPath , const VertexData < bool >& extraMarkedVertices ) Construct a network from a marked set of edges on the mesh. Endpoints, loops, etc are heuristically inferred (e.g. if a path ends at the same vertex it starts at, it is assumed to be a loop). mesh : the input manifold triangle mesh inputGeom : the input geometry (as always, a VertexPositionGeometry is valid input) inPath : a boolean array indicating edges which are in the path extraMarkedVerts : if given, boolean vector of vertices where the path is pinned, and should not be straightened Manipulating paths The key routine is FlipEdgeNetwork::iterativeShorten() , which shortens the path until it is a geodesic by flipping edges in the underlying intrinsic triangulation. void FlipEdgeNetwork :: iterativeShorten ( size_t maxIterations = INVALID_IND , double maxRelativeLengthDecrease = 0. ) Shorten the network to be geodesic. Additional termination conditions can be set to potentially stop the process before the path is a geodesic: maxIterations if set to something other than INVALID_IND , limits the number of iterations maxRelativeLengthDecrease if set to something other than 0 , limits the maximum decrease in length for the network. E.g. 0.5 would mean the resulting network is at at 0.5 * L , where L is the initial length. Importantly, after calling iterativeShorten() , the underlying intrinsic triangulation FlipEdgeNetwork::tri is a triangulation which conforms to the generated geodesics. This triangulation can then be used for subsequent computation, such as solving a PDE which has geodesics as boundary conditions. Geodesic B\u00e9zier curves Once we can shorten curves to geodesics, we can use a de Casteljau-style subdivision scheme to construct geodesic B\u00e9zier curves along a mesh, using a procedure described in \u201cModeling on triangulations with geodesic curves\u201d by Morera et al. (2008). void FlipEdgeNetwork :: bezierSubdivide ( size_t nRounds ) Construct a B\u00e9zier curve from an input control polygon path via iterative subdivision. nRounds specifies the number of subdivision rounds to perform; the curve converges to an exact geodesics as nRounds increases. Setting nRounds=3 is often a good initial choice. Note that the control points of the curve should be marked vertices , as described in the construction section. The algorithm used here is essentially the one described in \u201cModeling on triangulations with geodesic curves\u201d by Morera et al. (2008), but using flip-based geodesics to straighten paths. A geodesic B\u00e9zier curve generated with this method. Improving the triangulation As noted above, we can additionally generate a triangulation which conforms to geodesic curves, but this triangulation will often contain extremely skinny triangles. Performing Delaunay refinement improves the triangle quality for subsequent computation. void FlipEdgeNetwork :: delaunayRefine ( double areaThresh = std :: numeric_limits < double >:: infinity (), size_t maxInsertions = INVALID_IND , double angleBound = 25. ) Perform intrinsic Delaunay refinement on the underlying triangulation to improve its numerical quality while preserving the geodesics. Additional arguments are as in SignpostIntrinsicTriangulation::delaunayRefine() . A geodesic path is introduced, then the triangulation is refined to remove skinny triangles. Output and utilities After running iterativeShorten() , the resulting geodesic paths are represented as a collection edges in an updated intrinsic triangulation. The most common operation is to extract the resulting path network as a polyline along the surface. Note that these routines return a double list; the outer list represents the paths/loops in the network, while the inner list are the points in each path/loop. One option is to get the output as a sequence of surface points , where each is a vertex or a point along some edge in the mesh. std :: vector < std :: vector < SurfacePoint >> FlipEdgeNetwork :: getPathPolyline () Get the path network as a sequence of surface points along the input mesh. std :: vector < std :: vector < SurfacePoint >> FlipEdgeNetwork :: getAllEdgePolyline () Get all edges in the underlying triangulation as a sequence of surface points along the input mesh. A simpler approach is to simply extract the path as a sequence of points in 3D space. To use this approach, you must first set your 3D mesh geometry as the posGeom member. This extra step is necessary because in general, the FlipEdgeNetwork can be applied to meshes which have only edge lengths, but extracting 3D points requires your mesh to have 3D positions. (see the example at the top.) std :: vector < std :: vector < Vector3 >> FlipEdgeNetwork :: getPathPolyline3D () Get the path network as a sequence of points in 3D space. To use this approach, you must first set your 3D mesh geometry as the posGeom member. std :: vector < std :: vector < Vector3 >> FlipEdgeNetwork :: getAllEdgePolyline3D () Get all edges in the underlying intrinsic triangulation as a sequence of points in 3D space. To use this approach, you must first set your 3D mesh geometry as the posGeom member. Additionally, a collection of useful utility functions are provided (see flip_geodesic.h the complete listing). bool FlipEdgeNetwork :: edgeInPath ( Edge e ) Test whether a given edge from the intrinsic triangulation appears in the path. bool FlipEdgeNetwork :: halfedgeInPath ( Halfedge he ) Test whether a given halfedge from the intrinsic triangulation appears in the path. double FlipEdgeNetwork :: length () Measure the total length of the path network. double FlipEdgeNetwork :: minAngleIsotopy () Measure the smallest angle in the path (not blocked by isotopy, aka the constraint that curves do not cross). void FlipEdgeNetwork :: savePathOBJLine ( std :: string filenamePrefix , bool withAll = false ) Write the path to file as line entries in an obj file. Citation If these routines contribute to academic work, please cite: @article { sharp2020you , title = {You can find geodesic paths in triangle meshes by just flipping edges} , author = {Sharp, Nicholas and Crane, Keenan} , journal = {ACM Transactions on Graphics (TOG)} , volume = {39} , number = {6} , pages = {1--15} , year = {2020} , publisher = {ACM New York, NY, USA} }","title":"Flip Geodesics"},{"location":"surface/algorithms/flip_geodesics/#constructing-a-path-network","text":"The class stateful class FlipEdgeNetwork encapsulates all functionality in the algorithm; all of the methods below are members functions. This class wraps a SignpostIntrinsicTriangulation (as member FlipEdgeNetwork::tri ), and also manages a path network along the edges of that triangulation. The most direct construct takes as input a sequence of halfedges along the surface which comprise the path. FlipEdgeNetwork :: FlipEdgeNetwork ( ManifoldSurfaceMesh & mesh , IntrinsicGeometryInterface & inputGeom , std :: vector < std :: vector < Halfedge >> paths , VertexData < bool > extraMarkedVerts = VertexData < bool > ()) Construct a network of paths along the surface. mesh : the input manifold triangle mesh inputGeom : the input geometry (as always, a VertexPositionGeometry is valid input) paths : a collection of paths along the surface, each given as an ordered sequence of halfedges extraMarkedVerts : if given, boolean vector of vertices where the path is pinned, and should not be straightened Additionally, several factory methods are provided which assist in constructing a path network from common input data. static std :: unique_ptr < FlipEdgeNetwork > FlipEdgeNetwork :: constructFromDijkstraPath ( ManifoldSurfaceMesh & mesh , IntrinsicGeometryInterface & geom , Vertex startVert , Vertex endVert ) Construct a network consisting of a single path, generated by running Dijkstra\u2019s algorithm between two point. mesh : the input manifold triangle mesh inputGeom : the input geometry (as always, a VertexPositionGeometry is valid input) startVert , endVert : the source and target vertices from which to initialize a Dijkstra path along edges static std :: unique_ptr < FlipEdgeNetwork > FlipEdgeNetwork :: constructFromPiecewiseDijkstraPath ( ManifoldSurfaceMesh & mesh , IntrinsicGeometryInterface & geom , std :: vector < Vertex > points , bool closed = false , bool markInterior = false ) Construct a network consisting of a single path, generated by running Dijkstra\u2019s algorithm between consecutive pairs of vertices. mesh : the input manifold triangle mesh inputGeom : the input geometry (as always, a VertexPositionGeometry is valid input) points : the not-necessarily-adjacent vertices from which to initialize the Dijkstra path, by running Dijkstra\u2019s algorithm between each i\u2019th and (i+1)\u2019th points. closed : if true, the first point will be connected to the last to create a closed loop markInterior : if true, the path will be pinned at the specified points and not shortened there static std :: unique_ptr < FlipEdgeNetwork > FlipEdgeNetwork :: constructFromEdgeSet ( ManifoldSurfaceMesh & mesh , IntrinsicGeometryInterface & geom , const EdgeData < bool >& inPath , const VertexData < bool >& extraMarkedVertices ) Construct a network from a marked set of edges on the mesh. Endpoints, loops, etc are heuristically inferred (e.g. if a path ends at the same vertex it starts at, it is assumed to be a loop). mesh : the input manifold triangle mesh inputGeom : the input geometry (as always, a VertexPositionGeometry is valid input) inPath : a boolean array indicating edges which are in the path extraMarkedVerts : if given, boolean vector of vertices where the path is pinned, and should not be straightened","title":"Constructing a path network"},{"location":"surface/algorithms/flip_geodesics/#manipulating-paths","text":"The key routine is FlipEdgeNetwork::iterativeShorten() , which shortens the path until it is a geodesic by flipping edges in the underlying intrinsic triangulation. void FlipEdgeNetwork :: iterativeShorten ( size_t maxIterations = INVALID_IND , double maxRelativeLengthDecrease = 0. ) Shorten the network to be geodesic. Additional termination conditions can be set to potentially stop the process before the path is a geodesic: maxIterations if set to something other than INVALID_IND , limits the number of iterations maxRelativeLengthDecrease if set to something other than 0 , limits the maximum decrease in length for the network. E.g. 0.5 would mean the resulting network is at at 0.5 * L , where L is the initial length. Importantly, after calling iterativeShorten() , the underlying intrinsic triangulation FlipEdgeNetwork::tri is a triangulation which conforms to the generated geodesics. This triangulation can then be used for subsequent computation, such as solving a PDE which has geodesics as boundary conditions.","title":"Manipulating paths"},{"location":"surface/algorithms/flip_geodesics/#geodesic-bezier-curves","text":"Once we can shorten curves to geodesics, we can use a de Casteljau-style subdivision scheme to construct geodesic B\u00e9zier curves along a mesh, using a procedure described in \u201cModeling on triangulations with geodesic curves\u201d by Morera et al. (2008). void FlipEdgeNetwork :: bezierSubdivide ( size_t nRounds ) Construct a B\u00e9zier curve from an input control polygon path via iterative subdivision. nRounds specifies the number of subdivision rounds to perform; the curve converges to an exact geodesics as nRounds increases. Setting nRounds=3 is often a good initial choice. Note that the control points of the curve should be marked vertices , as described in the construction section. The algorithm used here is essentially the one described in \u201cModeling on triangulations with geodesic curves\u201d by Morera et al. (2008), but using flip-based geodesics to straighten paths. A geodesic B\u00e9zier curve generated with this method.","title":"Geodesic B\u00e9zier curves"},{"location":"surface/algorithms/flip_geodesics/#improving-the-triangulation","text":"As noted above, we can additionally generate a triangulation which conforms to geodesic curves, but this triangulation will often contain extremely skinny triangles. Performing Delaunay refinement improves the triangle quality for subsequent computation. void FlipEdgeNetwork :: delaunayRefine ( double areaThresh = std :: numeric_limits < double >:: infinity (), size_t maxInsertions = INVALID_IND , double angleBound = 25. ) Perform intrinsic Delaunay refinement on the underlying triangulation to improve its numerical quality while preserving the geodesics. Additional arguments are as in SignpostIntrinsicTriangulation::delaunayRefine() . A geodesic path is introduced, then the triangulation is refined to remove skinny triangles.","title":"Improving the triangulation"},{"location":"surface/algorithms/flip_geodesics/#output-and-utilities","text":"After running iterativeShorten() , the resulting geodesic paths are represented as a collection edges in an updated intrinsic triangulation. The most common operation is to extract the resulting path network as a polyline along the surface. Note that these routines return a double list; the outer list represents the paths/loops in the network, while the inner list are the points in each path/loop. One option is to get the output as a sequence of surface points , where each is a vertex or a point along some edge in the mesh. std :: vector < std :: vector < SurfacePoint >> FlipEdgeNetwork :: getPathPolyline () Get the path network as a sequence of surface points along the input mesh. std :: vector < std :: vector < SurfacePoint >> FlipEdgeNetwork :: getAllEdgePolyline () Get all edges in the underlying triangulation as a sequence of surface points along the input mesh. A simpler approach is to simply extract the path as a sequence of points in 3D space. To use this approach, you must first set your 3D mesh geometry as the posGeom member. This extra step is necessary because in general, the FlipEdgeNetwork can be applied to meshes which have only edge lengths, but extracting 3D points requires your mesh to have 3D positions. (see the example at the top.) std :: vector < std :: vector < Vector3 >> FlipEdgeNetwork :: getPathPolyline3D () Get the path network as a sequence of points in 3D space. To use this approach, you must first set your 3D mesh geometry as the posGeom member. std :: vector < std :: vector < Vector3 >> FlipEdgeNetwork :: getAllEdgePolyline3D () Get all edges in the underlying intrinsic triangulation as a sequence of points in 3D space. To use this approach, you must first set your 3D mesh geometry as the posGeom member. Additionally, a collection of useful utility functions are provided (see flip_geodesic.h the complete listing). bool FlipEdgeNetwork :: edgeInPath ( Edge e ) Test whether a given edge from the intrinsic triangulation appears in the path. bool FlipEdgeNetwork :: halfedgeInPath ( Halfedge he ) Test whether a given halfedge from the intrinsic triangulation appears in the path. double FlipEdgeNetwork :: length () Measure the total length of the path network. double FlipEdgeNetwork :: minAngleIsotopy () Measure the smallest angle in the path (not blocked by isotopy, aka the constraint that curves do not cross). void FlipEdgeNetwork :: savePathOBJLine ( std :: string filenamePrefix , bool withAll = false ) Write the path to file as line entries in an obj file.","title":"Output and utilities"},{"location":"surface/algorithms/flip_geodesics/#citation","text":"If these routines contribute to academic work, please cite: @article { sharp2020you , title = {You can find geodesic paths in triangle meshes by just flipping edges} , author = {Sharp, Nicholas and Crane, Keenan} , journal = {ACM Transactions on Graphics (TOG)} , volume = {39} , number = {6} , pages = {1--15} , year = {2020} , publisher = {ACM New York, NY, USA} }","title":"Citation"},{"location":"surface/algorithms/geodesic_distance/","text":"This section describes algorithms for computing distance along a surface, or geodesic distance. Note that distance depends on the intrinsic geometry of a surface (via the IntrinsicGeometryInterface ). Therefore, these routines can be run on abstract geometric domains as well as traditional surfaces in 3D. Polyhedral Distance TODO document Heat Method for Distance These routines implement the Heat Method for Geodesic Distance . This algorithm uses short time heat flow to compute distance on surfaces. Because the main burden is simply solving linear systems of equations, it tends to be faster than polyhedral schemes, especially when computing distance multiple times on the same surface. In the computational geometry sense, this method is an approximation, as the result is not precisely equal to the polyhedral distance on the surface; nonetheless it is fast and well-suited for many applications. This class supports any (possibly-nonmanifold) triangle mesh as input, and requires only intrinsic geometry (aka edge lengths) to function. Furthermore, it can optionally use robust operators internally to improve performance on low-quality meshes. #include \"geometrycentral/surface/heat_method_distance.h\" Single Solves A one-off utility function is provided which computes the distance from a source vertex using the heat method. Repeated solves or more general source data should use the stateful version below. Example #include \"geometrycentral/surface/heat_method_distance.h\" #include \"geometrycentral/surface/meshio.h\" // Load a mesh std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Pick a vertex Vertex sourceVert = /* some vertex */ // Compute distance VertexData < double > distToSource = heatMethodDistance ( * geometry , sourceVert ); /* do something useful */ VertexData < double > heatMethodDistance ( IntrinsicGeometryInterface & geom , Vertex v ) Compute the distance from the source using the heat method. See the stateful class below for further options. Repeated Solves The stateful class HeatMethodDistanceSolver does precomputation when constructed, then allows many distance solves from different source locations to be performed efficiently. This class also exposes options, like changing the internal short-time parameter, or using a robust operators. The computeDistance() method in HeatMethodDistanceSolver can also take SurfacePoint (s) as the source location(s). A SurfacePoint (see here ) is a location on a surface, which may be a vertex, a point along an edge, or a point inside a face. Example: #include \"geometrycentral/surface/heat_method_distance.h\" #include \"geometrycentral/surface/meshio.h\" // Load a mesh std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Create the Heat Method solver HeatMethodDistanceSolver heatSolver ( * geometry ); // Alternately, set useRobustLaplacian=true to get a robustified version // HeatMethodDistanceSolver heatSolver(*geometry, 1.0, true); // Some vertices as source set std :: vector < Vertex > sourceVerts = /* some interesting vertices */ for ( Vertex v : sourceVerts ) { VertexData < double > distToSource = heatSolver . computeDistance ( v ); /* do something useful */ } // A point in a face as a source set Face sourceF = /* some face */ ; Vector3 sourceFBary = /* some barycentric coords in face */ ; SurfacePoint targetP ( sourceF , sourceFBary ); VertexData < double > distToSource = heatSolver . computeDistance ( targetP ); /* do something useful */ HeatMethodDistanceSolver :: HeatMethodDistanceSolver ( IntrinsicGeometryInterface & geom , double tCoef = 1.0 , bool useRobustLaplacian = false ) Create a new solver to compute geodesic distance using the heat method. All precomputation work is performed immediately at construction time. geom is the geometry (and hence mesh) on which to compute. Note that nearly any geometry object ( VertexPositionGeometry , etc) can be passed here. tCoef is the time to use for short time heat flow, as a factor m * h^2 , where h is the mean edge length. The default value of 1.0 is almost always sufficient. useRobustLaplacian is true, the solver will internally use a robust intrinsic Laplacian, including mollification & tufting for nonmanifold inputs. See \u201cA Laplacian for Nonmanifold Triangle Meshes\u201d [Sharp & Crane 2020 @ SGP] for algorithmic details and citation. Algorithm options (like tCoef ) cannot be changed after construction; create a new solver object with the new settings. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( Vertex v ) Compute the distance from a single source vertex. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( std :: vector < Vertex > verts ) Compute the distance from a set of source vertices. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( SurfacePoint p ) Compute the distance from a single source point. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( std :: vector < SurfacePoint > points ) Compute the distance from a set of source points.","title":"Geodesic Distance"},{"location":"surface/algorithms/geodesic_distance/#polyhedral-distance","text":"TODO document","title":"Polyhedral Distance"},{"location":"surface/algorithms/geodesic_distance/#heat-method-for-distance","text":"These routines implement the Heat Method for Geodesic Distance . This algorithm uses short time heat flow to compute distance on surfaces. Because the main burden is simply solving linear systems of equations, it tends to be faster than polyhedral schemes, especially when computing distance multiple times on the same surface. In the computational geometry sense, this method is an approximation, as the result is not precisely equal to the polyhedral distance on the surface; nonetheless it is fast and well-suited for many applications. This class supports any (possibly-nonmanifold) triangle mesh as input, and requires only intrinsic geometry (aka edge lengths) to function. Furthermore, it can optionally use robust operators internally to improve performance on low-quality meshes. #include \"geometrycentral/surface/heat_method_distance.h\"","title":"Heat Method for Distance"},{"location":"surface/algorithms/geodesic_distance/#single-solves","text":"A one-off utility function is provided which computes the distance from a source vertex using the heat method. Repeated solves or more general source data should use the stateful version below. Example #include \"geometrycentral/surface/heat_method_distance.h\" #include \"geometrycentral/surface/meshio.h\" // Load a mesh std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Pick a vertex Vertex sourceVert = /* some vertex */ // Compute distance VertexData < double > distToSource = heatMethodDistance ( * geometry , sourceVert ); /* do something useful */ VertexData < double > heatMethodDistance ( IntrinsicGeometryInterface & geom , Vertex v ) Compute the distance from the source using the heat method. See the stateful class below for further options.","title":"Single Solves"},{"location":"surface/algorithms/geodesic_distance/#repeated-solves","text":"The stateful class HeatMethodDistanceSolver does precomputation when constructed, then allows many distance solves from different source locations to be performed efficiently. This class also exposes options, like changing the internal short-time parameter, or using a robust operators. The computeDistance() method in HeatMethodDistanceSolver can also take SurfacePoint (s) as the source location(s). A SurfacePoint (see here ) is a location on a surface, which may be a vertex, a point along an edge, or a point inside a face. Example: #include \"geometrycentral/surface/heat_method_distance.h\" #include \"geometrycentral/surface/meshio.h\" // Load a mesh std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Create the Heat Method solver HeatMethodDistanceSolver heatSolver ( * geometry ); // Alternately, set useRobustLaplacian=true to get a robustified version // HeatMethodDistanceSolver heatSolver(*geometry, 1.0, true); // Some vertices as source set std :: vector < Vertex > sourceVerts = /* some interesting vertices */ for ( Vertex v : sourceVerts ) { VertexData < double > distToSource = heatSolver . computeDistance ( v ); /* do something useful */ } // A point in a face as a source set Face sourceF = /* some face */ ; Vector3 sourceFBary = /* some barycentric coords in face */ ; SurfacePoint targetP ( sourceF , sourceFBary ); VertexData < double > distToSource = heatSolver . computeDistance ( targetP ); /* do something useful */ HeatMethodDistanceSolver :: HeatMethodDistanceSolver ( IntrinsicGeometryInterface & geom , double tCoef = 1.0 , bool useRobustLaplacian = false ) Create a new solver to compute geodesic distance using the heat method. All precomputation work is performed immediately at construction time. geom is the geometry (and hence mesh) on which to compute. Note that nearly any geometry object ( VertexPositionGeometry , etc) can be passed here. tCoef is the time to use for short time heat flow, as a factor m * h^2 , where h is the mean edge length. The default value of 1.0 is almost always sufficient. useRobustLaplacian is true, the solver will internally use a robust intrinsic Laplacian, including mollification & tufting for nonmanifold inputs. See \u201cA Laplacian for Nonmanifold Triangle Meshes\u201d [Sharp & Crane 2020 @ SGP] for algorithmic details and citation. Algorithm options (like tCoef ) cannot be changed after construction; create a new solver object with the new settings. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( Vertex v ) Compute the distance from a single source vertex. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( std :: vector < Vertex > verts ) Compute the distance from a set of source vertices. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( SurfacePoint p ) Compute the distance from a single source point. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( std :: vector < SurfacePoint > points ) Compute the distance from a set of source points.","title":"Repeated Solves"},{"location":"surface/algorithms/mesh_graph_algorithms/","text":"","title":"Mesh Graph Algorithms"},{"location":"surface/algorithms/robust_geometry/","text":"Many data structures and algorithms in geometry-central help to \u201crobustify\u201d algorithms, and help them automatically work better on meshes with poor geometry and/or connectivity. Whenever possible, this done in a way which is transparent to the algorithm designer and end user. Intrinsic Mollifiction #include \"geometrycentral/surface/intrinsic_mollification.h\" Poor quality meshes might have triangles whose shape is so close to being degenerate that even basic floating point arithmetic breaks down. Such features are difficult to resolve with by perturbing vertex positions, because a motion that makes one triangle better might make another triangle worse. Fortunately, when working with intrinsic geometry, there is a simple strategy which is always guaranteed to work. To ensure that all triangles are nondegenerate, we want to have l_{ij} + l_{jk} > l_{ki} + \\delta l_{ij} + l_{jk} > l_{ki} + \\delta for all triples of triangle edge lengths, according to some user-specified numerical tolerance \\delta \\delta , which specified how far from degenerate the triangles should be. This is easily achieved by simply adding some small value \\epsilon \\epsilon to all edge lengths, chosen to be the smallest \\epsilon \\epsilon which will make the above inequality hold. This strategy ensures all triangles are non-degenerate, yet yields a negligible change to the mesh\u2019s geometry. For a mesh which already has no degenerate triangles, it will have no effect. Example: #include \"geometrycentral/surface/intrinsic_mollification.h\" using namespace geometrycentral ; using namespace surface ; // your mesh and intrinsic geometry std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < EdgeLengthGeometry > geometry ; // mollify the edge lengths mollifyIntrinsic ( * mesh , geometry -> inputEdgeLengths ); // ensure that any existing quantities are updated for the new edge lengths geometry -> refreshQuantities (); // continue running algorithms, etc geometry -> requireVertexGaussianCurvatures (); for ( Vertex v : mesh -> vertices ()) { std :: cout << \"Gaussian curvature of \" << v << \" is \" << geometry -> vertexGaussianCurvatures [ v ] << std :: endl ; } void mollifyIntrinsic ( SurfaceMesh & mesh , EdgeData < double >& edgeLengths , double relativeFactor = 1e-6 ) Mollify the edge lengths in edgeLengths , to ensure that all triangles are nondegenerate by a factor \\delta \\delta , where \\delta \\delta is computed as relativeFactor times the mean edge length in the input. void mollifyIntrinsicAbsolute ( SurfaceMesh & mesh , EdgeData < double >& edgeLengths , double absoluteFactor ) Similar to above, but mollifies with an absolute factor given by absoluteFactor , rather than a relative factor. This strategy is described in A Laplacian for Nonmanifold Triangle Meshes . The appropriate citation is: @article { Sharp:2020:LNT , author = {Nicholas Sharp and Keenan Crane} , title = {{A Laplacian for Nonmanifold Triangle Meshes}} , journal = {Computer Graphics Forum (SGP)} , volume = {39} , number = {5} , year = {2020} }","title":"Robust Geometry"},{"location":"surface/algorithms/robust_geometry/#intrinsic-mollifiction","text":"#include \"geometrycentral/surface/intrinsic_mollification.h\" Poor quality meshes might have triangles whose shape is so close to being degenerate that even basic floating point arithmetic breaks down. Such features are difficult to resolve with by perturbing vertex positions, because a motion that makes one triangle better might make another triangle worse. Fortunately, when working with intrinsic geometry, there is a simple strategy which is always guaranteed to work. To ensure that all triangles are nondegenerate, we want to have l_{ij} + l_{jk} > l_{ki} + \\delta l_{ij} + l_{jk} > l_{ki} + \\delta for all triples of triangle edge lengths, according to some user-specified numerical tolerance \\delta \\delta , which specified how far from degenerate the triangles should be. This is easily achieved by simply adding some small value \\epsilon \\epsilon to all edge lengths, chosen to be the smallest \\epsilon \\epsilon which will make the above inequality hold. This strategy ensures all triangles are non-degenerate, yet yields a negligible change to the mesh\u2019s geometry. For a mesh which already has no degenerate triangles, it will have no effect. Example: #include \"geometrycentral/surface/intrinsic_mollification.h\" using namespace geometrycentral ; using namespace surface ; // your mesh and intrinsic geometry std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < EdgeLengthGeometry > geometry ; // mollify the edge lengths mollifyIntrinsic ( * mesh , geometry -> inputEdgeLengths ); // ensure that any existing quantities are updated for the new edge lengths geometry -> refreshQuantities (); // continue running algorithms, etc geometry -> requireVertexGaussianCurvatures (); for ( Vertex v : mesh -> vertices ()) { std :: cout << \"Gaussian curvature of \" << v << \" is \" << geometry -> vertexGaussianCurvatures [ v ] << std :: endl ; } void mollifyIntrinsic ( SurfaceMesh & mesh , EdgeData < double >& edgeLengths , double relativeFactor = 1e-6 ) Mollify the edge lengths in edgeLengths , to ensure that all triangles are nondegenerate by a factor \\delta \\delta , where \\delta \\delta is computed as relativeFactor times the mean edge length in the input. void mollifyIntrinsicAbsolute ( SurfaceMesh & mesh , EdgeData < double >& edgeLengths , double absoluteFactor ) Similar to above, but mollifies with an absolute factor given by absoluteFactor , rather than a relative factor. This strategy is described in A Laplacian for Nonmanifold Triangle Meshes . The appropriate citation is: @article { Sharp:2020:LNT , author = {Nicholas Sharp and Keenan Crane} , title = {{A Laplacian for Nonmanifold Triangle Meshes}} , journal = {Computer Graphics Forum (SGP)} , volume = {39} , number = {5} , year = {2020} }","title":"Intrinsic Mollifiction"},{"location":"surface/algorithms/surface_centers/","text":"These routines compute geometric centers of point sets and distrubtions on surfaces. A \u201ccenter\u201d c c is a point on the surface which is a local minimum of the energy: $$ c = \\underset{m}{\\textrm{argmin}}\\sum_{y \\in \\mathcal{Y}} d(m,y)^p $$ where \\mathcal{Y} \\mathcal{Y} is a set of sites to take the average of and d(\\cdot, \\cdot) d(\\cdot, \\cdot) denotes the geodesic distance. Centers on surfaces with p=2 p=2 (\u201cmeans\u201d) are known as Karcher Means or Frechet Means . Centers on surfaces with p=1 p=1 (\u201cmedians\u201d) are known as geometric medians . Centers are not unique! In general, there will not be a single unqiue \u201ccenter\u201d of a point set or distribution on a surface. For nearby sites there may be a single center, but in general this may not be the case. The routines in this section use random initialization to report a center . As such, the results may be different under repeated runs of the procedure. #include \"geometrycentral/surface/surface_centers.h\" Centers of points SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , const std :: vector < Vertex >& vertexPts , int p = 2 ) Find a center of a collection of points at vertices. p must be either 1 1 or 2 2 . SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , VectorHeatMethodSolver & solver , const std :: vector < Vertex >& vertexPts , int p = 2 ) Like the above method, but uses an existing solver object, which saves precomputation. Centers of distributions SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , const VertexData < double >& distribution , int p = 2 ) Find a center of a distribution at vertices. Note that the input distribution is treated as integrated values at vertices. If your distribution is \u201cper-unit-area\u201d, you should multiply times vertex area before passing it in. p must be either 1 1 or 2 2 . SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , VectorHeatMethodSolver & solver , const VertexData < double >& distribution , int p = 2 ) Like the above method, but uses an existing solver object, which saves precomputation. Citation These algorithms are described in The Vector Heat Method , the appropriate citation is: @article { sharp2019vector , title = {The Vector Heat Method} , author = {Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan} , journal = {ACM Transactions on Graphics (TOG)} , volume = {38} , number = {3} , pages = {24} , year = {2019} , publisher = {ACM} }","title":"Surface Centers"},{"location":"surface/algorithms/surface_centers/#centers-of-points","text":"SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , const std :: vector < Vertex >& vertexPts , int p = 2 ) Find a center of a collection of points at vertices. p must be either 1 1 or 2 2 . SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , VectorHeatMethodSolver & solver , const std :: vector < Vertex >& vertexPts , int p = 2 ) Like the above method, but uses an existing solver object, which saves precomputation.","title":"Centers of points"},{"location":"surface/algorithms/surface_centers/#centers-of-distributions","text":"SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , const VertexData < double >& distribution , int p = 2 ) Find a center of a distribution at vertices. Note that the input distribution is treated as integrated values at vertices. If your distribution is \u201cper-unit-area\u201d, you should multiply times vertex area before passing it in. p must be either 1 1 or 2 2 . SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , VectorHeatMethodSolver & solver , const VertexData < double >& distribution , int p = 2 ) Like the above method, but uses an existing solver object, which saves precomputation.","title":"Centers of distributions"},{"location":"surface/algorithms/surface_centers/#citation","text":"These algorithms are described in The Vector Heat Method , the appropriate citation is: @article { sharp2019vector , title = {The Vector Heat Method} , author = {Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan} , journal = {ACM Transactions on Graphics (TOG)} , volume = {38} , number = {3} , pages = {24} , year = {2019} , publisher = {ACM} }","title":"Citation"},{"location":"surface/algorithms/vector_heat_method/","text":"This section describes the Vector Heat Method in geometry-central, which computes parallel transport of vectors using heat flow, and applications that follow from it. Note that these quantities all depend on the intrinsic geometry of a surface (via the IntrinsicGeometryInterface ). Therefore, these routines can be run on abstract geometric domains as well as traditional surfaces in 3D. These algorithms are described in The Vector Heat Method . #include \"geometrycentral/surface/vector_heat_method.h\" Vector Heat Solver The stateful class VectorHeatSolver shares precomputation for all of the routines below. VectorHeatSolver :: VectorHeatSolver ( IntrinsicGeometryInterface & geom , double tCoef = 1.0 ) Create a new solver for the Vector Heat Method. Precomputation is perfrmed lazily as needed. geom is the geometry (and hence mesh) on which to compute. Note that nearly any geometry object ( VertexPositionGeometry , etc) can be passed here. tCoef is the time to use for short time heat flow, as a factor m * h^2 , where h is the mean edge length. The default value of 1.0 is almost always sufficient. Algorithm options (like tCoef ) cannot be changed after construction; create a new solver object with the new settings. Scalar Extension Given scalar data defined at isolated source locations on a surface, extend it to the entire domain. Each point on the domain will take the value of the nearest source point. Example: // your mesh and geometry VertexPositionGeometry geometry ; SurfaceMesh mesh ; // construct a solver VectorHeatSolver vhmSolver ( geometry ); // some interesting source values std :: vector < std :: tuple < Vertex , double >> points ; for ( /* ... some inputs ... */ ) { Vertex sourceVert = /* something */ ; double sourceVal = /* something */ ; points . emplace_back ( sourceVert , sourceVal ); } // solve! VertexData < double > scalarExtension = vhmSolver -> extendScalar ( points ); VertexData < double > VectorHeatSolver :: extendScalar ( const std :: vector < std :: tuple < Vertex , double >>& sources ) Compute the nearest-neighbor extension of scalar data defined at isolated vertices to the entire domain. The input is a list of vertices and their corresponding values. VertexData < double > VectorHeatSolver :: extendScalar ( const std :: vector < std :: tuple < SurfacePoint , double >>& sources ) Compute the nearest-neighbor extension of scalar data defined at isolated points to the entire domain. The input is a list of surface points and their corresponding values. Vector Extension Given tangent vectors defined at one or more isolated source locations on a surface, extend transport the vectors across the entire domain according to parallel transport. Each point on the domain will take the value of the nearest source point. VertexData < Vector2 > VectorHeatSolver :: transportTangentVectors ( Vertex sourceVert , Vector2 sourceVec ) Compute the parallel transport of a vector defined at a single vertex to the entire domain. The input is defined in the tangent space of the source vertex. VertexData < Vector2 > VectorHeatSolver :: transportTangentVectors ( const std :: vector < std :: tuple < Vertex , Vector2 >>& sources ) Compute the parallel transport of vectors defined at a collection of vertices to the entire domain. The input is defined in the tangent space of each the source vertex. VertexData < Vector2 > VectorHeatSolver :: transportTangentVectors ( const std :: vector < std :: tuple < SurfacePoint , Vector2 >>& sources ) Compute the parallel transport of vectors defined at a collection of surface points to the entire domain. The input is defined in the tangent space of each the vertex, face, or edge respectively. Logarithmic Map The logarithmic map is a very special 2D local parameterization of a surface about a point, where for each point on the surface the magnitude of the log map gives the geodesic distance from the source, and the polar coordinate of the log map gives the direction at which a geodesic must leave the source to arrive at the point. These routines compute the logarithmic map using the vector heat method. VertexData < Vector2 > VectorHeatSolver :: computeLogMap ( const Vertex & sourceVert ) Compute the logarithmic map with respect to the given source vertex. The angular coordinate of the log map will be respect to the tangent space of the source vertex. VertexData < Vector2 > VectorHeatSolver :: computeLogMap ( const SurfacePoint & sourceP ) Compute the logarithmic map with respect to the given source point, which is a general surface point . The angular coordinate of the log map will be respect to the tangent space of the source vertex, edge, or face. Citation If these algorithms contribute to academic work, please cite the following paper: @article { sharp2019vector , title = {The Vector Heat Method} , author = {Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan} , journal = {ACM Transactions on Graphics (TOG)} , volume = {38} , number = {3} , pages = {24} , year = {2019} , publisher = {ACM} }","title":"Vector Heat Method"},{"location":"surface/algorithms/vector_heat_method/#vector-heat-solver","text":"The stateful class VectorHeatSolver shares precomputation for all of the routines below. VectorHeatSolver :: VectorHeatSolver ( IntrinsicGeometryInterface & geom , double tCoef = 1.0 ) Create a new solver for the Vector Heat Method. Precomputation is perfrmed lazily as needed. geom is the geometry (and hence mesh) on which to compute. Note that nearly any geometry object ( VertexPositionGeometry , etc) can be passed here. tCoef is the time to use for short time heat flow, as a factor m * h^2 , where h is the mean edge length. The default value of 1.0 is almost always sufficient. Algorithm options (like tCoef ) cannot be changed after construction; create a new solver object with the new settings.","title":"Vector Heat Solver"},{"location":"surface/algorithms/vector_heat_method/#scalar-extension","text":"Given scalar data defined at isolated source locations on a surface, extend it to the entire domain. Each point on the domain will take the value of the nearest source point. Example: // your mesh and geometry VertexPositionGeometry geometry ; SurfaceMesh mesh ; // construct a solver VectorHeatSolver vhmSolver ( geometry ); // some interesting source values std :: vector < std :: tuple < Vertex , double >> points ; for ( /* ... some inputs ... */ ) { Vertex sourceVert = /* something */ ; double sourceVal = /* something */ ; points . emplace_back ( sourceVert , sourceVal ); } // solve! VertexData < double > scalarExtension = vhmSolver -> extendScalar ( points ); VertexData < double > VectorHeatSolver :: extendScalar ( const std :: vector < std :: tuple < Vertex , double >>& sources ) Compute the nearest-neighbor extension of scalar data defined at isolated vertices to the entire domain. The input is a list of vertices and their corresponding values. VertexData < double > VectorHeatSolver :: extendScalar ( const std :: vector < std :: tuple < SurfacePoint , double >>& sources ) Compute the nearest-neighbor extension of scalar data defined at isolated points to the entire domain. The input is a list of surface points and their corresponding values.","title":"Scalar Extension"},{"location":"surface/algorithms/vector_heat_method/#vector-extension","text":"Given tangent vectors defined at one or more isolated source locations on a surface, extend transport the vectors across the entire domain according to parallel transport. Each point on the domain will take the value of the nearest source point. VertexData < Vector2 > VectorHeatSolver :: transportTangentVectors ( Vertex sourceVert , Vector2 sourceVec ) Compute the parallel transport of a vector defined at a single vertex to the entire domain. The input is defined in the tangent space of the source vertex. VertexData < Vector2 > VectorHeatSolver :: transportTangentVectors ( const std :: vector < std :: tuple < Vertex , Vector2 >>& sources ) Compute the parallel transport of vectors defined at a collection of vertices to the entire domain. The input is defined in the tangent space of each the source vertex. VertexData < Vector2 > VectorHeatSolver :: transportTangentVectors ( const std :: vector < std :: tuple < SurfacePoint , Vector2 >>& sources ) Compute the parallel transport of vectors defined at a collection of surface points to the entire domain. The input is defined in the tangent space of each the vertex, face, or edge respectively.","title":"Vector Extension"},{"location":"surface/algorithms/vector_heat_method/#logarithmic-map","text":"The logarithmic map is a very special 2D local parameterization of a surface about a point, where for each point on the surface the magnitude of the log map gives the geodesic distance from the source, and the polar coordinate of the log map gives the direction at which a geodesic must leave the source to arrive at the point. These routines compute the logarithmic map using the vector heat method. VertexData < Vector2 > VectorHeatSolver :: computeLogMap ( const Vertex & sourceVert ) Compute the logarithmic map with respect to the given source vertex. The angular coordinate of the log map will be respect to the tangent space of the source vertex. VertexData < Vector2 > VectorHeatSolver :: computeLogMap ( const SurfacePoint & sourceP ) Compute the logarithmic map with respect to the given source point, which is a general surface point . The angular coordinate of the log map will be respect to the tangent space of the source vertex, edge, or face.","title":"Logarithmic Map"},{"location":"surface/algorithms/vector_heat_method/#citation","text":"If these algorithms contribute to academic work, please cite the following paper: @article { sharp2019vector , title = {The Vector Heat Method} , author = {Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan} , journal = {ACM Transactions on Graphics (TOG)} , volume = {38} , number = {3} , pages = {24} , year = {2019} , publisher = {ACM} }","title":"Citation"},{"location":"surface/geometry/geometry/","text":"While the halfedge mesh encodes the connectivity of a surface, this section covers the classes which sit atop a halfedge mesh to define its geometry . The first section below explains the class structure used to expose geometric logic, and the second section explains the system of automatically-cached quantities. Geometry hierarchy TL;DR Construct a VertexPositionGeometry object using vertex positions; it offers all the geometric routines you would expect, and can be passed to any method that demands geometry. Many algorithms can actually operate on weaker data than vertex positions. Read on to learn more. Geometry central is intentionally designed to allow flexibility in defining the geometry of a surface. Traditional code might assume a 3D position for every vertex, but many algorithms actually need only the intrinsic geometry of a surface, aka the edge lengths. More generally, specifying algorithms to only use the geometric data they really need allows us to seamlessly leverage powerful techniques. We (sparingly) make use of polymorphism via inheritance in C++ to encode a hierarchy of geometric quantities that one might compute for a surface. Interfaces define which quantities can be computed from the geometry; for instance, an EmbeddedGeometryInterface can compute face normals, and it can also compute face areas because it extends the more basic IntrinsicGeometryInterface . Interfaces are abstract, and cannot be instantiated by themselves. Realizations are concrete classes that allow the user instantiate a geometry object from data; for instance, a VertexPositionGeometry can be constructed from vertex positions, and implements the EmbeddedGeometryInterface giving access to a wide range of intrinsic and extrinsic geometric quantities. The following diagram outlines the interfaces and realizations currently available. Quantity management Immediate computation In the most basic usage, realizations can compute simple quantities for a given element directly from input data. For instance, double VertexPositionGeometry::faceArea(Face f) will compute the area of a face. However, this is not the typical intended method for working with geometric quantities in geometry central. Managed quantities A common pattern in geometry code is to maintain precomputed arrays of values that are used repeatedly (e.g. vertex normals). However, naive use of this pattern requires the programmer to coordinate these arrays throughout their codebase, or risk computing and storing the same array many times in distant subroutines. Geometry central embraces this pattern, and provides automatic support for proper use of it. All geometry objects automatically maintain of system of caches for geometric quantities; the user can simply call (for instance) geometry.requireFaceAreas() at the beginning of a subroutine to ensure that the face area buffer is populated, then access geometry.faceAreas[f] in any subsequent code. This strategy keep storage and computation to a minimum by sharing repeated values across any use of the geometry object. The following example demonstrates immediate computation vs cached quantities. VertexPositionGeometry & geometry = /* ... */ ; // bad: immediate computation everywhere for ( Face f : mesh -> faces ()) { Vector3 normal = geometry . faceNormal ( f ); } // good: automatic caching and storage geometry . requireFaceNormals (); for ( Face f : mesh -> faces ()) { Vector3 normal = geometry . faceNormals [ f ]; } In fact, the inheritance in this design allows geometry central to leverage alternate ways of computing a quantity depending on the underlying data available. For instance, face areas are computed for an EdgeLengthGeometry using Heron\u2019s rule, but for a VertexPositionGeometry a faster and more stable edge cross-product is used. Of course, this is all happening under the hood\u2013 the user just needs to call myGeometry.requireFaceAreas() . Dependencies In addition, dependencies between these quantities are managed internally; for instance, if vertex normals are requested, face normals will be internally populated and used to compute vertex normals. However, these dependencies are internal and subject to change; the programmer should always explicitly call geometry.requireFaceNormals() if they intend to access face normals. Updating If the underlying geometric data changes (e.g., vertices are moved or the mesh is mutated), invoking geometry.refreshQuantities() will recompute all required values. Minimizing storage usage To minimize memory usage, invoke geometry.unrequireFaceNormals() at the conclusion of a subroutine to indicate that the quantity is no longer needed, decrementing an internal counter. The quantity is not instantly deleted after being un-required, but invoking geometry.purgeQuantities() will delete any quantities that are not currently required, reducing memory usage. Most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object. Quantity API #include \"geometrycentral/surface/geometry.h\" to get all geometry interfaces. All quantities offer methods and storage following the same naming pattern. For a quantity named YYYs (e.g. faceAreas ), which is defined in an interface GeometryInterface (e.g. IntrinsicGeometry ) the pattern is given below. An exauhstive list is given in quantities . MeshData <> GeometryInterface :: YYYs The member variable array for quantity YYY. Initially empty, but can be populated with requireYYYs() below. For instance, for the quantity face areas, there is a member FaceData<double> IntrinsicGeometry::faceAreas . void GeometryInterface :: requireYYYs () Request that the buffer for quantity YYYs be populated. If it is already populated the method will return right away, otherwise the quantity will be computed. For instance, for the quantity face areas, one would call IntrinsicGeometry::requireFaceAreas() . void GeometryInterface :: unrequireYYYs () Indicate that the buffer for quantity YYYs no longer needs to be populated. Internally decrements a counter; once there is a unrequireYYYs() for every requireYYYs() call, the quantity can be purged by GeometryInterface::purgeQuantities() . For instance, for the quantity face areas, one would call IntrinsicGeometry::unrequireFaceAreas() . Note: most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object. This functionality can be used only if reducing memory usage is very important. T GeometryRealization :: computeYYY ( Element e ) Immediate computation: rather than using the caching system described above, directly compute the value from the input data. Only available for quantities which can be easily computed in O(1) from inputs (e.g. face normals), but not for quantities with significant dependencies (e.g. vertex normals, which depend on all incident face normals). For instance, face areas can be immediately computed with double VertexPositionGeometry::faceArea(Face f) . Note: immediate computation is generally discouraged, prefer using managed quantities instead. In addition, the caching system provides two methods. void GeometryInterface :: refreshQuantities () Recompute all required quantities from the input geometric data. Should be called, for instance if vertices are moved or the underlying mesh is mutated. void GeometryInterface :: purgeQuantities () Delete all cached quantities which are not currently require() \u2018d, reducing memory usage. Note: most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object. This functionality can be used only if reducing memory usage is very important. Interfaces Interfaces are abstract classes which define which quantities are available for a given geometry, and compute/manage caches of these quantities. For the full list of the managed quantities that can be computed by these interfaces, see the quantities section . Base Geometry Base Geometry This is a simple base class which is serves as a parent of all geometry interfaces. It does not actually correspond to any geometric data, and the only quantities it manages are convenience element indices. #include \"geometrycentral/surface/base_geometry_interface.h\" blah? Intrinsic Geometry Intrinsic Geometry Extends BaseGeometryInterface . These quantites depend only on the notion of lengths and angles on the surface, but not how it might sit in space. #include \"geometrycentral/surface/intrinsic_geometry_interface.h\" An intrinsic geometry can be instantiated via any of the realizations which inherit from it: EdgeLengthGeometry VertexPositionGeometry (additionally inherits from the child EmbeddedGeometryInterface ) Extrinsic Geometry Extrinsic Geometry Extends IntrinsicTangentGeometry . These quantites depend on extrinsic angles (like dihedral angles at edges), but are rotation-invariant. #include \"geometrycentral/surface/extrinsic_geometry_interface.h\" An extrinsic geometry can be instantiated via any of the realizations which inherit from it: VertexPositionGeometry (additionally inherits from the child EmbeddedGeometryInterface ) Note that there is not currently any realization which instantiates an ExtrinsicGeometryInterface which is not also an EmbeddedGeometryInterface , but such a realization might one day exist. Embedded Geometry Embedded Geometry Extends ExtrinsicTangentGeometry . These quantites depend explicitly on how the surface sits in 3D space. #include \"geometrycentral/surface/embedded_geometry_interface.h\" An embedded geometry can be instantiated via any of the realizations which inherit from it: VertexPositionGeometry Realizations Realizations construct a geometry object from input data. There are two widely used realizations in geometry central: VertexPositionGeometry and EdgeLengthGeometry . Other realizations of geometry can arise in various contexts, such as the IntrinsicTangentGeometry , which includes both edge lengths and a choice of tangent spaces. In addition to the quantities listed in their own section , the realizations each offer a few immediate computations and some utility functions. Vertex Position Geometry The usual notion of geometry for a mesh, with a position in 3D for each vertex. These positions are stored in the member VertexPositionGeometry::inputVertexPositions . This class inherits from all of the geometry interfaces mentioned above, so all quantities will be available. #include \"geometrycentral/surface/vertex_position_geometry.h\" void VertexPositionGeometry :: VertexPositionGeometry ( VertexData < Vector3 > positions ) Construct a new geometry from vertex positions. The positions input is copied, and stored in the member VertexPositionGeometry::inputVertexPositions . void VertexPositionGeometry :: VertexPositionGeometry ( SurfaceMesh & mesh ) Construct a new geometry for the mesh, with all positions set to the origin Vector3{0., 0., 0.,} . void VertexPositionGeometry :: VertexPositionGeometry ( SurfaceMesh & mesh , const VertexData < Vector3 >& positions ) Construct a new geometry for a mesh from known vertex positions. The positions input is copied, and stored in the member VertexPositionGeometry::inputVertexPositions . void VertexPositionGeometry :: VertexPositionGeometry ( SurfaceMesh & mesh , const Eigen :: MatrixBase < T >& positions ) Construct a new geometry for a mesh from known vertex positions, where the positions are stored as an Eigen matrix. The input matrix should be a Vx3 matrix of floating point values. The Eigen::MatrixBase type is just a generic type which accepts most Eigen matrices as input, including the geometry-central DenseMatrix<> type. std :: unique_ptr < VertexPositionGeometry > VertexPositionGeometry :: copy () Copy the geometry, creating a new identical geometry on the same mesh. Any require() counts or already-computed quantities are not transferred, the new geometry is a blank slate. std :: unique_ptr < VertexPositionGeometry > VertexPositionGeometry :: reinterpretTo ( SurfaceMesh & targetMesh ) Copy the geometry, creating a new identical geometry on targetMesh . The target mesh must be in vertex-correspondence with the input mesh, in the sense that both meshes have the same number of vertices and iterating through the vertex sets yields matching vertices. Any require() counts or already-computed quantities are not transferred, the new geometry is a blank slate. Immediate computations . These routines directly compute geometry quantities from the input data, without touching the caching system. For the full list of available managed quantities, see the quantities section . double VertexPositionGeometry :: edgeLength ( Edge e ) Compute the length of a single edge. double VertexPositionGeometry :: faceArea ( Face f ) Compute the area of a single face. double VertexPositionGeometry :: cornerAngle ( Corner c ) Compute the angle (in radians) formed by the two edges incident on a corner. double VertexPositionGeometry :: halfedgeCotanWeight ( Halfedge he ) Compute the cotangent weight of a hafedge. double VertexPositionGeometry :: edgeCotanWeight ( Edge e ) Compute the cotangent weight of an edge. Vector3 VertexPositionGeometry :: faceNormal ( Face f ) Compute the normal of a face. Edge Length Geometry A weaker notion of geometry where one knows only edge lengths. This data turns out to be sufficient to implement many algorithms in geometry processing, and offers valuable flexibility in defining the geometry. This class inherits from the IntrinsicGeometryInterface , so only intrinsic quantities will be available. #include \"geometrycentral/surface/edge_length_geometry.h\" void EdgeLengthGeometry :: EdgeLengthGeometry ( SurfaceMesh & mesh , EdgeData < double > edgeLengths ) Construct a new geometry for a mesh from known edge lengths. The edgeLengths input is copied, and stored in the member EdgeLengthGeometry::inputEdgeLengths . std :: unique_ptr < EdgeLengthGeometry > EdgeLengthGeometry :: copy () Copy the geometry, creating a new identical geometry on the same mesh. Any require() counts or already-computed quantities are not transferred, the new geometry is a blank slate. std :: unique_ptr < EdgeLengthGeometry > reinterpretTo ( SurfaceMesh & targetMesh ) Copy the geometry, creating a new identical geometry on targetMesh . The target mesh must be in edge-correspondence with the input mesh, in the sense that both meshes have the same number of edges and iterating through the edge sets yields matching edges. Any require() counts or already-computed quantities are not transferred, the new geometry is a blank slate. Immediate computations . These routines directly compute geometry quantities from the input data, without touching the caching system. For the full list of available managed quantities, see the quantities section . double EdgeLengthGeometry :: faceArea ( Face f ) Compute the area of a single face. double EdgeLengthGeometry :: cornerAngle ( Corner c ) Compute the angle (in radians) formed by the two edges incident on a corner. double EdgeLengthGeometry :: halfedgeCotanWeight ( Halfedge he ) Compute the cotangent weight of a hafedge. double EdgeLengthGeometry :: edgeCotanWeight ( Edge e ) Compute the cotangent weight of an edge.","title":"Overview"},{"location":"surface/geometry/geometry/#geometry-hierarchy","text":"TL;DR Construct a VertexPositionGeometry object using vertex positions; it offers all the geometric routines you would expect, and can be passed to any method that demands geometry. Many algorithms can actually operate on weaker data than vertex positions. Read on to learn more. Geometry central is intentionally designed to allow flexibility in defining the geometry of a surface. Traditional code might assume a 3D position for every vertex, but many algorithms actually need only the intrinsic geometry of a surface, aka the edge lengths. More generally, specifying algorithms to only use the geometric data they really need allows us to seamlessly leverage powerful techniques. We (sparingly) make use of polymorphism via inheritance in C++ to encode a hierarchy of geometric quantities that one might compute for a surface. Interfaces define which quantities can be computed from the geometry; for instance, an EmbeddedGeometryInterface can compute face normals, and it can also compute face areas because it extends the more basic IntrinsicGeometryInterface . Interfaces are abstract, and cannot be instantiated by themselves. Realizations are concrete classes that allow the user instantiate a geometry object from data; for instance, a VertexPositionGeometry can be constructed from vertex positions, and implements the EmbeddedGeometryInterface giving access to a wide range of intrinsic and extrinsic geometric quantities. The following diagram outlines the interfaces and realizations currently available.","title":"Geometry hierarchy"},{"location":"surface/geometry/geometry/#quantity-management","text":"","title":"Quantity management"},{"location":"surface/geometry/geometry/#immediate-computation","text":"In the most basic usage, realizations can compute simple quantities for a given element directly from input data. For instance, double VertexPositionGeometry::faceArea(Face f) will compute the area of a face. However, this is not the typical intended method for working with geometric quantities in geometry central.","title":"Immediate computation"},{"location":"surface/geometry/geometry/#managed-quantities","text":"A common pattern in geometry code is to maintain precomputed arrays of values that are used repeatedly (e.g. vertex normals). However, naive use of this pattern requires the programmer to coordinate these arrays throughout their codebase, or risk computing and storing the same array many times in distant subroutines. Geometry central embraces this pattern, and provides automatic support for proper use of it. All geometry objects automatically maintain of system of caches for geometric quantities; the user can simply call (for instance) geometry.requireFaceAreas() at the beginning of a subroutine to ensure that the face area buffer is populated, then access geometry.faceAreas[f] in any subsequent code. This strategy keep storage and computation to a minimum by sharing repeated values across any use of the geometry object. The following example demonstrates immediate computation vs cached quantities. VertexPositionGeometry & geometry = /* ... */ ; // bad: immediate computation everywhere for ( Face f : mesh -> faces ()) { Vector3 normal = geometry . faceNormal ( f ); } // good: automatic caching and storage geometry . requireFaceNormals (); for ( Face f : mesh -> faces ()) { Vector3 normal = geometry . faceNormals [ f ]; } In fact, the inheritance in this design allows geometry central to leverage alternate ways of computing a quantity depending on the underlying data available. For instance, face areas are computed for an EdgeLengthGeometry using Heron\u2019s rule, but for a VertexPositionGeometry a faster and more stable edge cross-product is used. Of course, this is all happening under the hood\u2013 the user just needs to call myGeometry.requireFaceAreas() .","title":"Managed quantities"},{"location":"surface/geometry/geometry/#dependencies","text":"In addition, dependencies between these quantities are managed internally; for instance, if vertex normals are requested, face normals will be internally populated and used to compute vertex normals. However, these dependencies are internal and subject to change; the programmer should always explicitly call geometry.requireFaceNormals() if they intend to access face normals.","title":"Dependencies"},{"location":"surface/geometry/geometry/#updating","text":"If the underlying geometric data changes (e.g., vertices are moved or the mesh is mutated), invoking geometry.refreshQuantities() will recompute all required values.","title":"Updating"},{"location":"surface/geometry/geometry/#minimizing-storage-usage","text":"To minimize memory usage, invoke geometry.unrequireFaceNormals() at the conclusion of a subroutine to indicate that the quantity is no longer needed, decrementing an internal counter. The quantity is not instantly deleted after being un-required, but invoking geometry.purgeQuantities() will delete any quantities that are not currently required, reducing memory usage. Most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object.","title":"Minimizing storage usage"},{"location":"surface/geometry/geometry/#quantity-api","text":"#include \"geometrycentral/surface/geometry.h\" to get all geometry interfaces. All quantities offer methods and storage following the same naming pattern. For a quantity named YYYs (e.g. faceAreas ), which is defined in an interface GeometryInterface (e.g. IntrinsicGeometry ) the pattern is given below. An exauhstive list is given in quantities . MeshData <> GeometryInterface :: YYYs The member variable array for quantity YYY. Initially empty, but can be populated with requireYYYs() below. For instance, for the quantity face areas, there is a member FaceData<double> IntrinsicGeometry::faceAreas . void GeometryInterface :: requireYYYs () Request that the buffer for quantity YYYs be populated. If it is already populated the method will return right away, otherwise the quantity will be computed. For instance, for the quantity face areas, one would call IntrinsicGeometry::requireFaceAreas() . void GeometryInterface :: unrequireYYYs () Indicate that the buffer for quantity YYYs no longer needs to be populated. Internally decrements a counter; once there is a unrequireYYYs() for every requireYYYs() call, the quantity can be purged by GeometryInterface::purgeQuantities() . For instance, for the quantity face areas, one would call IntrinsicGeometry::unrequireFaceAreas() . Note: most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object. This functionality can be used only if reducing memory usage is very important. T GeometryRealization :: computeYYY ( Element e ) Immediate computation: rather than using the caching system described above, directly compute the value from the input data. Only available for quantities which can be easily computed in O(1) from inputs (e.g. face normals), but not for quantities with significant dependencies (e.g. vertex normals, which depend on all incident face normals). For instance, face areas can be immediately computed with double VertexPositionGeometry::faceArea(Face f) . Note: immediate computation is generally discouraged, prefer using managed quantities instead. In addition, the caching system provides two methods. void GeometryInterface :: refreshQuantities () Recompute all required quantities from the input geometric data. Should be called, for instance if vertices are moved or the underlying mesh is mutated. void GeometryInterface :: purgeQuantities () Delete all cached quantities which are not currently require() \u2018d, reducing memory usage. Note: most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object. This functionality can be used only if reducing memory usage is very important.","title":"Quantity API"},{"location":"surface/geometry/geometry/#interfaces","text":"Interfaces are abstract classes which define which quantities are available for a given geometry, and compute/manage caches of these quantities. For the full list of the managed quantities that can be computed by these interfaces, see the quantities section . Base Geometry","title":"Interfaces"},{"location":"surface/geometry/geometry/#base-geometry","text":"This is a simple base class which is serves as a parent of all geometry interfaces. It does not actually correspond to any geometric data, and the only quantities it manages are convenience element indices. #include \"geometrycentral/surface/base_geometry_interface.h\" blah? Intrinsic Geometry","title":"Base Geometry"},{"location":"surface/geometry/geometry/#intrinsic-geometry","text":"Extends BaseGeometryInterface . These quantites depend only on the notion of lengths and angles on the surface, but not how it might sit in space. #include \"geometrycentral/surface/intrinsic_geometry_interface.h\" An intrinsic geometry can be instantiated via any of the realizations which inherit from it: EdgeLengthGeometry VertexPositionGeometry (additionally inherits from the child EmbeddedGeometryInterface ) Extrinsic Geometry","title":"Intrinsic Geometry"},{"location":"surface/geometry/geometry/#extrinsic-geometry","text":"Extends IntrinsicTangentGeometry . These quantites depend on extrinsic angles (like dihedral angles at edges), but are rotation-invariant. #include \"geometrycentral/surface/extrinsic_geometry_interface.h\" An extrinsic geometry can be instantiated via any of the realizations which inherit from it: VertexPositionGeometry (additionally inherits from the child EmbeddedGeometryInterface ) Note that there is not currently any realization which instantiates an ExtrinsicGeometryInterface which is not also an EmbeddedGeometryInterface , but such a realization might one day exist. Embedded Geometry","title":"Extrinsic Geometry"},{"location":"surface/geometry/geometry/#embedded-geometry","text":"Extends ExtrinsicTangentGeometry . These quantites depend explicitly on how the surface sits in 3D space. #include \"geometrycentral/surface/embedded_geometry_interface.h\" An embedded geometry can be instantiated via any of the realizations which inherit from it: VertexPositionGeometry","title":"Embedded Geometry"},{"location":"surface/geometry/geometry/#realizations","text":"Realizations construct a geometry object from input data. There are two widely used realizations in geometry central: VertexPositionGeometry and EdgeLengthGeometry . Other realizations of geometry can arise in various contexts, such as the IntrinsicTangentGeometry , which includes both edge lengths and a choice of tangent spaces. In addition to the quantities listed in their own section , the realizations each offer a few immediate computations and some utility functions.","title":"Realizations"},{"location":"surface/geometry/geometry/#vertex-position-geometry","text":"The usual notion of geometry for a mesh, with a position in 3D for each vertex. These positions are stored in the member VertexPositionGeometry::inputVertexPositions . This class inherits from all of the geometry interfaces mentioned above, so all quantities will be available. #include \"geometrycentral/surface/vertex_position_geometry.h\" void VertexPositionGeometry :: VertexPositionGeometry ( VertexData < Vector3 > positions ) Construct a new geometry from vertex positions. The positions input is copied, and stored in the member VertexPositionGeometry::inputVertexPositions . void VertexPositionGeometry :: VertexPositionGeometry ( SurfaceMesh & mesh ) Construct a new geometry for the mesh, with all positions set to the origin Vector3{0., 0., 0.,} . void VertexPositionGeometry :: VertexPositionGeometry ( SurfaceMesh & mesh , const VertexData < Vector3 >& positions ) Construct a new geometry for a mesh from known vertex positions. The positions input is copied, and stored in the member VertexPositionGeometry::inputVertexPositions . void VertexPositionGeometry :: VertexPositionGeometry ( SurfaceMesh & mesh , const Eigen :: MatrixBase < T >& positions ) Construct a new geometry for a mesh from known vertex positions, where the positions are stored as an Eigen matrix. The input matrix should be a Vx3 matrix of floating point values. The Eigen::MatrixBase type is just a generic type which accepts most Eigen matrices as input, including the geometry-central DenseMatrix<> type. std :: unique_ptr < VertexPositionGeometry > VertexPositionGeometry :: copy () Copy the geometry, creating a new identical geometry on the same mesh. Any require() counts or already-computed quantities are not transferred, the new geometry is a blank slate. std :: unique_ptr < VertexPositionGeometry > VertexPositionGeometry :: reinterpretTo ( SurfaceMesh & targetMesh ) Copy the geometry, creating a new identical geometry on targetMesh . The target mesh must be in vertex-correspondence with the input mesh, in the sense that both meshes have the same number of vertices and iterating through the vertex sets yields matching vertices. Any require() counts or already-computed quantities are not transferred, the new geometry is a blank slate. Immediate computations . These routines directly compute geometry quantities from the input data, without touching the caching system. For the full list of available managed quantities, see the quantities section . double VertexPositionGeometry :: edgeLength ( Edge e ) Compute the length of a single edge. double VertexPositionGeometry :: faceArea ( Face f ) Compute the area of a single face. double VertexPositionGeometry :: cornerAngle ( Corner c ) Compute the angle (in radians) formed by the two edges incident on a corner. double VertexPositionGeometry :: halfedgeCotanWeight ( Halfedge he ) Compute the cotangent weight of a hafedge. double VertexPositionGeometry :: edgeCotanWeight ( Edge e ) Compute the cotangent weight of an edge. Vector3 VertexPositionGeometry :: faceNormal ( Face f ) Compute the normal of a face.","title":"Vertex Position Geometry"},{"location":"surface/geometry/geometry/#edge-length-geometry","text":"A weaker notion of geometry where one knows only edge lengths. This data turns out to be sufficient to implement many algorithms in geometry processing, and offers valuable flexibility in defining the geometry. This class inherits from the IntrinsicGeometryInterface , so only intrinsic quantities will be available. #include \"geometrycentral/surface/edge_length_geometry.h\" void EdgeLengthGeometry :: EdgeLengthGeometry ( SurfaceMesh & mesh , EdgeData < double > edgeLengths ) Construct a new geometry for a mesh from known edge lengths. The edgeLengths input is copied, and stored in the member EdgeLengthGeometry::inputEdgeLengths . std :: unique_ptr < EdgeLengthGeometry > EdgeLengthGeometry :: copy () Copy the geometry, creating a new identical geometry on the same mesh. Any require() counts or already-computed quantities are not transferred, the new geometry is a blank slate. std :: unique_ptr < EdgeLengthGeometry > reinterpretTo ( SurfaceMesh & targetMesh ) Copy the geometry, creating a new identical geometry on targetMesh . The target mesh must be in edge-correspondence with the input mesh, in the sense that both meshes have the same number of edges and iterating through the edge sets yields matching edges. Any require() counts or already-computed quantities are not transferred, the new geometry is a blank slate. Immediate computations . These routines directly compute geometry quantities from the input data, without touching the caching system. For the full list of available managed quantities, see the quantities section . double EdgeLengthGeometry :: faceArea ( Face f ) Compute the area of a single face. double EdgeLengthGeometry :: cornerAngle ( Corner c ) Compute the angle (in radians) formed by the two edges incident on a corner. double EdgeLengthGeometry :: halfedgeCotanWeight ( Halfedge he ) Compute the cotangent weight of a hafedge. double EdgeLengthGeometry :: edgeCotanWeight ( Edge e ) Compute the cotangent weight of an edge.","title":"Edge Length Geometry"},{"location":"surface/geometry/quantities/","text":"This page enumerates the surface geometry quantities available in geometry central. Recall that these quantities are each associated with a geometry interface specifying what can be computed from the given input data. Instantiating a geometry from data, classes like VertexPositionGeometry extend these interfaces and give access to all of the quantities therein. Quantities should usually be accessed via the managed caches , as in the example below. #include \"geometrycentral/surface/geometry.h\" #include \"geometrycentral/surface/meshio.h\" using namespace geometrycentral :: surface ; // Load a mesh and geometry from file std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > positionGeometry ; std :: tie < mesh , positionGeometry > = loadMesh ( \"spot.obj\" ); // For the sake of the example, use an interface type that offers // only the quantities which we will actually use below. IntrinsicGeometryInterface & geometry = * positionGeometry ; // populate the quantity geometry . requireFaceAreas (); for ( Face f : mesh -> faces ()) { // Managed array holding quantity double area = geometry . faceAreas [ f ]; // Immediate computation, computes directly from // input data without touching caches. // Generally discouraged but occasionally useful. area = positionGeometry -> faceArea ( f ); } Indices These quantities are defined for the base BaseGeometryInterface , and will always be available. They are not actually geometric data, but it is convenient to cache the canonical arrays alongside geometric quantities, as they are often used in concert. vertex indices vertex indices A dense 0-based enumeration of vertices. Equivalent to the result of SurfaceMesh::getVertexIndices() . member: VertexData<size_t> BaseGeometryInterface::vertexIndices require: void BaseGeometryInterface::requireVertexIndices() halfedge indices halfedge indices A dense 0-based enumeration of halfedges. Equivalent to the result of SurfaceMesh::getHalfedgeIndices() . member: HalfedgeData<size_t> BaseGeometryInterface::halfedgeIndices require: void BaseGeometryInterface::requireHalfedgeIndices() corner indices corner indices A dense 0-based enumeration of corners. Equivalent to the result of SurfaceMesh::getCornerIndices() . member: CornerData<size_t> BaseGeometryInterface::cornerIndices require: void BaseGeometryInterface::requireCornerIndices() edge indices edge indices A dense 0-based enumeration of edges. Equivalent to the result of SurfaceMesh::getEdgeIndices() . member: EdgeData<size_t> BaseGeometryInterface::edgeIndices require: void BaseGeometryInterface::requireEdgeIndices() face indices face indices A dense 0-based enumeration of faces. Equivalent to the result of SurfaceMesh::getFaceIndices() . member: FaceData<size_t> BaseGeometryInterface::faceIndices require: void BaseGeometryInterface::requireFaceIndices() boundary loop indices boundary loop indices A dense 0-based enumeration of boundary loops . Equivalent to the result of SurfaceMesh::getBoundaryLoopIndices() . member: BoundaryLoopData<size_t> BaseGeometryInterface::boundaryLoopIndices require: void BaseGeometryInterface::requireBoundaryLoopIndices() Lengths, areas, and angles These quantities are defined for any IntrinsicGeometryInterface , which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. edge length edge length The length of an edge in the mesh, as a non-negative real number. member: EdgeData<double> IntrinsicGeometryInterface::edgeLengths require: void IntrinsicGeometryInterface::requireEdgeLengths() The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double VertexPositionGeometry::edgeLength(Edge e) face area face area The area of a face, as a non-negative real number. May be computed from edge lengths via Heron\u2019s formula, or from embedded vertex positions with a cross product. Only valid on triangular meshes. member: FaceData<double> IntrinsicGeometryInterface::faceAreas require: void IntrinsicGeometryInterface::requireFaceAreas() The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry::faceArea(Face f) immediate: double VertexPositionGeometry::faceArea(Face f) vertex dual area vertex dual area An area associated with each vertex, as a non-negative real number. Only valid on triangular meshes. Defined to be 1/3 1/3 the sum of all adjacent face areas. The sum of all vertex dual areas is equal to the usual surface area of the mesh. member: VertexData<double> IntrinsicGeometryInterface::vertexDualAreas require: void IntrinsicGeometryInterface::requireVertexDualAreas() The inline immediate method can be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry::vertexDualArea(Vertex v) immediate: double VertexPositionGeometry::vertexDualArea(Vertex v) corner angles corner angles The angle between incident edges at each corner of a mesh. Only valid on triangular meshes. member: CornerData<double> IntrinsicGeometryInterface::cornerAngles require: void IntrinsicGeometryInterface::requireCornerAngles() The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry::cornerAngle(Corner c) immediate: double VertexPositionGeometry::cornerAngle(Corner c) vertex angle sum vertex angle sum The sum of corner angles around a vertex. Only valid on triangular meshes. member: VertexData<double> IntrinsicGeometryInterface::vertexAngleSums require: void IntrinsicGeometryInterface::requireVertexAngleSums() corner scaled angles corner scaled angles The angle between incident edges at each corner of a mesh, linearly rescaled such that the angles around every vertex sum to 2 \\pi 2 \\pi . At boundary vertices, no scaling will be performed. Only valid on triangular meshes. member: CornerData<double> IntrinsicGeometryInterface::cornerScaledAngles require: void IntrinsicGeometryInterface::requireCornerScaledAngles() halfedge cotan weight halfedge cotan weight The \u201ccotangent weight\u201d of an interior halfedge, defined as \\frac{1}{2} \\cot(\\theta) \\frac{1}{2} \\cot(\\theta) , where \\theta \\theta is the corner angle opposite the halfedge. Defined to be 0 0 for exterior halfedges. Can be computed directly from edge lengths, or more efficiently in an embedded triangle via \\cot(\\theta) = \\frac{u \\cdot v}{||u \\times v||} \\cot(\\theta) = \\frac{u \\cdot v}{||u \\times v||} , where u u and v v are the edge vectors emanating from the opposite corner. Only valid on triangular meshes. member: HalfedgeData<double> IntrinsicGeometryInterface::halfedgeCotanWeights require: void IntrinsicGeometryInterface::requireHalfedgeCotanWeights() The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry::halfedgeCotanWeight(Halfedge he) immediate: double VertexPositionGeometry::halfedgeCotanWeight(Halfedge he) edge cotan weight edge cotan weight The \u201ccotangent weight\u201d of an edge, defined as the sum of halfedge cotan weights for incident interior halfedges. Only valid on triangular meshes. member: EdgeData<double> IntrinsicGeometryInterface::edgeCotanWeights require: void IntrinsicGeometryInterface::requireEdgeCotanWeights() The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry::edgeCotanWeight(Edge e) immediate: double VertexPositionGeometry::edgeCotanWeight(Edge e) Curvatures Different curvatures are available depending on whether geometry is intrinsic or extrinsic. In particular, Gaussian curvature is available for any IntrinsicGeometryInterface (such as EdgeLengthGeometry ), which is the base class of all other geometry objects, whereas mean and principal curvatures are available only from an ExtrinsicGeometryInterface (such as VertexPositionGeometry ). All curvatures are rigid motion invariant. Importantly, Gaussian and mean curvatures correspond to the integral of curvature over a local neighborhood, and are hence scale invariant\u2014to get the pointwise curvatures you should divide by area (see details below). Principal curvatures are pointwise values. See also vertexPrincipalCurvatureDirections , which provides curvature directions (rather than curvature magnitudes). See this video for further background on discrete curvature. vertex Gaussian curvature vertex Gaussian curvature The Gaussian curvature K K at a vertex, defined via the angle defect K_v = 2 \\pi - \\sum \\theta_i K_v = 2 \\pi - \\sum \\theta_i , where \\sum \\theta_i \\sum \\theta_i is the vertexAngleSum as above. Should be interpreted as an integrated Gaussian curvature, giving the total curvature in the neighborhood of the vertex. On a closed surface, the Gauss-Bonnet theorem tells us that the sum of these Gaussian curvatures will be a topological constant given by \\sum_v K_v = 2 \\pi \\chi \\sum_v K_v = 2 \\pi \\chi , where \\chi \\chi is the Euler characteristic of the surface. On surfaces with boundary, the geodesic curvature of the boundary factors in. Only valid on triangular meshes. member: VertexData<double> IntrinsicGeometryInterface::vertexGaussianCurvatures require: void IntrinsicGeometryInterface::requireVertexGaussianCurvatures() The inline immediate method can be used to compute this value directly from input data for a single element: immediate: double VertexPositionGeometry::vertexGaussianCurvature(Vertex v) immediate: double EdgeLengthGeometry::vertexGaussianCurvature(Vertex v) vertex mean curvature vertex mean curvature The mean curvature H H at a vertex i i , defined via the Steiner approximation H_i = \\frac{1}{4}\\sum_{ij} \\theta_{ij} \\ell_{ij} H_i = \\frac{1}{4}\\sum_{ij} \\theta_{ij} \\ell_{ij} , where \\theta_{ij} \\theta_{ij} is the edgeDihedralAngle and \\ell_{ij} \\ell_{ij} is the edgeLength as defined above (and the sum is taken over halfedges extending from i i ). Should be interpreted as an integrated mean curvature (units: m m ), giving the total curvature in the neighborhood of the vertex. A corresponding pointwise mean curvature (units: 1/m 1/m ) can be obtained by dividing by the vertexDualArea . Only valid on triangular meshes. member: VertexData<double> IntrinsicGeometryInterface::vertexMeanCurvatures require: void IntrinsicGeometryInterface::requireVertexMeanCurvatures() The inline immediate method can be used to compute this value directly from input data for a single element: immediate: double VertexPositionGeometry::vertexMeanCurvature(Vertex v) vertex principal curvature vertex principal curvatures The principal curvatures \\kappa_1,\\kappa_2 \\kappa_1,\\kappa_2 at a vertex i i , defined by the relationships K = \\kappa_1\\kappa_2 K = \\kappa_1\\kappa_2 and H = (\\kappa_1+\\kappa_2)/2 H = (\\kappa_1+\\kappa_2)/2 , where H H and K K are the pointwise mean and Gaussian curvatures (resp.). These values are signed, and \\kappa_1 \\kappa_1 is always the smaller curvature in value , but not necessarily the smaller one in magnitude (e.g., \\kappa_1 \\kappa_1 could be a very large negative value, and \\kappa_2 \\kappa_2 could be a very small positive value). These quantities can be interpreted as pointwise quantities (units: 1/m 1/m ), approximating the maximum and minimum bending the neighborhood of the vertex. Only valid on triangular meshes. member: VertexData<double> IntrinsicGeometryInterface::vertexMinPrincipalCurvatures require: void IntrinsicGeometryInterface::requireVertexMinPrincipalCurvatures() member: VertexData<double> IntrinsicGeometryInterface::vertexMaxPrincipalCurvatures require: void IntrinsicGeometryInterface::requireVertexMaxPrincipalCurvatures() The inline immediate methods can be used to compute this value directly from input data for a single element: immediate: double VertexPositionGeometry::vertexMinPrincipalCurvature(Vertex v) immediate: double VertexPositionGeometry::vertexMaxPrincipalCurvature(Vertex v) face Gaussian curvature face Gaussian curvature The Gaussian curvature K K at a face, defined via the rescaled angle defect in the face K_f = \\pi - \\sum \\tilde{\\theta}_i K_f = \\pi - \\sum \\tilde{\\theta}_i , where \\tilde{\\theta}_i \\tilde{\\theta}_i are the rescaled corner angles (as in cornerScaledAngles ) incident on the face. Should be interpreted as an integrated Gaussian curvature, giving the total curvature inside of the face. A corresponding curvature-per-unit-area can be computed by dividing by the area of the face. On a closed surface, the Gauss-Bonnet theorem tells us that the sum of these Gaussian curvatures will be a topological constant given by \\sum_f K_f = 2 \\pi \\chi \\sum_f K_f = 2 \\pi \\chi , where \\chi \\chi is the Euler characteristic of the surface. On surfaces with boundary, the geodesic curvature of the boundary factors in. Only valid on triangular meshes. member: FaceData<double> IntrinsicGeometryInterface::faceGaussianCurvatures require: void IntrinsicGeometryInterface::requireFaceGaussianCurvatures() Tangent vectors and transport These quantities are defined for any IntrinsicGeometryInterface , which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. Tangent vectors and transport are defined in terms of tangent spaces at faces and vertices, as defined below. Recall that our Vector2 types obey the multiplication and division rules of complex arithmetic, and thus can be used to represent rotations. For instance, a 2D vector representing a rotation can be used to rotate another vector like: Vector2 v = /* your vector */ Vector2 r = Vector2 { std :: cos ( PI / 4 ), std :: sin ( PI / 4 )}; // rotation by 45 degrees Vector2 vRot = r * v ; This is fundamentally no different from using 2x2 rotation matrices, but leads to much cleaner code (try using division to compute relative rotations!). Face tangent spaces To represent vectors that sit in flat mesh faces, we define a 2D coordinate frame tangent to each face. By default, this frame is aligned such that face.halfedge() points along the x x -axis (but subclasses might change this convention). All vectors in faces are then expressed via (x,y) (x,y) Vector2D coordinates in this frame. Crucially, this basis is well-defined even if the geometry does not have vertex positions. See face tangent basis to convert these vectors to world coordinates (if your mesh has vertex positions). halfedge vectors in face halfedge vectors in face Vectors for each halfedge in the coordinate frame of the face in which they sit. See the description of face tangent spaces above for a definition. Only valid on triangular meshes. member: HalfedgeData<Vector2> IntrinsicGeometryInterface::halfedgeVectorsInFace require: void IntrinsicGeometryInterface::requireHalfedgeVectorsInFace() transport vector across halfedge transport vector across halfedge Rotations which transport tangent vectors across a halfedge, rotating a vector from the tangent space of halfedge.face() to the tangent space halfedge.twin().face() . Always a unit vector, which can be multiplied by any other vector to compute the rotation. (recall our Vector2 s multiply like complex numbers) Only valid on triangular meshes. Not defined for halfedges (interior or exterior) incident on boundary edges, these boundary values are set to NaN so errors can be caught quickly. member: HalfedgeData<Vector2> IntrinsicGeometryInterface::transportVectorAcrossHalfedge require: void IntrinsicGeometryInterface::requireTransportVectorAcrossHalfedge() Example usage: geometry . requireTransportVectorAcrossHalfedge (); Face f = /* ... */ ; // a face of interest Vector2 myVec = /* ... */ ; // tangent vector in face f for ( Halfedge he : f . adjacentHalfedges ()) { Vertex neighborFace = he . twin (). face (); Vector2 rot = geometry . transportVectorAcrossHalfedge [ he ]; Vector2 neighVec = rot * myVec ; // now in the basis of neighborFace } Vertex tangent spaces To represent vectors that sit at mesh faces, we consider a polar coordinate frame at each vertex. This frame is defined by measuring angles according to the rescaled corner angles as in cornerScaledAngles . By default, this frame is aligned such that vertex.halfedge() points along the \\phi=0 \\phi=0 x x -axis (but subclasses might change this convention). Of course, rather than using polar coordinates we can equivalently work in the corresponding Cartesian frame\u2014tangent vectors at vertices are then expressed via (x,y) (x,y) Vector2D coordinates in this frame. Crucially, this basis does not require picking a vertex normal, and is well-defined even if the geometry does not have vertex positions. See vertex tangent basis to convert these tangent vectors to world coordinates (if your mesh has vertex positions). halfedge vectors in vertex halfedge vectors in vertex Vectors for each halfedge in the coordinate frame of the vertex from which the emanate (in halfedge.vertex() ). See the description of vertex tangent spaces above for a definition. Only valid on triangular meshes. member: HalfedgeData<Vector2> IntrinsicGeometryInterface::halfedgeVectorsInVertex require: void IntrinsicGeometryInterface::requireHalfedgeVectorsInVertex() transport vector along halfedge transport vector along halfedge Rotations which transport tangent vectors along a halfedge, rotating a vector from the tangent space of halfedge.vertex() to the tangent space halfedge.twin().vertex() . Always a unit vector, which can be multiplied by any other vector to compute the rotation. (recall our Vector2 s multiply like complex numbers) Only valid on triangular meshes. member: HalfedgeData<Vector2> IntrinsicGeometryInterface::transportVectorAlongHalfedge require: void IntrinsicGeometryInterface::requireTransportVectorAlongHalfedge() Example usage: geometry . requireTransportVectorAlongHalfedge (); Vertex v = /* ... */ ; // a vertex of interest Vector2 myVec = /* ... */ ; // tangent vector in vertex v for ( Halfedge he : v . outgoingHalfedges ()) { Vertex neighborVertex = he . twin (). vertex (); Vector2 rot = geometry . transportVectorAlongHalfedge [ he ]; Vector2 neighVec = rot * myVec ; // now in the basis of neighborVertex } Operators These quantities are defined for any IntrinsicGeometryInterface , which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. A full explanation of these operators is beyond the scope of these docs; see these course notes for one introduction. All operators are indexed over mesh elements according to the natural iteration order of the elements, or equivalently the indices from SurfaceMesh::getVertexIndices() (etc). cotangent Laplacian cotangent laplacian The discrete Laplace operator, discretized via cotangent weights. A |V| \\times |V| |V| \\times |V| real matrix. Always symmetric and positive semi-definite. If and only the underlying geometry is Delaunay , the matrix will furthermore have all negative off-diagonal entries, satisfy a maximum principle, and be an M-matrix . This is the weak Laplace operator, if we use it to evalutae \\mathsf{y} \\leftarrow \\mathsf{L} \\mathsf{x} \\mathsf{y} \\leftarrow \\mathsf{L} \\mathsf{x} , \\mathsf{x} \\mathsf{x} should hold pointwise quantities at vertices, and the result \\mathsf{y} \\mathsf{y} will contain integrated values of the result in the neighborhood of each vertex. If used to solve a Poisson problem, a mass matrix (such as the lumped or Galerkin mass matrices below) are likely necessary on the right hand side. Only valid on triangular meshes. member: Eigen::SparseMatrix<double> IntrinsicGeometryInterface::laplacian require: void IntrinsicGeometryInterface::requireLaplacian() vertex lumped mass matrix vertex lumped mass matrix A mass matrix at vertices, where vertex area is 1/3 1/3 the incident face areas as in vertexDualAreas . A |V| \\times |V| |V| \\times |V| real diagonal matrix. Generally less-accurate than the Galerkin mass matrix below, but can be easily inverted since it is a diagonal matrix. Only valid on triangular meshes. member: Eigen::SparseMatrix<double> IntrinsicGeometryInterface::vertexLumpedMassMatrix require: void IntrinsicGeometryInterface::requireVertexLumpedMassMatrix() vertex Galerkin mass matrix vertex Galerkin mass matrix A mass matrix at vertices, supported at all neighbors of a vertex via integration of piecewise-linear elements. A |V| \\times |V| |V| \\times |V| real matrix. Generally more accurate than the lumped mass matrix above, should be preferred unless the mass matrix needs to be inverted. Only valid on triangular meshes. member: Eigen::SparseMatrix<double> IntrinsicGeometryInterface::vertexGalerkinMassMatrix require: void IntrinsicGeometryInterface::requireVertexGalerkinMassMatrix() vertex connection Laplacian vertex connection Laplacian A discrete connection Laplacian operator, which applies to vector fields defined in vertex tangent spaces. Essentially defined as the scalar cotangent Laplacian, augmented with rotations given by the rotations in transportVectorAlongHalfedge ; see The Vector Heat Method, Sec 5.3 for more explanation and definition. A |V| \\times |V| |V| \\times |V| complex matrix. Always Hermitian, but positive semi-definite if and only the underlying geometry is Delaunay . This is a weak Laplace operator, the application of which outputs integrated values in vertex neighborhood. Given a complex vector \\mathsf{x} \\mathsf{x} of tangent vectors at vertices, apply the operator by multiplying \\mathsf{L} * \\mathsf{x} \\mathsf{L} * \\mathsf{x} . Only valid on triangular meshes. member: Eigen::SparseMatrix<double> IntrinsicGeometryInterface::vertexGalerkinMassMatrix require: void IntrinsicGeometryInterface::requireVertexGalerkinMassMatrix() DEC operators DEC operators These operators are the basic building blocks for discrete exterior calculus on surfaces. Note: These quantities slightly deviate from the usual naming scheme for quantities. Rather than requireD0() , requireD1() , etc, there is a single requireDECOperators() function which manages all 8 of the members listed below. The following members are constructed: Eigen::SparseMatrix<double> IntrinsicGeometryInterface::hodge0 A |V| \\times |V| |V| \\times |V| diagonal matrix Eigen::SparseMatrix<double> IntrinsicGeometryInterface::hodge0Inverse A |V| \\times |V| |V| \\times |V| diagonal matrix Eigen::SparseMatrix<double> IntrinsicGeometryInterface::hodge1 An |E| \\times |E| |E| \\times |E| diagonal matrix Eigen::SparseMatrix<double> IntrinsicGeometryInterface::hodge1Inverse An |E| \\times |E| |E| \\times |E| diagonal matrix Eigen::SparseMatrix<double> IntrinsicGeometryInterface::hodge2 An |F| \\times |F| |F| \\times |F| diagonal matrix Eigen::SparseMatrix<double> IntrinsicGeometryInterface::hodge2Inverse An |F| \\times |F| |F| \\times |F| diagonal matrix Eigen::SparseMatrix<double> IntrinsicGeometryInterface::d0 An |E| \\times |V| |E| \\times |V| matrix with \\{-1, 0, 1\\} \\{-1, 0, 1\\} entries Eigen::SparseMatrix<double> IntrinsicGeometryInterface::d1 An |F| \\times |E| |F| \\times |E| matrix with \\{-1, 0, 1\\} \\{-1, 0, 1\\} entries Only valid on triangular meshes. require: void IntrinsicGeometryInterface::requireDECOperators() Extrinsic angles These quantities depend on extrinsic angles, but are still rotation-invariant, and independent of a particular embeddeding. They are defined for ExtrinsicGeometryInterface and classes that extend it, including the EmbeddedGeometryInterface one usually constructs from vertex positions. Currently there is no realization that constructs an ExtrinsicGeometryInterface from input data which is not also an EmbeddedGeometryInterface , but such a class could be implemented in the future. edge dihedral angle edge dihedral angle The dihedral angle at an edge, in radians. Defined to be the signed angle between the incident triangle normals: 0 0 if the edge is flat, positive at a convex edge, and negative at a nonconvex edge. Only valid on triangular meshes. member: EdgeData<double> ExtrinsicGeometryInterface::edgeDihedralAngles require: void ExtrinsicGeometryInterface::requireEdgeDihedralAngles() The inline immediate method can be used to compute this value directly from input data for a single element: immediate: double VertexPositionGeometry::edgeDihedralAngle(Edge e) vertex principal curvature direction vertex principal curvature direction A 2-symmetric tangent vector field at vertices. The direction corresponds to the first principal direction, and the magnitude is proportional to the squared difference of the 1st and 2nd principal curvatures (\\kappa_1 - \\kappa_2)^2 (\\kappa_1 - \\kappa_2)^2 (so for instance, if a surface is flat and \\kappa_1 \\approx \\kappa_2 \\kappa_1 \\approx \\kappa_2 , the magnitude of the field will be near 0 0 ). A formal description appears in section 6.1.2 of Globally Optimal Direction Fields Only valid on triangular meshes. member: VertexData<Vector2> ExtrinsicGeometryInterface::vertexPrincipalCurvatureDirections require: void ExtrinsicGeometryInterface::requireVertexPrincipalCurvatureDirections() Embedded positions and normals These quantities depend explicitly on an embedding in 3D space (better known as vertex positions). They are defined for EmbeddedGeometryInterface (which is usually instantiated as a VertexPositionGeometry ). Don\u2019t forget, EmbeddedGeometryInterface extends the IntrinsicGeometryInterface and ExtrinsicGeometryInterface , so all of the quantities above are also accessible. vertex position vertex position Vertex positions in 3D. Note: this member is distinct from the VertexPositionGeometry::inputVertexPositions field. In the common case of a VertexPositionGeometry , this member is a copy of the input vertex positions, provided for consistency and generality (one might define embedded surfaces with data other than vertex positions). If you want to update vertex positions on a mesh, you should modify inputVertexPositions , not this quantity. member: VertexData<Vector3> EmbeddedGeometryInterface::vertexPositions require: void EmbeddedGeometryInterface::requireVertexPositions() face normal face normal A normal vector for each face. member: FaceData<Vector3> EmbeddedGeometryInterface::faceNormals require: void EmbeddedGeometryInterface::requireFaceNormals() The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: Vector3 VertexPositionGeometry::faceNormal(Face f) vertex normal vertex normal A normal vector for each vertex. Defined as the corner-angle weighted average of incident face normals. member: VertexData<Vector3> EmbeddedGeometryInterface::faceNormals require: void EmbeddedGeometryInterface::requireFaceNormals() face tangent basis face tangent basis A pair of x x -axis and y y -axis 3D basis vectors in world space, corresponding to the intrinsic tangent space for the face. Always orthogonal to the face normal. Example: SurfaceMesh & mesh = /* ... */ VertexPositionGeometry & geometry = /* ... */ ; FaceData < Vector2 > myTangentVectorField ; geometry . requireFaceTangentBasis (); for ( Face f : mesh . faces ()) { Vector2 field = myTangentVectorField [ f ]; Vector3 basisX = geometry . faceTangentBasis [ f ]; Vector3 basisY = geometry . faceTangentBasis [ f ]; Vector3 fieldInWorldCoords = basisX * field . x + basisY * field . y ; } member: FaceData<std::array<Vector3,2>> EmbeddedGeometryInterface::faceTangentBasis require: void EmbeddedGeometryInterface::requireFaceTangentBasis() vertex tangent basis vertex tangent basis A pair of x x -axis and y y -axis 3D basis vectors in world space, corresponding to the intrinsic tangent space for the vertex. Always orthogonal to the vertex normal. Example: SurfaceMesh & mesh = /* ... */ VertexPositionGeometry & geometry = /* ... */ ; VertexData < Vector2 > myTangentVectorField ; geometry . requireFaceTangentBasis (); for ( Vertex v : mesh . vertices ()) { Vector2 field = myTangentVectorField [ v ]; Vector3 basisX = geometry . vertexTangentBasis [ v ]; Vector3 basisY = geometry . vertexTangentBasis [ v ]; Vector3 fieldInWorldCoords = basisX * field . x + basisY * field . y ; } member: VertexData<std::array<Vector3,2>> EmbeddedGeometryInterface::vertexTangentBasis require: void EmbeddedGeometryInterface::requireVertexTangentBasis()","title":"Quantities"},{"location":"surface/geometry/quantities/#indices","text":"These quantities are defined for the base BaseGeometryInterface , and will always be available. They are not actually geometric data, but it is convenient to cache the canonical arrays alongside geometric quantities, as they are often used in concert. vertex indices","title":"Indices"},{"location":"surface/geometry/quantities/#vertex-indices","text":"A dense 0-based enumeration of vertices. Equivalent to the result of SurfaceMesh::getVertexIndices() . member: VertexData<size_t> BaseGeometryInterface::vertexIndices require: void BaseGeometryInterface::requireVertexIndices() halfedge indices","title":"vertex indices"},{"location":"surface/geometry/quantities/#halfedge-indices","text":"A dense 0-based enumeration of halfedges. Equivalent to the result of SurfaceMesh::getHalfedgeIndices() . member: HalfedgeData<size_t> BaseGeometryInterface::halfedgeIndices require: void BaseGeometryInterface::requireHalfedgeIndices() corner indices","title":"halfedge indices"},{"location":"surface/geometry/quantities/#corner-indices","text":"A dense 0-based enumeration of corners. Equivalent to the result of SurfaceMesh::getCornerIndices() . member: CornerData<size_t> BaseGeometryInterface::cornerIndices require: void BaseGeometryInterface::requireCornerIndices() edge indices","title":"corner indices"},{"location":"surface/geometry/quantities/#edge-indices","text":"A dense 0-based enumeration of edges. Equivalent to the result of SurfaceMesh::getEdgeIndices() . member: EdgeData<size_t> BaseGeometryInterface::edgeIndices require: void BaseGeometryInterface::requireEdgeIndices() face indices","title":"edge indices"},{"location":"surface/geometry/quantities/#face-indices","text":"A dense 0-based enumeration of faces. Equivalent to the result of SurfaceMesh::getFaceIndices() . member: FaceData<size_t> BaseGeometryInterface::faceIndices require: void BaseGeometryInterface::requireFaceIndices() boundary loop indices","title":"face indices"},{"location":"surface/geometry/quantities/#boundary-loop-indices","text":"A dense 0-based enumeration of boundary loops . Equivalent to the result of SurfaceMesh::getBoundaryLoopIndices() . member: BoundaryLoopData<size_t> BaseGeometryInterface::boundaryLoopIndices require: void BaseGeometryInterface::requireBoundaryLoopIndices()","title":"boundary loop indices"},{"location":"surface/geometry/quantities/#lengths-areas-and-angles","text":"These quantities are defined for any IntrinsicGeometryInterface , which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. edge length","title":"Lengths, areas, and angles"},{"location":"surface/geometry/quantities/#edge-length","text":"The length of an edge in the mesh, as a non-negative real number. member: EdgeData<double> IntrinsicGeometryInterface::edgeLengths require: void IntrinsicGeometryInterface::requireEdgeLengths() The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double VertexPositionGeometry::edgeLength(Edge e) face area","title":"edge length"},{"location":"surface/geometry/quantities/#face-area","text":"The area of a face, as a non-negative real number. May be computed from edge lengths via Heron\u2019s formula, or from embedded vertex positions with a cross product. Only valid on triangular meshes. member: FaceData<double> IntrinsicGeometryInterface::faceAreas require: void IntrinsicGeometryInterface::requireFaceAreas() The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry::faceArea(Face f) immediate: double VertexPositionGeometry::faceArea(Face f) vertex dual area","title":"face area"},{"location":"surface/geometry/quantities/#vertex-dual-area","text":"An area associated with each vertex, as a non-negative real number. Only valid on triangular meshes. Defined to be 1/3 1/3 the sum of all adjacent face areas. The sum of all vertex dual areas is equal to the usual surface area of the mesh. member: VertexData<double> IntrinsicGeometryInterface::vertexDualAreas require: void IntrinsicGeometryInterface::requireVertexDualAreas() The inline immediate method can be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry::vertexDualArea(Vertex v) immediate: double VertexPositionGeometry::vertexDualArea(Vertex v) corner angles","title":"vertex dual area"},{"location":"surface/geometry/quantities/#corner-angles","text":"The angle between incident edges at each corner of a mesh. Only valid on triangular meshes. member: CornerData<double> IntrinsicGeometryInterface::cornerAngles require: void IntrinsicGeometryInterface::requireCornerAngles() The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry::cornerAngle(Corner c) immediate: double VertexPositionGeometry::cornerAngle(Corner c) vertex angle sum","title":"corner angles"},{"location":"surface/geometry/quantities/#vertex-angle-sum","text":"The sum of corner angles around a vertex. Only valid on triangular meshes. member: VertexData<double> IntrinsicGeometryInterface::vertexAngleSums require: void IntrinsicGeometryInterface::requireVertexAngleSums() corner scaled angles","title":"vertex angle sum"},{"location":"surface/geometry/quantities/#corner-scaled-angles","text":"The angle between incident edges at each corner of a mesh, linearly rescaled such that the angles around every vertex sum to 2 \\pi 2 \\pi . At boundary vertices, no scaling will be performed. Only valid on triangular meshes. member: CornerData<double> IntrinsicGeometryInterface::cornerScaledAngles require: void IntrinsicGeometryInterface::requireCornerScaledAngles() halfedge cotan weight","title":"corner scaled angles"},{"location":"surface/geometry/quantities/#halfedge-cotan-weight","text":"The \u201ccotangent weight\u201d of an interior halfedge, defined as \\frac{1}{2} \\cot(\\theta) \\frac{1}{2} \\cot(\\theta) , where \\theta \\theta is the corner angle opposite the halfedge. Defined to be 0 0 for exterior halfedges. Can be computed directly from edge lengths, or more efficiently in an embedded triangle via \\cot(\\theta) = \\frac{u \\cdot v}{||u \\times v||} \\cot(\\theta) = \\frac{u \\cdot v}{||u \\times v||} , where u u and v v are the edge vectors emanating from the opposite corner. Only valid on triangular meshes. member: HalfedgeData<double> IntrinsicGeometryInterface::halfedgeCotanWeights require: void IntrinsicGeometryInterface::requireHalfedgeCotanWeights() The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry::halfedgeCotanWeight(Halfedge he) immediate: double VertexPositionGeometry::halfedgeCotanWeight(Halfedge he) edge cotan weight","title":"halfedge cotan weight"},{"location":"surface/geometry/quantities/#edge-cotan-weight","text":"The \u201ccotangent weight\u201d of an edge, defined as the sum of halfedge cotan weights for incident interior halfedges. Only valid on triangular meshes. member: EdgeData<double> IntrinsicGeometryInterface::edgeCotanWeights require: void IntrinsicGeometryInterface::requireEdgeCotanWeights() The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry::edgeCotanWeight(Edge e) immediate: double VertexPositionGeometry::edgeCotanWeight(Edge e)","title":"edge cotan weight"},{"location":"surface/geometry/quantities/#curvatures","text":"Different curvatures are available depending on whether geometry is intrinsic or extrinsic. In particular, Gaussian curvature is available for any IntrinsicGeometryInterface (such as EdgeLengthGeometry ), which is the base class of all other geometry objects, whereas mean and principal curvatures are available only from an ExtrinsicGeometryInterface (such as VertexPositionGeometry ). All curvatures are rigid motion invariant. Importantly, Gaussian and mean curvatures correspond to the integral of curvature over a local neighborhood, and are hence scale invariant\u2014to get the pointwise curvatures you should divide by area (see details below). Principal curvatures are pointwise values. See also vertexPrincipalCurvatureDirections , which provides curvature directions (rather than curvature magnitudes). See this video for further background on discrete curvature. vertex Gaussian curvature","title":"Curvatures"},{"location":"surface/geometry/quantities/#vertex-gaussian-curvature","text":"The Gaussian curvature K K at a vertex, defined via the angle defect K_v = 2 \\pi - \\sum \\theta_i K_v = 2 \\pi - \\sum \\theta_i , where \\sum \\theta_i \\sum \\theta_i is the vertexAngleSum as above. Should be interpreted as an integrated Gaussian curvature, giving the total curvature in the neighborhood of the vertex. On a closed surface, the Gauss-Bonnet theorem tells us that the sum of these Gaussian curvatures will be a topological constant given by \\sum_v K_v = 2 \\pi \\chi \\sum_v K_v = 2 \\pi \\chi , where \\chi \\chi is the Euler characteristic of the surface. On surfaces with boundary, the geodesic curvature of the boundary factors in. Only valid on triangular meshes. member: VertexData<double> IntrinsicGeometryInterface::vertexGaussianCurvatures require: void IntrinsicGeometryInterface::requireVertexGaussianCurvatures() The inline immediate method can be used to compute this value directly from input data for a single element: immediate: double VertexPositionGeometry::vertexGaussianCurvature(Vertex v) immediate: double EdgeLengthGeometry::vertexGaussianCurvature(Vertex v) vertex mean curvature","title":"vertex Gaussian curvature"},{"location":"surface/geometry/quantities/#vertex-mean-curvature","text":"The mean curvature H H at a vertex i i , defined via the Steiner approximation H_i = \\frac{1}{4}\\sum_{ij} \\theta_{ij} \\ell_{ij} H_i = \\frac{1}{4}\\sum_{ij} \\theta_{ij} \\ell_{ij} , where \\theta_{ij} \\theta_{ij} is the edgeDihedralAngle and \\ell_{ij} \\ell_{ij} is the edgeLength as defined above (and the sum is taken over halfedges extending from i i ). Should be interpreted as an integrated mean curvature (units: m m ), giving the total curvature in the neighborhood of the vertex. A corresponding pointwise mean curvature (units: 1/m 1/m ) can be obtained by dividing by the vertexDualArea . Only valid on triangular meshes. member: VertexData<double> IntrinsicGeometryInterface::vertexMeanCurvatures require: void IntrinsicGeometryInterface::requireVertexMeanCurvatures() The inline immediate method can be used to compute this value directly from input data for a single element: immediate: double VertexPositionGeometry::vertexMeanCurvature(Vertex v) vertex principal curvature","title":"vertex mean curvature"},{"location":"surface/geometry/quantities/#vertex-principal-curvatures","text":"The principal curvatures \\kappa_1,\\kappa_2 \\kappa_1,\\kappa_2 at a vertex i i , defined by the relationships K = \\kappa_1\\kappa_2 K = \\kappa_1\\kappa_2 and H = (\\kappa_1+\\kappa_2)/2 H = (\\kappa_1+\\kappa_2)/2 , where H H and K K are the pointwise mean and Gaussian curvatures (resp.). These values are signed, and \\kappa_1 \\kappa_1 is always the smaller curvature in value , but not necessarily the smaller one in magnitude (e.g., \\kappa_1 \\kappa_1 could be a very large negative value, and \\kappa_2 \\kappa_2 could be a very small positive value). These quantities can be interpreted as pointwise quantities (units: 1/m 1/m ), approximating the maximum and minimum bending the neighborhood of the vertex. Only valid on triangular meshes. member: VertexData<double> IntrinsicGeometryInterface::vertexMinPrincipalCurvatures require: void IntrinsicGeometryInterface::requireVertexMinPrincipalCurvatures() member: VertexData<double> IntrinsicGeometryInterface::vertexMaxPrincipalCurvatures require: void IntrinsicGeometryInterface::requireVertexMaxPrincipalCurvatures() The inline immediate methods can be used to compute this value directly from input data for a single element: immediate: double VertexPositionGeometry::vertexMinPrincipalCurvature(Vertex v) immediate: double VertexPositionGeometry::vertexMaxPrincipalCurvature(Vertex v) face Gaussian curvature","title":"vertex principal curvatures"},{"location":"surface/geometry/quantities/#face-gaussian-curvature","text":"The Gaussian curvature K K at a face, defined via the rescaled angle defect in the face K_f = \\pi - \\sum \\tilde{\\theta}_i K_f = \\pi - \\sum \\tilde{\\theta}_i , where \\tilde{\\theta}_i \\tilde{\\theta}_i are the rescaled corner angles (as in cornerScaledAngles ) incident on the face. Should be interpreted as an integrated Gaussian curvature, giving the total curvature inside of the face. A corresponding curvature-per-unit-area can be computed by dividing by the area of the face. On a closed surface, the Gauss-Bonnet theorem tells us that the sum of these Gaussian curvatures will be a topological constant given by \\sum_f K_f = 2 \\pi \\chi \\sum_f K_f = 2 \\pi \\chi , where \\chi \\chi is the Euler characteristic of the surface. On surfaces with boundary, the geodesic curvature of the boundary factors in. Only valid on triangular meshes. member: FaceData<double> IntrinsicGeometryInterface::faceGaussianCurvatures require: void IntrinsicGeometryInterface::requireFaceGaussianCurvatures()","title":"face Gaussian curvature"},{"location":"surface/geometry/quantities/#tangent-vectors-and-transport","text":"These quantities are defined for any IntrinsicGeometryInterface , which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. Tangent vectors and transport are defined in terms of tangent spaces at faces and vertices, as defined below. Recall that our Vector2 types obey the multiplication and division rules of complex arithmetic, and thus can be used to represent rotations. For instance, a 2D vector representing a rotation can be used to rotate another vector like: Vector2 v = /* your vector */ Vector2 r = Vector2 { std :: cos ( PI / 4 ), std :: sin ( PI / 4 )}; // rotation by 45 degrees Vector2 vRot = r * v ; This is fundamentally no different from using 2x2 rotation matrices, but leads to much cleaner code (try using division to compute relative rotations!).","title":"Tangent vectors and transport"},{"location":"surface/geometry/quantities/#face-tangent-spaces","text":"To represent vectors that sit in flat mesh faces, we define a 2D coordinate frame tangent to each face. By default, this frame is aligned such that face.halfedge() points along the x x -axis (but subclasses might change this convention). All vectors in faces are then expressed via (x,y) (x,y) Vector2D coordinates in this frame. Crucially, this basis is well-defined even if the geometry does not have vertex positions. See face tangent basis to convert these vectors to world coordinates (if your mesh has vertex positions). halfedge vectors in face","title":"Face tangent spaces"},{"location":"surface/geometry/quantities/#halfedge-vectors-in-face","text":"Vectors for each halfedge in the coordinate frame of the face in which they sit. See the description of face tangent spaces above for a definition. Only valid on triangular meshes. member: HalfedgeData<Vector2> IntrinsicGeometryInterface::halfedgeVectorsInFace require: void IntrinsicGeometryInterface::requireHalfedgeVectorsInFace() transport vector across halfedge","title":"halfedge vectors in face"},{"location":"surface/geometry/quantities/#transport-vector-across-halfedge","text":"Rotations which transport tangent vectors across a halfedge, rotating a vector from the tangent space of halfedge.face() to the tangent space halfedge.twin().face() . Always a unit vector, which can be multiplied by any other vector to compute the rotation. (recall our Vector2 s multiply like complex numbers) Only valid on triangular meshes. Not defined for halfedges (interior or exterior) incident on boundary edges, these boundary values are set to NaN so errors can be caught quickly. member: HalfedgeData<Vector2> IntrinsicGeometryInterface::transportVectorAcrossHalfedge require: void IntrinsicGeometryInterface::requireTransportVectorAcrossHalfedge() Example usage: geometry . requireTransportVectorAcrossHalfedge (); Face f = /* ... */ ; // a face of interest Vector2 myVec = /* ... */ ; // tangent vector in face f for ( Halfedge he : f . adjacentHalfedges ()) { Vertex neighborFace = he . twin (). face (); Vector2 rot = geometry . transportVectorAcrossHalfedge [ he ]; Vector2 neighVec = rot * myVec ; // now in the basis of neighborFace }","title":"transport vector across halfedge"},{"location":"surface/geometry/quantities/#vertex-tangent-spaces","text":"To represent vectors that sit at mesh faces, we consider a polar coordinate frame at each vertex. This frame is defined by measuring angles according to the rescaled corner angles as in cornerScaledAngles . By default, this frame is aligned such that vertex.halfedge() points along the \\phi=0 \\phi=0 x x -axis (but subclasses might change this convention). Of course, rather than using polar coordinates we can equivalently work in the corresponding Cartesian frame\u2014tangent vectors at vertices are then expressed via (x,y) (x,y) Vector2D coordinates in this frame. Crucially, this basis does not require picking a vertex normal, and is well-defined even if the geometry does not have vertex positions. See vertex tangent basis to convert these tangent vectors to world coordinates (if your mesh has vertex positions). halfedge vectors in vertex","title":"Vertex tangent spaces"},{"location":"surface/geometry/quantities/#halfedge-vectors-in-vertex","text":"Vectors for each halfedge in the coordinate frame of the vertex from which the emanate (in halfedge.vertex() ). See the description of vertex tangent spaces above for a definition. Only valid on triangular meshes. member: HalfedgeData<Vector2> IntrinsicGeometryInterface::halfedgeVectorsInVertex require: void IntrinsicGeometryInterface::requireHalfedgeVectorsInVertex() transport vector along halfedge","title":"halfedge vectors in vertex"},{"location":"surface/geometry/quantities/#transport-vector-along-halfedge","text":"Rotations which transport tangent vectors along a halfedge, rotating a vector from the tangent space of halfedge.vertex() to the tangent space halfedge.twin().vertex() . Always a unit vector, which can be multiplied by any other vector to compute the rotation. (recall our Vector2 s multiply like complex numbers) Only valid on triangular meshes. member: HalfedgeData<Vector2> IntrinsicGeometryInterface::transportVectorAlongHalfedge require: void IntrinsicGeometryInterface::requireTransportVectorAlongHalfedge() Example usage: geometry . requireTransportVectorAlongHalfedge (); Vertex v = /* ... */ ; // a vertex of interest Vector2 myVec = /* ... */ ; // tangent vector in vertex v for ( Halfedge he : v . outgoingHalfedges ()) { Vertex neighborVertex = he . twin (). vertex (); Vector2 rot = geometry . transportVectorAlongHalfedge [ he ]; Vector2 neighVec = rot * myVec ; // now in the basis of neighborVertex }","title":"transport vector along halfedge"},{"location":"surface/geometry/quantities/#operators","text":"These quantities are defined for any IntrinsicGeometryInterface , which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. A full explanation of these operators is beyond the scope of these docs; see these course notes for one introduction. All operators are indexed over mesh elements according to the natural iteration order of the elements, or equivalently the indices from SurfaceMesh::getVertexIndices() (etc). cotangent Laplacian","title":"Operators"},{"location":"surface/geometry/quantities/#cotangent-laplacian","text":"The discrete Laplace operator, discretized via cotangent weights. A |V| \\times |V| |V| \\times |V| real matrix. Always symmetric and positive semi-definite. If and only the underlying geometry is Delaunay , the matrix will furthermore have all negative off-diagonal entries, satisfy a maximum principle, and be an M-matrix . This is the weak Laplace operator, if we use it to evalutae \\mathsf{y} \\leftarrow \\mathsf{L} \\mathsf{x} \\mathsf{y} \\leftarrow \\mathsf{L} \\mathsf{x} , \\mathsf{x} \\mathsf{x} should hold pointwise quantities at vertices, and the result \\mathsf{y} \\mathsf{y} will contain integrated values of the result in the neighborhood of each vertex. If used to solve a Poisson problem, a mass matrix (such as the lumped or Galerkin mass matrices below) are likely necessary on the right hand side. Only valid on triangular meshes. member: Eigen::SparseMatrix<double> IntrinsicGeometryInterface::laplacian require: void IntrinsicGeometryInterface::requireLaplacian() vertex lumped mass matrix","title":"cotangent laplacian"},{"location":"surface/geometry/quantities/#vertex-lumped-mass-matrix","text":"A mass matrix at vertices, where vertex area is 1/3 1/3 the incident face areas as in vertexDualAreas . A |V| \\times |V| |V| \\times |V| real diagonal matrix. Generally less-accurate than the Galerkin mass matrix below, but can be easily inverted since it is a diagonal matrix. Only valid on triangular meshes. member: Eigen::SparseMatrix<double> IntrinsicGeometryInterface::vertexLumpedMassMatrix require: void IntrinsicGeometryInterface::requireVertexLumpedMassMatrix() vertex Galerkin mass matrix","title":"vertex lumped mass matrix"},{"location":"surface/geometry/quantities/#vertex-galerkin-mass-matrix","text":"A mass matrix at vertices, supported at all neighbors of a vertex via integration of piecewise-linear elements. A |V| \\times |V| |V| \\times |V| real matrix. Generally more accurate than the lumped mass matrix above, should be preferred unless the mass matrix needs to be inverted. Only valid on triangular meshes. member: Eigen::SparseMatrix<double> IntrinsicGeometryInterface::vertexGalerkinMassMatrix require: void IntrinsicGeometryInterface::requireVertexGalerkinMassMatrix() vertex connection Laplacian","title":"vertex Galerkin mass matrix"},{"location":"surface/geometry/quantities/#vertex-connection-laplacian","text":"A discrete connection Laplacian operator, which applies to vector fields defined in vertex tangent spaces. Essentially defined as the scalar cotangent Laplacian, augmented with rotations given by the rotations in transportVectorAlongHalfedge ; see The Vector Heat Method, Sec 5.3 for more explanation and definition. A |V| \\times |V| |V| \\times |V| complex matrix. Always Hermitian, but positive semi-definite if and only the underlying geometry is Delaunay . This is a weak Laplace operator, the application of which outputs integrated values in vertex neighborhood. Given a complex vector \\mathsf{x} \\mathsf{x} of tangent vectors at vertices, apply the operator by multiplying \\mathsf{L} * \\mathsf{x} \\mathsf{L} * \\mathsf{x} . Only valid on triangular meshes. member: Eigen::SparseMatrix<double> IntrinsicGeometryInterface::vertexGalerkinMassMatrix require: void IntrinsicGeometryInterface::requireVertexGalerkinMassMatrix() DEC operators","title":"vertex connection Laplacian"},{"location":"surface/geometry/quantities/#dec-operators","text":"These operators are the basic building blocks for discrete exterior calculus on surfaces. Note: These quantities slightly deviate from the usual naming scheme for quantities. Rather than requireD0() , requireD1() , etc, there is a single requireDECOperators() function which manages all 8 of the members listed below. The following members are constructed: Eigen::SparseMatrix<double> IntrinsicGeometryInterface::hodge0 A |V| \\times |V| |V| \\times |V| diagonal matrix Eigen::SparseMatrix<double> IntrinsicGeometryInterface::hodge0Inverse A |V| \\times |V| |V| \\times |V| diagonal matrix Eigen::SparseMatrix<double> IntrinsicGeometryInterface::hodge1 An |E| \\times |E| |E| \\times |E| diagonal matrix Eigen::SparseMatrix<double> IntrinsicGeometryInterface::hodge1Inverse An |E| \\times |E| |E| \\times |E| diagonal matrix Eigen::SparseMatrix<double> IntrinsicGeometryInterface::hodge2 An |F| \\times |F| |F| \\times |F| diagonal matrix Eigen::SparseMatrix<double> IntrinsicGeometryInterface::hodge2Inverse An |F| \\times |F| |F| \\times |F| diagonal matrix Eigen::SparseMatrix<double> IntrinsicGeometryInterface::d0 An |E| \\times |V| |E| \\times |V| matrix with \\{-1, 0, 1\\} \\{-1, 0, 1\\} entries Eigen::SparseMatrix<double> IntrinsicGeometryInterface::d1 An |F| \\times |E| |F| \\times |E| matrix with \\{-1, 0, 1\\} \\{-1, 0, 1\\} entries Only valid on triangular meshes. require: void IntrinsicGeometryInterface::requireDECOperators()","title":"DEC operators"},{"location":"surface/geometry/quantities/#extrinsic-angles","text":"These quantities depend on extrinsic angles, but are still rotation-invariant, and independent of a particular embeddeding. They are defined for ExtrinsicGeometryInterface and classes that extend it, including the EmbeddedGeometryInterface one usually constructs from vertex positions. Currently there is no realization that constructs an ExtrinsicGeometryInterface from input data which is not also an EmbeddedGeometryInterface , but such a class could be implemented in the future. edge dihedral angle","title":"Extrinsic angles"},{"location":"surface/geometry/quantities/#edge-dihedral-angle","text":"The dihedral angle at an edge, in radians. Defined to be the signed angle between the incident triangle normals: 0 0 if the edge is flat, positive at a convex edge, and negative at a nonconvex edge. Only valid on triangular meshes. member: EdgeData<double> ExtrinsicGeometryInterface::edgeDihedralAngles require: void ExtrinsicGeometryInterface::requireEdgeDihedralAngles() The inline immediate method can be used to compute this value directly from input data for a single element: immediate: double VertexPositionGeometry::edgeDihedralAngle(Edge e) vertex principal curvature direction","title":"edge dihedral angle"},{"location":"surface/geometry/quantities/#vertex-principal-curvature-direction","text":"A 2-symmetric tangent vector field at vertices. The direction corresponds to the first principal direction, and the magnitude is proportional to the squared difference of the 1st and 2nd principal curvatures (\\kappa_1 - \\kappa_2)^2 (\\kappa_1 - \\kappa_2)^2 (so for instance, if a surface is flat and \\kappa_1 \\approx \\kappa_2 \\kappa_1 \\approx \\kappa_2 , the magnitude of the field will be near 0 0 ). A formal description appears in section 6.1.2 of Globally Optimal Direction Fields Only valid on triangular meshes. member: VertexData<Vector2> ExtrinsicGeometryInterface::vertexPrincipalCurvatureDirections require: void ExtrinsicGeometryInterface::requireVertexPrincipalCurvatureDirections()","title":"vertex principal curvature direction"},{"location":"surface/geometry/quantities/#embedded-positions-and-normals","text":"These quantities depend explicitly on an embedding in 3D space (better known as vertex positions). They are defined for EmbeddedGeometryInterface (which is usually instantiated as a VertexPositionGeometry ). Don\u2019t forget, EmbeddedGeometryInterface extends the IntrinsicGeometryInterface and ExtrinsicGeometryInterface , so all of the quantities above are also accessible. vertex position","title":"Embedded positions and normals"},{"location":"surface/geometry/quantities/#vertex-position","text":"Vertex positions in 3D. Note: this member is distinct from the VertexPositionGeometry::inputVertexPositions field. In the common case of a VertexPositionGeometry , this member is a copy of the input vertex positions, provided for consistency and generality (one might define embedded surfaces with data other than vertex positions). If you want to update vertex positions on a mesh, you should modify inputVertexPositions , not this quantity. member: VertexData<Vector3> EmbeddedGeometryInterface::vertexPositions require: void EmbeddedGeometryInterface::requireVertexPositions() face normal","title":"vertex position"},{"location":"surface/geometry/quantities/#face-normal","text":"A normal vector for each face. member: FaceData<Vector3> EmbeddedGeometryInterface::faceNormals require: void EmbeddedGeometryInterface::requireFaceNormals() The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: Vector3 VertexPositionGeometry::faceNormal(Face f) vertex normal","title":"face normal"},{"location":"surface/geometry/quantities/#vertex-normal","text":"A normal vector for each vertex. Defined as the corner-angle weighted average of incident face normals. member: VertexData<Vector3> EmbeddedGeometryInterface::faceNormals require: void EmbeddedGeometryInterface::requireFaceNormals() face tangent basis","title":"vertex normal"},{"location":"surface/geometry/quantities/#face-tangent-basis","text":"A pair of x x -axis and y y -axis 3D basis vectors in world space, corresponding to the intrinsic tangent space for the face. Always orthogonal to the face normal. Example: SurfaceMesh & mesh = /* ... */ VertexPositionGeometry & geometry = /* ... */ ; FaceData < Vector2 > myTangentVectorField ; geometry . requireFaceTangentBasis (); for ( Face f : mesh . faces ()) { Vector2 field = myTangentVectorField [ f ]; Vector3 basisX = geometry . faceTangentBasis [ f ]; Vector3 basisY = geometry . faceTangentBasis [ f ]; Vector3 fieldInWorldCoords = basisX * field . x + basisY * field . y ; } member: FaceData<std::array<Vector3,2>> EmbeddedGeometryInterface::faceTangentBasis require: void EmbeddedGeometryInterface::requireFaceTangentBasis() vertex tangent basis","title":"face tangent basis"},{"location":"surface/geometry/quantities/#vertex-tangent-basis","text":"A pair of x x -axis and y y -axis 3D basis vectors in world space, corresponding to the intrinsic tangent space for the vertex. Always orthogonal to the vertex normal. Example: SurfaceMesh & mesh = /* ... */ VertexPositionGeometry & geometry = /* ... */ ; VertexData < Vector2 > myTangentVectorField ; geometry . requireFaceTangentBasis (); for ( Vertex v : mesh . vertices ()) { Vector2 field = myTangentVectorField [ v ]; Vector3 basisX = geometry . vertexTangentBasis [ v ]; Vector3 basisY = geometry . vertexTangentBasis [ v ]; Vector3 fieldInWorldCoords = basisX * field . x + basisY * field . y ; } member: VertexData<std::array<Vector3,2>> EmbeddedGeometryInterface::vertexTangentBasis require: void EmbeddedGeometryInterface::requireVertexTangentBasis()","title":"vertex tangent basis"},{"location":"surface/surface_mesh/basics/","text":"The SurfaceMesh is the workhorse datastructure for representing surface in geometry-central. Internally, it is reference-based mesh (similar to halfedge mesh), and can hold general polygonal meshes (though many routines only support triangle meshes). SurfaceMesh offers wide support for things like iterating around a mesh, modifying a mesh, and associating data with a mesh via containers. Under the hood, it is implemented with dense, automatically resizing buffers for efficient performance. #include \"geometrycentral/surface/surface_mesh.h\" #include \"geometrycentral/surface/manifold_surface_mesh.h\" Old HalfedgeMesh type In a previous version of geometrycentral , the mesh type was simply called HalfedgeMesh , and only supported manifold meshes. This type as been renamed to ManifoldSurfaceMesh . Including geometrycentral/surface/halfedge_mesh.h will simply typedef HalfedgeMesh as ManifoldSurfaceMesh , so most existing code will still work unchanged; new code should use ManifoldSurfaceMesh . General vs. Manifold Surface Meshes There are variants of the surface mesh class; the more general SurfaceMesh which can hold any very general polygonal mesh, and the more specific ManifoldSurfaceMesh , which only supports manifold, oriented meshes. Beyond the general capabilities of a SurfaceMesh , the ManifoldSurfaceMesh : inherits from SurfaceMesh , and can be used anywhere a SurfaceMesh is expected supports additional operations which require a manifold structure internally uses a more efficient representation There are also a small number of operations which might throw an error if called on a ManifoldSurfaceMesh , and should be used only on the more general SurfaceMesh . In particular, mutations which would make the mesh nonmanifold. Nonmanifold Meshes Support for general, possibly nonmanifold surface meshes is a recent addition to geometry-central. We are still gradually porting routines from supporting ManifoldSurfaceMesh to the more general SurfaceMesh where appropriate! Element types The SurfaceMesh also comes with a collection of lightweight types serving as logical references, or \u201chandles\u201d to mesh elements: Vertex , Halfedge , Edge , Corner , Face , and BoundaryLoop ( ManifoldSurfaceMesh only). These handles are essentially just a typed wrapper around an ID for the element. Deleting one of these handles does not delete the underlying element, and one may have many distinct handles to the same element Vertex a; Vertex b; a == b; . Mesh connectivity Generally, you can (and should) interact with the mesh via higher-level, abstracted routines . However, this section details the low-level relationships between these handles. Note that on a ManifoldSurfaceMesh , the guarantees about these relationships are much stronger than on a more general SurfaceMesh . The primary type in our halfedge-based mesh is a halfedge , in addition to the usual vertex , edge and face types. A halfedge is a directed edge incident on a face, as shown below. On a ManifoldSurfaceMesh , two halfedges, oriented in opposite directions, make up each edge in the mesh. Each halfedge has relationships with five adjacent elements: Halfedge::twin() the other halfedge across the incident edge Halfedge::next() the next halfedge in clockwise order around the incident face Halfedge::vertex() the vertex at the tail (back) of the halfedge Halfedge::edge() the incident edge Halfedge::face() the incident face On a more general SurfaceMesh , rather than a single twin, the Halfedge::sibling() referene orbits around all other halfedge incident on the edge, which might point in the same or the opposite direction. Each vertex, edge, and face need just one relationship: Vertex::halfedge() any of the incident halfedges (which point outward from the vertex) Edge::halfedge() any of the incident halfedges Face::halfedge() any of the incident halfedges In fact, these relationships is sufficient to implement pretty much any local traversal. Geometry central provides a wide range of convience iterators which wrap these relationships to traverse neighborhoods (see navigation ). for ( Edge e : vertex . adjacentEdges ()) { // do science } Manifold, Oriented Surfaces The ManifoldSurfaceMesh mesh imposes two requirements: manifoldness and orientation. Manifoldness means that our surface must locally look like a plane in any neighborhood. This disallows structures such as three faces meeting at an edge, or two cones of faces meeting at a single vertex like an hourglass. Furthermore the halfedge mesh implies a combinatorial orientation of the surface, indicated by the clockwise ordering of halfedges around each face (see figure below). Because the halfedge mesh implies an orientation, it cannot represent non-orientable surfaces, like a Klein bottle. These properties are invariants which always hold for the ManifoldSurfaceMesh ; in practice we check them during construction and ensure that all operations preserve them. Basic API Constructors See the mesh I/O page for helpers which read a mesh from file, and factory methods to construct a mesh and geometry simultaneously. SurfaceMesh ( const std :: vector < std :: vector < size_t >>& polygons ) Constructs a mesh from a face-index list. polygons a list of faces, each holding the indices of the vertices incident on that face, zero-indexed and in counter-clockwise order. ManifoldSurfaceMesh ( const std :: vector < std :: vector < size_t >>& polygons ) Same as above, but constructs a manifold surface mesh. SurfaceMesh ( const Eigen :: MatrixBase < T >& faces ) Constructs a mesh from a rectangular face-index matrix, like an Fx3 array of triangle indices, or an Fx4 array of quad indices. The matrix scalar can be any integer type, like size_t or int . The Eigen:MatrixBase<T> type is just a general type which accepts most Eigen matrix types as input, including geometry-central\u2019s nicely-named wrapper DenseMatrix<T> . ManifoldSurfaceMesh ( const Eigen :: MatrixBase < T >& faces ) Same as above, but constructs a manifold surface mesh. ManifoldSurfaceMesh ( const std :: vector < std :: vector < size_t >>& polygons , const std :: vector < std :: vector < std :: tuple < size_t , size_t >>>& twins ) Constructs a mesh from a face-index list, and extra data specifying the neighboring face across each face-side. This extra data allows you to describe meshes where there are multiple, distinct edges between some pair of vertices polygons a list of faces, each holding the indices of the vertices incident on that face, zero-indexed and in counter-clockwise order. twins a list of tuples, in correspondence with the polygons list. For each side of a face, it holds an (iF, iS) tuple, where iF is the index of the face across the edge, and iS is the side of that face (e.g. the iS = 2 for the third side of a triangle). Set both tuple elements to INVALID_IND for boundary sides. Element counts Remember, all functions from SurfaceMesh can also be called on ManifoldSurfaceMesh . size_t SurfaceMesh :: nVertices () Returns the number of vertices. size_t SurfaceMesh :: nInteriorVertices () Returns the number of vertices not incident on the boundary. size_t SurfaceMesh :: nBoundaryVertices () Returns the number of vertices incident on the boundary. size_t SurfaceMesh :: nEdges () Returns the number of edges. size_t SurfaceMesh :: nFaces () Returns the number of faces in the mesh. size_t SurfaceMesh :: nHalfedges () Returns the number of halfedges, including both interior halfedges and any exterior halfedges incident on boundary loops. Always exactly twice the number of edges. size_t SurfaceMesh :: nInterioHalfedges () Returns the number of interior halfedges, which are incident on faces of the mesh. Always equal to the sum of the number of sides of all faces. size_t SurfaceMesh :: nExteriorHalfedges () Returns the number of exterior halfedges, which are opposite boundary faces. size_t SurfaceMesh :: nBoundaryLoops () Returns the number of distinct boundary loops in the mesh, each identified as an fictional face closing a boundary loop in the mesh. Properties bool SurfaceMesh :: hasBoundary () Returns true if the mesh has boundary, that is if it is not closed . Complexity \\mathcal{O}(1) \\mathcal{O}(1) . int ManifoldSurfaceMesh :: eulerCharacteristic () Returns the Euler characteristic of the surface. Computed in O(1) from element counts. Note: always computed by naively applying Euler\u2019s polyhedron formula , which might not do what you want in the case of multiple-connected components. int ManifoldSurfaceMesh :: genus () Returns the genus of the surface. Computed in O(1) from element counts. Note: always computed by naively applying Euler\u2019s polyhedron formula , which might not do what you want in the case of multiple connected components. bool SurfaceMesh :: isManifold () Returns true if the mesh is both edge- and vertex- manifold. Note that there is no isVertexManifold() , because a mesh which is edge-nonmanifold is always also vertex-nonmanifold. bool SurfaceMesh :: isEdgeManifold () Returns true if the mesh is both edge-manifold. bool SurfaceMesh :: isOriented () Returns true if all faces have consistent orientations. bool SurfaceMesh :: isTriangular () Returns true if all faces in the mesh have 3 sides. Complexity \\mathcal{O}(n) \\mathcal{O}(n) , do not call in a tight loop. size_t SurfaceMesh :: nConnectedComponents () Returns the number of distinct connected components of the mesh. Complexity \\mathcal{O}(n) \\mathcal{O}(n) , do not call in a tight loop. Utility functions std :: vector < std :: vector < size_t >> SurfaceMesh :: getFaceVertexList () Return a listing of the vertex indices incident on each face. DenseMatrix < T > SurfaceMesh :: getFaceVertexMatrix () Return a dense F x D matrix of the vertex indices for each face in the mesh. All faces in the mesh must have the same degree D . This function is templated on the scalar type for the resulting matrix, so call it like DenseMatrix < size_t > F = mesh -> getFaceVertexMatrix < size_t > (); to get a matrix where each entry is a size_t , or like DenseMatrix < int > F = mesh -> getFaceVertexMatrix < int > (); to get a matrix where each entry is an int . Remember that DenseMatrix<T> is just our nice synonym for Eigen:::Matrix . std :: unique_ptr < SurfaceMesh > SurfaceMesh :: copy () const Construct a copy of the mesh. std :: unique_ptr < ManifoldSurfaceMesh > ManifoldSurfaceMesh :: copy () const Construct a copy of the mesh. std :: unique_ptr < SurfaceMesh > SurfaceMesh :: copyToSurfaceMesh () const Construct a copy of the mesh. The underlying type will be the same as the underlying type of the mesh on which it is called. std :: unique_ptr < ManifoldSurfaceMesh > SurfaceMesh :: toManifoldMesh () Convert the mesh to ManifoldSurfaceMesh , which is certainly manifold and oriented. Throws an error if the mesh is not manifold and oriented.","title":"Basics"},{"location":"surface/surface_mesh/basics/#general-vs-manifold-surface-meshes","text":"There are variants of the surface mesh class; the more general SurfaceMesh which can hold any very general polygonal mesh, and the more specific ManifoldSurfaceMesh , which only supports manifold, oriented meshes. Beyond the general capabilities of a SurfaceMesh , the ManifoldSurfaceMesh : inherits from SurfaceMesh , and can be used anywhere a SurfaceMesh is expected supports additional operations which require a manifold structure internally uses a more efficient representation There are also a small number of operations which might throw an error if called on a ManifoldSurfaceMesh , and should be used only on the more general SurfaceMesh . In particular, mutations which would make the mesh nonmanifold. Nonmanifold Meshes Support for general, possibly nonmanifold surface meshes is a recent addition to geometry-central. We are still gradually porting routines from supporting ManifoldSurfaceMesh to the more general SurfaceMesh where appropriate!","title":"General vs. Manifold Surface Meshes"},{"location":"surface/surface_mesh/basics/#element-types","text":"The SurfaceMesh also comes with a collection of lightweight types serving as logical references, or \u201chandles\u201d to mesh elements: Vertex , Halfedge , Edge , Corner , Face , and BoundaryLoop ( ManifoldSurfaceMesh only). These handles are essentially just a typed wrapper around an ID for the element. Deleting one of these handles does not delete the underlying element, and one may have many distinct handles to the same element Vertex a; Vertex b; a == b; .","title":"Element types"},{"location":"surface/surface_mesh/basics/#mesh-connectivity","text":"Generally, you can (and should) interact with the mesh via higher-level, abstracted routines . However, this section details the low-level relationships between these handles. Note that on a ManifoldSurfaceMesh , the guarantees about these relationships are much stronger than on a more general SurfaceMesh . The primary type in our halfedge-based mesh is a halfedge , in addition to the usual vertex , edge and face types. A halfedge is a directed edge incident on a face, as shown below. On a ManifoldSurfaceMesh , two halfedges, oriented in opposite directions, make up each edge in the mesh. Each halfedge has relationships with five adjacent elements: Halfedge::twin() the other halfedge across the incident edge Halfedge::next() the next halfedge in clockwise order around the incident face Halfedge::vertex() the vertex at the tail (back) of the halfedge Halfedge::edge() the incident edge Halfedge::face() the incident face On a more general SurfaceMesh , rather than a single twin, the Halfedge::sibling() referene orbits around all other halfedge incident on the edge, which might point in the same or the opposite direction. Each vertex, edge, and face need just one relationship: Vertex::halfedge() any of the incident halfedges (which point outward from the vertex) Edge::halfedge() any of the incident halfedges Face::halfedge() any of the incident halfedges In fact, these relationships is sufficient to implement pretty much any local traversal. Geometry central provides a wide range of convience iterators which wrap these relationships to traverse neighborhoods (see navigation ). for ( Edge e : vertex . adjacentEdges ()) { // do science }","title":"Mesh connectivity"},{"location":"surface/surface_mesh/basics/#manifold-oriented-surfaces","text":"The ManifoldSurfaceMesh mesh imposes two requirements: manifoldness and orientation. Manifoldness means that our surface must locally look like a plane in any neighborhood. This disallows structures such as three faces meeting at an edge, or two cones of faces meeting at a single vertex like an hourglass. Furthermore the halfedge mesh implies a combinatorial orientation of the surface, indicated by the clockwise ordering of halfedges around each face (see figure below). Because the halfedge mesh implies an orientation, it cannot represent non-orientable surfaces, like a Klein bottle. These properties are invariants which always hold for the ManifoldSurfaceMesh ; in practice we check them during construction and ensure that all operations preserve them.","title":"Manifold, Oriented Surfaces"},{"location":"surface/surface_mesh/basics/#basic-api","text":"","title":"Basic API"},{"location":"surface/surface_mesh/basics/#constructors","text":"See the mesh I/O page for helpers which read a mesh from file, and factory methods to construct a mesh and geometry simultaneously. SurfaceMesh ( const std :: vector < std :: vector < size_t >>& polygons ) Constructs a mesh from a face-index list. polygons a list of faces, each holding the indices of the vertices incident on that face, zero-indexed and in counter-clockwise order. ManifoldSurfaceMesh ( const std :: vector < std :: vector < size_t >>& polygons ) Same as above, but constructs a manifold surface mesh. SurfaceMesh ( const Eigen :: MatrixBase < T >& faces ) Constructs a mesh from a rectangular face-index matrix, like an Fx3 array of triangle indices, or an Fx4 array of quad indices. The matrix scalar can be any integer type, like size_t or int . The Eigen:MatrixBase<T> type is just a general type which accepts most Eigen matrix types as input, including geometry-central\u2019s nicely-named wrapper DenseMatrix<T> . ManifoldSurfaceMesh ( const Eigen :: MatrixBase < T >& faces ) Same as above, but constructs a manifold surface mesh. ManifoldSurfaceMesh ( const std :: vector < std :: vector < size_t >>& polygons , const std :: vector < std :: vector < std :: tuple < size_t , size_t >>>& twins ) Constructs a mesh from a face-index list, and extra data specifying the neighboring face across each face-side. This extra data allows you to describe meshes where there are multiple, distinct edges between some pair of vertices polygons a list of faces, each holding the indices of the vertices incident on that face, zero-indexed and in counter-clockwise order. twins a list of tuples, in correspondence with the polygons list. For each side of a face, it holds an (iF, iS) tuple, where iF is the index of the face across the edge, and iS is the side of that face (e.g. the iS = 2 for the third side of a triangle). Set both tuple elements to INVALID_IND for boundary sides.","title":"Constructors"},{"location":"surface/surface_mesh/basics/#element-counts","text":"Remember, all functions from SurfaceMesh can also be called on ManifoldSurfaceMesh . size_t SurfaceMesh :: nVertices () Returns the number of vertices. size_t SurfaceMesh :: nInteriorVertices () Returns the number of vertices not incident on the boundary. size_t SurfaceMesh :: nBoundaryVertices () Returns the number of vertices incident on the boundary. size_t SurfaceMesh :: nEdges () Returns the number of edges. size_t SurfaceMesh :: nFaces () Returns the number of faces in the mesh. size_t SurfaceMesh :: nHalfedges () Returns the number of halfedges, including both interior halfedges and any exterior halfedges incident on boundary loops. Always exactly twice the number of edges. size_t SurfaceMesh :: nInterioHalfedges () Returns the number of interior halfedges, which are incident on faces of the mesh. Always equal to the sum of the number of sides of all faces. size_t SurfaceMesh :: nExteriorHalfedges () Returns the number of exterior halfedges, which are opposite boundary faces. size_t SurfaceMesh :: nBoundaryLoops () Returns the number of distinct boundary loops in the mesh, each identified as an fictional face closing a boundary loop in the mesh.","title":"Element counts"},{"location":"surface/surface_mesh/basics/#properties","text":"bool SurfaceMesh :: hasBoundary () Returns true if the mesh has boundary, that is if it is not closed . Complexity \\mathcal{O}(1) \\mathcal{O}(1) . int ManifoldSurfaceMesh :: eulerCharacteristic () Returns the Euler characteristic of the surface. Computed in O(1) from element counts. Note: always computed by naively applying Euler\u2019s polyhedron formula , which might not do what you want in the case of multiple-connected components. int ManifoldSurfaceMesh :: genus () Returns the genus of the surface. Computed in O(1) from element counts. Note: always computed by naively applying Euler\u2019s polyhedron formula , which might not do what you want in the case of multiple connected components. bool SurfaceMesh :: isManifold () Returns true if the mesh is both edge- and vertex- manifold. Note that there is no isVertexManifold() , because a mesh which is edge-nonmanifold is always also vertex-nonmanifold. bool SurfaceMesh :: isEdgeManifold () Returns true if the mesh is both edge-manifold. bool SurfaceMesh :: isOriented () Returns true if all faces have consistent orientations. bool SurfaceMesh :: isTriangular () Returns true if all faces in the mesh have 3 sides. Complexity \\mathcal{O}(n) \\mathcal{O}(n) , do not call in a tight loop. size_t SurfaceMesh :: nConnectedComponents () Returns the number of distinct connected components of the mesh. Complexity \\mathcal{O}(n) \\mathcal{O}(n) , do not call in a tight loop.","title":"Properties"},{"location":"surface/surface_mesh/basics/#utility-functions","text":"std :: vector < std :: vector < size_t >> SurfaceMesh :: getFaceVertexList () Return a listing of the vertex indices incident on each face. DenseMatrix < T > SurfaceMesh :: getFaceVertexMatrix () Return a dense F x D matrix of the vertex indices for each face in the mesh. All faces in the mesh must have the same degree D . This function is templated on the scalar type for the resulting matrix, so call it like DenseMatrix < size_t > F = mesh -> getFaceVertexMatrix < size_t > (); to get a matrix where each entry is a size_t , or like DenseMatrix < int > F = mesh -> getFaceVertexMatrix < int > (); to get a matrix where each entry is an int . Remember that DenseMatrix<T> is just our nice synonym for Eigen:::Matrix . std :: unique_ptr < SurfaceMesh > SurfaceMesh :: copy () const Construct a copy of the mesh. std :: unique_ptr < ManifoldSurfaceMesh > ManifoldSurfaceMesh :: copy () const Construct a copy of the mesh. std :: unique_ptr < SurfaceMesh > SurfaceMesh :: copyToSurfaceMesh () const Construct a copy of the mesh. The underlying type will be the same as the underlying type of the mesh on which it is called. std :: unique_ptr < ManifoldSurfaceMesh > SurfaceMesh :: toManifoldMesh () Convert the mesh to ManifoldSurfaceMesh , which is certainly manifold and oriented. Throws an error if the mesh is not manifold and oriented.","title":"Utility functions"},{"location":"surface/surface_mesh/boundaries/","text":"Mesh boundaries in halfedge meshes are modelled by logically treating each boundary loop as if it were a face with an associated set of halfedges. These halfedges incident on boundary loops are referred to as exterior halfedges , while the usual halfedges incident on faces actually present in the mesh are interior halfedges . Any boundary edge of the mesh will have one interior and one exterior halfedge incident upon it. Manifold Surfaces Only This section largely only applies to ManifoldSurfaceMesh , which has well-defined boundary loops. On a general SurfaceMesh , you can test if an element is along the boundary (like edge.isBoundary() ), but not much else. Exterior halfedges Nearly all routines involving halfedges include both interior and exterior halfedges, as this is most often what is needed in algorithms. HalfedgeData<> containers can hold data on exterior halfedges, and iterators (like Vertex::outgoingHalfedges ) will iterate over both interior and exterior halfedges. A few routines explicitly indicate whether they process interior halfedges, exterior halfedges, or both, such as ManifoldSurfaceMesh::nInteriorHalfedges() . bool Halfedge :: isInterior () Return: true if the halfedge is an interior halfedge, and false if it is an exterior halfedge. Faces and boundary loops The separate type BoundaryLoop is used to represent boundary loops, and offers all functionality of other element types. For instance, the BoundaryLoopData<> container can be used to associate data with boundary loops, and BoundaryLoop::adjacentVertices() can be used to iterate over the vertices along a boundary component. Since boundary loops act like faces in the mesh connectivity, traversing the mesh might yield a \u201cface\u201d referring to what is really a boundary loop. In particular, calling Halfedge::face() on an exterior halfedge will yield the \u201cface\u201d which is its boundary loop. However, this \u201cface\u201d is a lie, we have not really added a face to the mesh: ManifoldSurfaceMesh::nFaces() will still report the actual number of faces, etc. The only valid thing to do with a Face which actually a boundary loop is to immediately convert it to a BoundaryLoop , See the example below. Halfedge myHe = /* some exterior halfedge */ ; assert ( myHe . isInterior () == false ); // this is an exterior halfedge // Traverse to \"face\" Face bFace = myExteriorHalfedge . face () // bFace is really a boundary loop, doing any face things // with it would be invalid assert ( bFace . isBoundaryLoop () == true ) // Convert the \"face\" to its true boundary loop form BoundaryLoop bLoop = bFace . asBoundaryLoop (); // Now we can do all kinds of things with it for ( Edge e : bLoop . adjacentEdges ()) { /* do science */ } bool Face :: isBoundaryLoop () Returns true if the face is really a boundary loop. BoundaryLoop Face :: asBoundaryLoop () Convert a face to the equivalent boundary loop. Only valid to call on a face for which Face::isBoundaryLoop() == true . Face BoundaryLoop :: asFace () Convert a boundary loop back to its equivalent face. The inverse of Face::asBoundaryLoop() . Rarely used. Element boundary properties The previous sections describe elements which make up the boundary of a mesh. The methods here identify elements which merely lie along the mesh boundary. bool Vertex :: isBoundary () Returns true if the vertex is on the boundary. A vertex is on the boundary if any of its incident edges are boundary edges. O(1) O(1) . bool Edge :: isBoundary () Returns true if the edge is on the boundary. An edge is on the boundary if either of its incident halfedges are exterior halfedges. O(1) O(1) . Note that only edges which lie entirely along a boundary are considered boundary edges. Edges which \u201cpoint at\u201d the boundary and touch the boundary only at one endpoint are not considered boundary edges by this function.","title":"Boundaries"},{"location":"surface/surface_mesh/boundaries/#exterior-halfedges","text":"Nearly all routines involving halfedges include both interior and exterior halfedges, as this is most often what is needed in algorithms. HalfedgeData<> containers can hold data on exterior halfedges, and iterators (like Vertex::outgoingHalfedges ) will iterate over both interior and exterior halfedges. A few routines explicitly indicate whether they process interior halfedges, exterior halfedges, or both, such as ManifoldSurfaceMesh::nInteriorHalfedges() . bool Halfedge :: isInterior () Return: true if the halfedge is an interior halfedge, and false if it is an exterior halfedge.","title":"Exterior halfedges"},{"location":"surface/surface_mesh/boundaries/#faces-and-boundary-loops","text":"The separate type BoundaryLoop is used to represent boundary loops, and offers all functionality of other element types. For instance, the BoundaryLoopData<> container can be used to associate data with boundary loops, and BoundaryLoop::adjacentVertices() can be used to iterate over the vertices along a boundary component. Since boundary loops act like faces in the mesh connectivity, traversing the mesh might yield a \u201cface\u201d referring to what is really a boundary loop. In particular, calling Halfedge::face() on an exterior halfedge will yield the \u201cface\u201d which is its boundary loop. However, this \u201cface\u201d is a lie, we have not really added a face to the mesh: ManifoldSurfaceMesh::nFaces() will still report the actual number of faces, etc. The only valid thing to do with a Face which actually a boundary loop is to immediately convert it to a BoundaryLoop , See the example below. Halfedge myHe = /* some exterior halfedge */ ; assert ( myHe . isInterior () == false ); // this is an exterior halfedge // Traverse to \"face\" Face bFace = myExteriorHalfedge . face () // bFace is really a boundary loop, doing any face things // with it would be invalid assert ( bFace . isBoundaryLoop () == true ) // Convert the \"face\" to its true boundary loop form BoundaryLoop bLoop = bFace . asBoundaryLoop (); // Now we can do all kinds of things with it for ( Edge e : bLoop . adjacentEdges ()) { /* do science */ } bool Face :: isBoundaryLoop () Returns true if the face is really a boundary loop. BoundaryLoop Face :: asBoundaryLoop () Convert a face to the equivalent boundary loop. Only valid to call on a face for which Face::isBoundaryLoop() == true . Face BoundaryLoop :: asFace () Convert a boundary loop back to its equivalent face. The inverse of Face::asBoundaryLoop() . Rarely used.","title":"Faces and boundary loops"},{"location":"surface/surface_mesh/boundaries/#element-boundary-properties","text":"The previous sections describe elements which make up the boundary of a mesh. The methods here identify elements which merely lie along the mesh boundary. bool Vertex :: isBoundary () Returns true if the vertex is on the boundary. A vertex is on the boundary if any of its incident edges are boundary edges. O(1) O(1) . bool Edge :: isBoundary () Returns true if the edge is on the boundary. An edge is on the boundary if either of its incident halfedges are exterior halfedges. O(1) O(1) . Note that only edges which lie entirely along a boundary are considered boundary edges. Edges which \u201cpoint at\u201d the boundary and touch the boundary only at one endpoint are not considered boundary edges by this function.","title":"Element boundary properties"},{"location":"surface/surface_mesh/containers/","text":"The halfedge mesh class is equipped with a system of containers for associating data with mesh vertices, halfedges, edges, and faces. For instance, to represent a scalar value at vertices, or a vector value at faces, one can use // on vertices VertexData < double > myVertexScalar ( mesh ); Vertex v = /* some vertex */ ; myVertexScalar [ v ] = 42. ; // on faces FaceData < Vector3 > myFaceVector ( mesh ); Face f = /* some face */ ; myFaceVector [ f ] = Vector3 { 1. , 2. , 3. }; and so on. A key feature of the MeshData<> containers is that they automatically adapt to mutation of the underlying mesh . All existing MeshData<> containers will remain valid during any sequence of mesh element insertions and deletions, adaptively and efficiently resizing themselves as needed. These containers can also be automatically written to file . Mesh data types The mesh data types are all templated on a common base class: MeshData<E,T> , where E is an element pointer type (such as Vertex ) and T is a scalar type (such as double ). The first template argument should usually be omitted in user code; the various element containers are all typedef\u2019d with concise names as follows: VertexData<T> data at vertices HalfedgeData<T> data at (interior and exterior) halfedges CornerData<T> data at corners EdgeData<T> data at edges FaceData<T> data at faces BoundaryLoopData<T> data at boundary loops Most functionality is identical between all of these classes, so the sections below are written in terms of the generic MeshData<> class. Construction MeshData < E , T >:: MeshData < E , T > ( SurfaceMesh & mesh ) Construct a new container over a mesh. Elements will be default-initialized with T() . MeshData < E , T >:: MeshData < E , T > ( SurfaceMesh & mesh , T initVal ) Construct a new container over a mesh. Elements will be initialized with initVal , and any newly-created mesh elements will have their default values set to initVal . Additionally, see the vector-based initializers in vector interoperability . Accessors T & MeshData < E , T >:: operator []( E ptr ) Access data stored in the container with a reference to a mesh element. A const version also exists; expect semantics like std::vector<> . For example: // on vertices VertexData < double > myVertexScalar ( mesh ); Vertex v = /* some vertex */ ; myVertexScalar [ v ] = 42. ; double val = myVertexScalar [ v ]; T & MeshData < E , T >:: operator []( size_t ind ) Access data stored in the container by the index of a mesh element. A const version also exists; expect semantics like std::vector<> . Only valid when the underlying mesh is compressed . Must have 0 <= ind < N , where N is the number of elements of that type. For example: // on vertices VertexData < double > myVertexScalar ( mesh ); myVertexScalar [ 11 ] = 42. ; double val = myVertexScalar [ 11 ]; // equivalent to: double val = myVertexScalar [ mesh -> vertex ( 11 )]; void MeshData < E , T >:: fill ( T fillVal ) Fill all entries in the container with fillVal . size_t MeshData < E , T >:: size () The size of the underlying buffer for the container. In particular, the largest integer i such that data[i] is safe. Generally on a compressed mesh this is the same as the number of elements of type E , e.g. SurfaceMesh::nVertices() , but on an uncompressed mesh or in the presence of exterior halfedges it may be larger. NOTE: The behavior of this function as changed in recent versions. SurfaceMesh * MeshData < E , T >:: getMesh () const The mesh on which the container is defined. Arithmetic MeshData<> containers support arithmetic operations with each other, and with scalar values. All arithmetic is applied independently to each value in the container, and is only well-defined for containers defined on the same mesh. // add two vertex datas together VertexData < double > A ( * mesh , 1. ); // (sample data, filled with all 1's) VertexData < double > B ( * mesh , 2. ); VertexData < double > C = A + B ; // multiply times a scalar FaceData < double > vals ( * mesh , 1. ); vals *= 12.0 ; // types do not need to be the same, as long as the operation // is well-defined VertexData < float > scales ( * mesh , 2. ); VertexData < Vector3 > vecs ( * mesh , Vector3 { 1. , 2. , 3. }); VertexData < Vector3 > scaledVecs = scales * vecs ; The binary operators +,-,*,/,%,&,|,^,<< ,>>,&&,|| and the unary operators +,-,!,~ are all supported, along with the matching assignment operators like += . Of course, the underlying container entry types must support the operation, and the result of the operation must be compatible with the destination container. Vector interoperability To support easy common-case linear algebra operations, MeshData<> containers support conversion to and from Eigen vector types. The corresponding vectors are indexed according to the indices of the underlying mesh elements, or by a user-supplied index map which maps each elements to a dense set of zero-based indices. Construct from a vector: MeshData < E , T >:: MeshData < E , T > ( SurfaceMesh & mesh Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec ) Construct a new container over a mesh, with the contents of vec . MeshData < E , T >:: MeshData < E , T > ( SurfaceMesh & mesh Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec , MeshData < E , size_t >& indexer ) Construct a new container over a mesh, with the contents of vec , indexed according to indexer . Fill from a vector: void MeshData < E , T >:: fromVector ( Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec ) Fill this container with the contents of vec . void MeshData < E , T >:: fromVector ( Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec , MeshData < E , size_t >& indexer ) Fill this container with the contents of vec , indexed according to indexer . Convert to a vector: Eigen :: Matrix < T , Eigen :: Dynamic , 1 > MeshData < E , T >:: toVector () Return a new std::vector which holds the contents of this container. Detail: this vector will always be a dense listing of values per-element, regardless of whether the mesh is compressed, etc. Therefore, the contents of this vector are not necessarily always identical to the raw underlying buffer via raw() . Even in the case of a compressed mesh, for CornerData<> the resulting vector will omit implicit indices for exterior \u201coutside\u201d corners which may exist on meshes with boundary. Eigen :: Matrix < T , Eigen :: Dynamic , 1 > MeshData < E , T >:: toVector ( MeshData < E , size_t >& indexer ) Return a new vector which holds the contents of this container, indexed according to indexer . See toVector() for more details. Default values All containers track a default value for their elements, which can optionally be set at construction; if not set it is simply T() . After construction this value is significant because it will be used as the value for any newly-created mesh elements if the underlying mesh is mutated. The getter and setter below allow you to modify the default value for an existing container. void MeshData < E , T >:: setDefault ( T newDefault ) Sets a new default value for the container. Does not modify any existing data in the container. T MeshData < E , T >:: getDefault () const Get the current default value for the container. Transferring data MeshData<> containers are defined with respect to a particular mesh object. Sometimes one may need to transfer data defined on one mesh to another, for instance after making a copy of a mesh, or when reading data from file. MeshData < E , T > MeshData < E , T >:: reinterpretTo ( SurfaceMesh & target ) Map data defined on one halfedge mesh to another. The meshes must have the same number of elements, and data will be naively transferred between elements with the same index. Requires that both meshes be compressed . Example usage: SurfaceMesh meshA = /* something */ ; SurfaceMesh meshB = meshA . copy (); FaceData < Vector3 > myDataOnA ( meshA ); /* fill myDataOnA with interesting values */ FaceData < Vector3 > myDataOnB = myDataOnA . reinterpretTo ( meshB ); Advanced features Under the hood, all MeshData<> types use a Eigen::Matrix<T> to store their values. However, the size and indexing indexing are carefully managed in conjunction with the underlying mesh. This vector will only be a dense listing if the mesh is compressed . Eigen :: Matrix < T , Eigen :: Dynamic , 1 >& MeshData < E , T >:: raw () Access the raw underlying Eigen vector of storage. const Eigen :: Matrix < T , Eigen :: Dynamic , 1 >& MeshData < E , T >:: raw () const Access the raw underlying Eigen vector of storage (const).","title":"Containers"},{"location":"surface/surface_mesh/containers/#mesh-data-types","text":"The mesh data types are all templated on a common base class: MeshData<E,T> , where E is an element pointer type (such as Vertex ) and T is a scalar type (such as double ). The first template argument should usually be omitted in user code; the various element containers are all typedef\u2019d with concise names as follows: VertexData<T> data at vertices HalfedgeData<T> data at (interior and exterior) halfedges CornerData<T> data at corners EdgeData<T> data at edges FaceData<T> data at faces BoundaryLoopData<T> data at boundary loops Most functionality is identical between all of these classes, so the sections below are written in terms of the generic MeshData<> class.","title":"Mesh data types"},{"location":"surface/surface_mesh/containers/#construction","text":"MeshData < E , T >:: MeshData < E , T > ( SurfaceMesh & mesh ) Construct a new container over a mesh. Elements will be default-initialized with T() . MeshData < E , T >:: MeshData < E , T > ( SurfaceMesh & mesh , T initVal ) Construct a new container over a mesh. Elements will be initialized with initVal , and any newly-created mesh elements will have their default values set to initVal . Additionally, see the vector-based initializers in vector interoperability .","title":"Construction"},{"location":"surface/surface_mesh/containers/#accessors","text":"T & MeshData < E , T >:: operator []( E ptr ) Access data stored in the container with a reference to a mesh element. A const version also exists; expect semantics like std::vector<> . For example: // on vertices VertexData < double > myVertexScalar ( mesh ); Vertex v = /* some vertex */ ; myVertexScalar [ v ] = 42. ; double val = myVertexScalar [ v ]; T & MeshData < E , T >:: operator []( size_t ind ) Access data stored in the container by the index of a mesh element. A const version also exists; expect semantics like std::vector<> . Only valid when the underlying mesh is compressed . Must have 0 <= ind < N , where N is the number of elements of that type. For example: // on vertices VertexData < double > myVertexScalar ( mesh ); myVertexScalar [ 11 ] = 42. ; double val = myVertexScalar [ 11 ]; // equivalent to: double val = myVertexScalar [ mesh -> vertex ( 11 )]; void MeshData < E , T >:: fill ( T fillVal ) Fill all entries in the container with fillVal . size_t MeshData < E , T >:: size () The size of the underlying buffer for the container. In particular, the largest integer i such that data[i] is safe. Generally on a compressed mesh this is the same as the number of elements of type E , e.g. SurfaceMesh::nVertices() , but on an uncompressed mesh or in the presence of exterior halfedges it may be larger. NOTE: The behavior of this function as changed in recent versions. SurfaceMesh * MeshData < E , T >:: getMesh () const The mesh on which the container is defined.","title":"Accessors"},{"location":"surface/surface_mesh/containers/#arithmetic","text":"MeshData<> containers support arithmetic operations with each other, and with scalar values. All arithmetic is applied independently to each value in the container, and is only well-defined for containers defined on the same mesh. // add two vertex datas together VertexData < double > A ( * mesh , 1. ); // (sample data, filled with all 1's) VertexData < double > B ( * mesh , 2. ); VertexData < double > C = A + B ; // multiply times a scalar FaceData < double > vals ( * mesh , 1. ); vals *= 12.0 ; // types do not need to be the same, as long as the operation // is well-defined VertexData < float > scales ( * mesh , 2. ); VertexData < Vector3 > vecs ( * mesh , Vector3 { 1. , 2. , 3. }); VertexData < Vector3 > scaledVecs = scales * vecs ; The binary operators +,-,*,/,%,&,|,^,<< ,>>,&&,|| and the unary operators +,-,!,~ are all supported, along with the matching assignment operators like += . Of course, the underlying container entry types must support the operation, and the result of the operation must be compatible with the destination container.","title":"Arithmetic"},{"location":"surface/surface_mesh/containers/#vector-interoperability","text":"To support easy common-case linear algebra operations, MeshData<> containers support conversion to and from Eigen vector types. The corresponding vectors are indexed according to the indices of the underlying mesh elements, or by a user-supplied index map which maps each elements to a dense set of zero-based indices. Construct from a vector: MeshData < E , T >:: MeshData < E , T > ( SurfaceMesh & mesh Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec ) Construct a new container over a mesh, with the contents of vec . MeshData < E , T >:: MeshData < E , T > ( SurfaceMesh & mesh Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec , MeshData < E , size_t >& indexer ) Construct a new container over a mesh, with the contents of vec , indexed according to indexer . Fill from a vector: void MeshData < E , T >:: fromVector ( Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec ) Fill this container with the contents of vec . void MeshData < E , T >:: fromVector ( Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec , MeshData < E , size_t >& indexer ) Fill this container with the contents of vec , indexed according to indexer . Convert to a vector: Eigen :: Matrix < T , Eigen :: Dynamic , 1 > MeshData < E , T >:: toVector () Return a new std::vector which holds the contents of this container. Detail: this vector will always be a dense listing of values per-element, regardless of whether the mesh is compressed, etc. Therefore, the contents of this vector are not necessarily always identical to the raw underlying buffer via raw() . Even in the case of a compressed mesh, for CornerData<> the resulting vector will omit implicit indices for exterior \u201coutside\u201d corners which may exist on meshes with boundary. Eigen :: Matrix < T , Eigen :: Dynamic , 1 > MeshData < E , T >:: toVector ( MeshData < E , size_t >& indexer ) Return a new vector which holds the contents of this container, indexed according to indexer . See toVector() for more details.","title":"Vector interoperability"},{"location":"surface/surface_mesh/containers/#default-values","text":"All containers track a default value for their elements, which can optionally be set at construction; if not set it is simply T() . After construction this value is significant because it will be used as the value for any newly-created mesh elements if the underlying mesh is mutated. The getter and setter below allow you to modify the default value for an existing container. void MeshData < E , T >:: setDefault ( T newDefault ) Sets a new default value for the container. Does not modify any existing data in the container. T MeshData < E , T >:: getDefault () const Get the current default value for the container.","title":"Default values"},{"location":"surface/surface_mesh/containers/#transferring-data","text":"MeshData<> containers are defined with respect to a particular mesh object. Sometimes one may need to transfer data defined on one mesh to another, for instance after making a copy of a mesh, or when reading data from file. MeshData < E , T > MeshData < E , T >:: reinterpretTo ( SurfaceMesh & target ) Map data defined on one halfedge mesh to another. The meshes must have the same number of elements, and data will be naively transferred between elements with the same index. Requires that both meshes be compressed . Example usage: SurfaceMesh meshA = /* something */ ; SurfaceMesh meshB = meshA . copy (); FaceData < Vector3 > myDataOnA ( meshA ); /* fill myDataOnA with interesting values */ FaceData < Vector3 > myDataOnB = myDataOnA . reinterpretTo ( meshB );","title":"Transferring data"},{"location":"surface/surface_mesh/containers/#advanced-features","text":"Under the hood, all MeshData<> types use a Eigen::Matrix<T> to store their values. However, the size and indexing indexing are carefully managed in conjunction with the underlying mesh. This vector will only be a dense listing if the mesh is compressed . Eigen :: Matrix < T , Eigen :: Dynamic , 1 >& MeshData < E , T >:: raw () Access the raw underlying Eigen vector of storage. const Eigen :: Matrix < T , Eigen :: Dynamic , 1 >& MeshData < E , T >:: raw () const Access the raw underlying Eigen vector of storage (const).","title":"Advanced features"},{"location":"surface/surface_mesh/delta_complex/","text":"TL;DR This section clarifies some formal mathematical ideas that may arise in advanced usage of the halfedge mesh class. If you are simply loading up a triangle mesh and running an ordinary geometry processing algorithm, you need not worry about these details\u2014everything will behave as expected . If you are implementing intrinsic triangulation algorithms, doing an unreasonable number of edge flips, or are simply curious: read on! Introduction Halfedge meshes are often used to represent simplicial complexes . When you\u2019re thinking about a triangle mesh, you probably imagine a simplicial complex: each face has three distinct vertices and three distinct edges, each edge connects two distinct vertices, and there can be at most one edge between any pair of vertices. In fact, halfedge meshes (unlike many other mesh representations) can actually represent more general structures than just simplicial complexes. Halfedges meshes can represent any (oriented, manifold) \\Delta \\Delta -complex 1 . Intuitively, the \\Delta \\Delta -complex relaxes the restriction that incident elements be unique: a face may be incident on the same vertex multiple times an edge may connect a vertex to itself there may be multiple edges between a pair of vertices However, the \\Delta \\Delta -complex still requires that every faces has 3 sides, and the manifold restriction still means that the complex looks like a surface in any local neighborhood. Recall that we are only concerned with the connectivity of these surfaces, not how they sit in space: these general \\Delta \\Delta -complexes might be impossible to embed with straight edges between vertex positions in \\mathbb{R}^3 \\mathbb{R}^3 , but that does not bother us right now. The following surfaces are \\Delta \\Delta -complexes but not simplicial complexes: That sounds complicated, why would you do that? Don\u2019t forget, \\Delta \\Delta -complexes are a superset of simplicial complexes, so everything that works on general \\Delta \\Delta -complexes will work on a plain old triangle mesh too. Buy why go to the extra trouble to support general \\Delta \\Delta -complexes in geometry central? General \\Delta \\Delta -complexes allow extremely powerful algorithms for intrinsic geometry processing. Most famously, the intrinsic Delaunay formulation 2 builds a Laplace operator for an input triangle mesh which has fantastic numerical and computational properties, and the algorithm requires representing a \\Delta \\Delta -complex as an intermediate step. More generally, intrinsic triangulations 3 enable computational geometry algorithms like Delaunay refinement on triangle meshes, so long as long as one can represent \\Delta \\Delta -complexes which arise in intermediate steps. In both of these examples, features like self-edges are rare, and do not occur on most inputs. However, supporting them is necessary for the robustness and correctness of the algorithm. Fortunately, working in a software library which already supports the nuances of \\Delta \\Delta -complexes means these powerful algorithms can be implemented with little additional work. Software support The halfedge mesh class in geometry central is explicitly designed to ensure support for \\Delta \\Delta -complexes, rather than just simplicial complexes. Mostly, this is a natural consequence of the halfedge mesh formulation, but special care is needed for a few operations like mutations and automatically written to file . Wherever relevant, the API will note its special properties with respect to \\Delta \\Delta -complexes. see Section 2.1 of Algebraic Topology by Allen Hatcher \u21a9 Bobenko, Alexander I., and Boris A. Springborn. A discrete Laplace\u2013Beltrami operator for simplicial surfaces. Discrete & Computational Geometry (2007) \u21a9 Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan. Navigating Intrinsic Triangulations . ACM Trans. Graph. (2019) \u21a9","title":"Delta Complexes"},{"location":"surface/surface_mesh/delta_complex/#introduction","text":"Halfedge meshes are often used to represent simplicial complexes . When you\u2019re thinking about a triangle mesh, you probably imagine a simplicial complex: each face has three distinct vertices and three distinct edges, each edge connects two distinct vertices, and there can be at most one edge between any pair of vertices. In fact, halfedge meshes (unlike many other mesh representations) can actually represent more general structures than just simplicial complexes. Halfedges meshes can represent any (oriented, manifold) \\Delta \\Delta -complex 1 . Intuitively, the \\Delta \\Delta -complex relaxes the restriction that incident elements be unique: a face may be incident on the same vertex multiple times an edge may connect a vertex to itself there may be multiple edges between a pair of vertices However, the \\Delta \\Delta -complex still requires that every faces has 3 sides, and the manifold restriction still means that the complex looks like a surface in any local neighborhood. Recall that we are only concerned with the connectivity of these surfaces, not how they sit in space: these general \\Delta \\Delta -complexes might be impossible to embed with straight edges between vertex positions in \\mathbb{R}^3 \\mathbb{R}^3 , but that does not bother us right now. The following surfaces are \\Delta \\Delta -complexes but not simplicial complexes:","title":"Introduction"},{"location":"surface/surface_mesh/delta_complex/#that-sounds-complicated-why-would-you-do-that","text":"Don\u2019t forget, \\Delta \\Delta -complexes are a superset of simplicial complexes, so everything that works on general \\Delta \\Delta -complexes will work on a plain old triangle mesh too. Buy why go to the extra trouble to support general \\Delta \\Delta -complexes in geometry central? General \\Delta \\Delta -complexes allow extremely powerful algorithms for intrinsic geometry processing. Most famously, the intrinsic Delaunay formulation 2 builds a Laplace operator for an input triangle mesh which has fantastic numerical and computational properties, and the algorithm requires representing a \\Delta \\Delta -complex as an intermediate step. More generally, intrinsic triangulations 3 enable computational geometry algorithms like Delaunay refinement on triangle meshes, so long as long as one can represent \\Delta \\Delta -complexes which arise in intermediate steps. In both of these examples, features like self-edges are rare, and do not occur on most inputs. However, supporting them is necessary for the robustness and correctness of the algorithm. Fortunately, working in a software library which already supports the nuances of \\Delta \\Delta -complexes means these powerful algorithms can be implemented with little additional work.","title":"That sounds complicated, why would you do that?"},{"location":"surface/surface_mesh/delta_complex/#software-support","text":"The halfedge mesh class in geometry central is explicitly designed to ensure support for \\Delta \\Delta -complexes, rather than just simplicial complexes. Mostly, this is a natural consequence of the halfedge mesh formulation, but special care is needed for a few operations like mutations and automatically written to file . Wherever relevant, the API will note its special properties with respect to \\Delta \\Delta -complexes. see Section 2.1 of Algebraic Topology by Allen Hatcher \u21a9 Bobenko, Alexander I., and Boris A. Springborn. A discrete Laplace\u2013Beltrami operator for simplicial surfaces. Discrete & Computational Geometry (2007) \u21a9 Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan. Navigating Intrinsic Triangulations . ACM Trans. Graph. (2019) \u21a9","title":"Software support"},{"location":"surface/surface_mesh/elements/","text":"Introduction This section covers the elements types for our surface mesh, as well as the traversal and utility functions that they offer. Note In the most proper sense, these element types are really \u201chandles\u201d to the underlying element. They refer to a particular element, but the Vertex variable in memory is not really the mesh element itself, just a temporary reference to it. For instance, it is possible (and common) to have multiple Vertex variables which actually refer to the same vertex, and allowing a Vertex variable to go out of scope certainly does not delete the vertex in the mesh. However, the semantics are very natural, so for the sake of brevity we call the type simply Vertex , rather than VertexHandle (etc). Additionally, see navigation for iterators to travese adjacent elements, like for(Vertex v : face.adjacentVertices()) . Construction Element types do not have constructors which should be called by the user. Instead, the element will always be created for you, via one of several methods, including: Iterating through the mesh for(Vertex v : mesh.vertices()) Traversing from a neighbor element Face f = halfedge.face() Iterating around an element for(Halfedge he : vertex.outgoingHalfedges()) Adding a new element to a mesh is covered in the mutation section . Comparison & Hashing All mesh elements support: equality checks ( == , != ) comparions ( < , > , <= , >= , according to the iteration order of the elements) hashing (so they can be used in a std::unordered_map ) Vertex A vertex is a 0-dimensional point which serves as a node in the mesh. Traversal: Halfedge Vertex :: halfedge () Returns one of the halfedges whose tail is incident on this vertex. If the vertex is a boundary vertex, then it is guaranteed that the returned halfedge will be the unique interior halfedge along the boundary. That is the unique halfedge such that vertex.halfedge().twin().isInterior() == false . Corner Vertex :: corner () Returns one of the corners incident on the vertex. Utility: bool Vertex :: isBoundary () Returns true if the vertex is along the boundary of the mesh. See boundaries for more information. bool Vertex :: isManifold () Returns true if the vertex neighborhood is manifold. bool Vertex :: isManifoldAndOriented () Returns true if the vertex neighborhood is manifold, and all faces have consistent orientations. size_t Vertex :: degree () The degree of the vertex, i.e. the number of edges incident on the vertex. size_t Vertex :: faceDegree () The face-degree of the vertex, i.e. the number of faces incident on the vertex. On the interior of a mesh, this will be equal to Vertex::degree() , at the boundary it will be smaller by one. Halfedge A halfedge is a the basic building block of a halfedge mesh. As its name suggests, the halfedge is half of an edge , connecting two vertices and sitting on on side of an edge in some face. The halfedge is directed, from its tail , to its tip . Our halfedges have a counter-clockwise orientation: the halfedges with in a face will always point in the counter-clockwise direction. On a ManifoldSurfaceMesh , a halfedge and its twin (the neighbor across an edge) will point in opposite directions. Traversal: Halfedge Halfedge :: twin () Returns the halfedge\u2019s twin , a neighbor across an edge. See notes in sibling() . On a ManifoldSurfaceMesh , it will point in the opposite direction. Calling twin twice will always return to the initial halfedge: halfedge.twin().twin() == halfedge . Halfedge Halfedge :: sibling () A synonym for twin() , which makes it clear that on a general SurfaceMesh which is not manifold there may be many halfedges incident on an edge. Calling sibling() repeatedly orbits around these halfedges. Halfedge Halfedge :: next () Returns the next halfedge in the same face as this halfedge, according to the counter-clockwise ordering. Vertex Halfedge :: vertex () Returns the vertex at the tail of this halfedge. Vertex Halfedge :: tailVertex () Returns the vertex at the tail of this halfedge. Vertex Halfedge :: tipVertex () Returns the vertex at the tip of this halfedge. Edge Halfedge :: edge () Returns the edge that this halfedge sits along. Face Halfedge :: face () Returns the face that this halfedge sits inside. Note that in the case of a mesh with boundary, if the halfedge is exterior the result of this function will really be a boundary loop. See boundaries for more information. Corner Halfedge :: corner () Returns the corner at the tail of this halfedge. Fancy Traversal: Halfedge Halfedge :: prevOrbitFace () Returns the previous halfedge, that is the halfedge such that he.next() == *this . This result is found by orbiting around the shared face. Because our halfedge mesh is singly-connected, this is not a simple O(1) O(1) lookup, but must be computed by orbiting around the face. Be careful: calling he.prevOrbitFace() on each exterior halfedge can easily lead to O(N^2) O(N^2) algorithm complexity, as each call walks all the way around a a boundary loop. Generally this operation can (and should) be avoided with proper code structure. Utility: bool Halfedge :: isInterior () Returns true if the edge is interior , and false if it is exterior (i.e., incident on a boundary loop). See boundaries for more information. bool Halfedge :: orientation () Returns true if the halfedge points in the same direction as the arbitrary orientation defined at each edge. For instance, for two halfedges incident on the same edge, you can test if they point in the same direction by checking heA.orientation() == heB.orientation() . Recall that two halfedges will point in the same direction along an edge when their respective faces have opposite orientation. Edge An edge is a 1-dimensional element that connects two vertices in the mesh. Traversal: Halfedge Edge :: halfedge () Returns one of the two halfedges incident on this edge. If the edge is a boundary edge, it is guaranteed that the returned edge will be the interior one. Vertex Edge :: otherVertex ( Vertex v ) Of the two vertices incident on the edge, returns the one which is not v . If both incident vertices are v , returns v . Vertex Edge :: firstVertex () Returns one of the two vertices incident on the edge. In particular, returns edge.halfedge().tailVertex() . See also: Edge::secondVertex() . Vertex Edge :: secondVertex () Returns one of the two vertices incident on the edge. In particular, returns edge.halfedge().tipVertex() . See also: Edge::firstVertex() . Utility: bool Edge :: isBoundary () Returns true if the edge is along the boundary of the mesh. Note that edges which merely touch the boundary at one endpoint are not considered to be boundary edges. See boundaries for more information. bool Edge :: isOriented () Returns true if the faces on either side have matching orientations. A nonmanifold edge is never oriented. size_t Edge :: degree () Returns the number of faces indcident on the edge. Face A face is a 2-dimensional element formed by a loop of 3 or more edges. In general, our faces can be polygonal with d \\ge 3 d \\ge 3 edges, though many of the routines in geometry central are only valid on triangular meshes. Traversal: Halfedge Face :: halfedge () Returns any one of the halfedges inside of this face. BoundaryLoop Face :: asBoundaryLoop () Reinterprets this element as a boundary loop. Only valid if the face is, in fact, a boundary loop. See boundaries for more information. Utility: bool Face :: isBoundaryLoop () Returns true if the face is really a boundary loop. See boundaries for more information. bool Face :: isTriangle () Returns true if the face has three sides. size_t Face :: degree () Returns the number of sides in the face. Complexity O(d) O(d) , where d d is the resulting degree. Boundary Loop A boundary loop is a special face-like element used to represent holes in the mesh due to surface boundary. These are only defined on a ManifoldSurfaceMesh , which necessarily has coherent boundary loops. See boundaries for more information. Traversal: Halfedge BoundaryLoop :: halfedge () Returns any one of the halfedges inside of the boundary loop. Utility: size_t BoundaryLoop :: degree () Returns the number of sides in the boundary loop. Complexity O(d) O(d) , where d d is the resulting degree. Corner A corner is a convenience type referring to a corner inside of a face. Tracking corners as a separate type is useful, because one often logically represents data defined at corners. Traversal: Halfedge Corner :: halfedge () Returns the halfedge whose tail touches this corner. That is to say, corner.halfedge().vertex() == corner.vertex() . Vertex Corner :: vertex () Returns the vertex which this corner is incident on. Face Corner :: face () Returns the face that this corner sits inside of.","title":"Elements"},{"location":"surface/surface_mesh/elements/#introduction","text":"This section covers the elements types for our surface mesh, as well as the traversal and utility functions that they offer. Note In the most proper sense, these element types are really \u201chandles\u201d to the underlying element. They refer to a particular element, but the Vertex variable in memory is not really the mesh element itself, just a temporary reference to it. For instance, it is possible (and common) to have multiple Vertex variables which actually refer to the same vertex, and allowing a Vertex variable to go out of scope certainly does not delete the vertex in the mesh. However, the semantics are very natural, so for the sake of brevity we call the type simply Vertex , rather than VertexHandle (etc). Additionally, see navigation for iterators to travese adjacent elements, like for(Vertex v : face.adjacentVertices()) .","title":"Introduction"},{"location":"surface/surface_mesh/elements/#construction","text":"Element types do not have constructors which should be called by the user. Instead, the element will always be created for you, via one of several methods, including: Iterating through the mesh for(Vertex v : mesh.vertices()) Traversing from a neighbor element Face f = halfedge.face() Iterating around an element for(Halfedge he : vertex.outgoingHalfedges()) Adding a new element to a mesh is covered in the mutation section .","title":"Construction"},{"location":"surface/surface_mesh/elements/#comparison-hashing","text":"All mesh elements support: equality checks ( == , != ) comparions ( < , > , <= , >= , according to the iteration order of the elements) hashing (so they can be used in a std::unordered_map )","title":"Comparison &amp; Hashing"},{"location":"surface/surface_mesh/elements/#vertex","text":"A vertex is a 0-dimensional point which serves as a node in the mesh. Traversal: Halfedge Vertex :: halfedge () Returns one of the halfedges whose tail is incident on this vertex. If the vertex is a boundary vertex, then it is guaranteed that the returned halfedge will be the unique interior halfedge along the boundary. That is the unique halfedge such that vertex.halfedge().twin().isInterior() == false . Corner Vertex :: corner () Returns one of the corners incident on the vertex. Utility: bool Vertex :: isBoundary () Returns true if the vertex is along the boundary of the mesh. See boundaries for more information. bool Vertex :: isManifold () Returns true if the vertex neighborhood is manifold. bool Vertex :: isManifoldAndOriented () Returns true if the vertex neighborhood is manifold, and all faces have consistent orientations. size_t Vertex :: degree () The degree of the vertex, i.e. the number of edges incident on the vertex. size_t Vertex :: faceDegree () The face-degree of the vertex, i.e. the number of faces incident on the vertex. On the interior of a mesh, this will be equal to Vertex::degree() , at the boundary it will be smaller by one.","title":"Vertex"},{"location":"surface/surface_mesh/elements/#halfedge","text":"A halfedge is a the basic building block of a halfedge mesh. As its name suggests, the halfedge is half of an edge , connecting two vertices and sitting on on side of an edge in some face. The halfedge is directed, from its tail , to its tip . Our halfedges have a counter-clockwise orientation: the halfedges with in a face will always point in the counter-clockwise direction. On a ManifoldSurfaceMesh , a halfedge and its twin (the neighbor across an edge) will point in opposite directions. Traversal: Halfedge Halfedge :: twin () Returns the halfedge\u2019s twin , a neighbor across an edge. See notes in sibling() . On a ManifoldSurfaceMesh , it will point in the opposite direction. Calling twin twice will always return to the initial halfedge: halfedge.twin().twin() == halfedge . Halfedge Halfedge :: sibling () A synonym for twin() , which makes it clear that on a general SurfaceMesh which is not manifold there may be many halfedges incident on an edge. Calling sibling() repeatedly orbits around these halfedges. Halfedge Halfedge :: next () Returns the next halfedge in the same face as this halfedge, according to the counter-clockwise ordering. Vertex Halfedge :: vertex () Returns the vertex at the tail of this halfedge. Vertex Halfedge :: tailVertex () Returns the vertex at the tail of this halfedge. Vertex Halfedge :: tipVertex () Returns the vertex at the tip of this halfedge. Edge Halfedge :: edge () Returns the edge that this halfedge sits along. Face Halfedge :: face () Returns the face that this halfedge sits inside. Note that in the case of a mesh with boundary, if the halfedge is exterior the result of this function will really be a boundary loop. See boundaries for more information. Corner Halfedge :: corner () Returns the corner at the tail of this halfedge. Fancy Traversal: Halfedge Halfedge :: prevOrbitFace () Returns the previous halfedge, that is the halfedge such that he.next() == *this . This result is found by orbiting around the shared face. Because our halfedge mesh is singly-connected, this is not a simple O(1) O(1) lookup, but must be computed by orbiting around the face. Be careful: calling he.prevOrbitFace() on each exterior halfedge can easily lead to O(N^2) O(N^2) algorithm complexity, as each call walks all the way around a a boundary loop. Generally this operation can (and should) be avoided with proper code structure. Utility: bool Halfedge :: isInterior () Returns true if the edge is interior , and false if it is exterior (i.e., incident on a boundary loop). See boundaries for more information. bool Halfedge :: orientation () Returns true if the halfedge points in the same direction as the arbitrary orientation defined at each edge. For instance, for two halfedges incident on the same edge, you can test if they point in the same direction by checking heA.orientation() == heB.orientation() . Recall that two halfedges will point in the same direction along an edge when their respective faces have opposite orientation.","title":"Halfedge"},{"location":"surface/surface_mesh/elements/#edge","text":"An edge is a 1-dimensional element that connects two vertices in the mesh. Traversal: Halfedge Edge :: halfedge () Returns one of the two halfedges incident on this edge. If the edge is a boundary edge, it is guaranteed that the returned edge will be the interior one. Vertex Edge :: otherVertex ( Vertex v ) Of the two vertices incident on the edge, returns the one which is not v . If both incident vertices are v , returns v . Vertex Edge :: firstVertex () Returns one of the two vertices incident on the edge. In particular, returns edge.halfedge().tailVertex() . See also: Edge::secondVertex() . Vertex Edge :: secondVertex () Returns one of the two vertices incident on the edge. In particular, returns edge.halfedge().tipVertex() . See also: Edge::firstVertex() . Utility: bool Edge :: isBoundary () Returns true if the edge is along the boundary of the mesh. Note that edges which merely touch the boundary at one endpoint are not considered to be boundary edges. See boundaries for more information. bool Edge :: isOriented () Returns true if the faces on either side have matching orientations. A nonmanifold edge is never oriented. size_t Edge :: degree () Returns the number of faces indcident on the edge.","title":"Edge"},{"location":"surface/surface_mesh/elements/#face","text":"A face is a 2-dimensional element formed by a loop of 3 or more edges. In general, our faces can be polygonal with d \\ge 3 d \\ge 3 edges, though many of the routines in geometry central are only valid on triangular meshes. Traversal: Halfedge Face :: halfedge () Returns any one of the halfedges inside of this face. BoundaryLoop Face :: asBoundaryLoop () Reinterprets this element as a boundary loop. Only valid if the face is, in fact, a boundary loop. See boundaries for more information. Utility: bool Face :: isBoundaryLoop () Returns true if the face is really a boundary loop. See boundaries for more information. bool Face :: isTriangle () Returns true if the face has three sides. size_t Face :: degree () Returns the number of sides in the face. Complexity O(d) O(d) , where d d is the resulting degree.","title":"Face"},{"location":"surface/surface_mesh/elements/#boundary-loop","text":"A boundary loop is a special face-like element used to represent holes in the mesh due to surface boundary. These are only defined on a ManifoldSurfaceMesh , which necessarily has coherent boundary loops. See boundaries for more information. Traversal: Halfedge BoundaryLoop :: halfedge () Returns any one of the halfedges inside of the boundary loop. Utility: size_t BoundaryLoop :: degree () Returns the number of sides in the boundary loop. Complexity O(d) O(d) , where d d is the resulting degree.","title":"Boundary Loop"},{"location":"surface/surface_mesh/elements/#corner","text":"A corner is a convenience type referring to a corner inside of a face. Tracking corners as a separate type is useful, because one often logically represents data defined at corners. Traversal: Halfedge Corner :: halfedge () Returns the halfedge whose tail touches this corner. That is to say, corner.halfedge().vertex() == corner.vertex() . Vertex Corner :: vertex () Returns the vertex which this corner is incident on. Face Corner :: face () Returns the face that this corner sits inside of.","title":"Corner"},{"location":"surface/surface_mesh/internals/","text":"Halfedge mesh internals This section contains details about the internal implementation of the halfedge mesh data structure. Typical users should not need to care about these details, but they may be useful for extension and debugging. The halfedge mesh structure is designed to simultaneously satisfy two core principles: contiguous storage: elements and mesh data are stored in flat buffers of memory. This makes traversing and storing data on the mesh fast. O(1) updates: dynamic operations that add and remove new elements must be supported in (amortized) constant time. This makes modifying the mesh fast. The solution to these two requirements is a dynamically-resizing, array-based mesh. Like a std::vector , elements are stored in contiguous buffers of memory, which are transparently expanded and copied sporadically. Of course, this expansion is largely hidden from the user. Philosophically, our halfedge mesh aims to be as-implicit-as-possible : whenever we can, we represent connectivity and properties implicitly by indices. Although this strategy runs the risk of being \u201coverly clever\u201d programming, it has proven effective for two reasons. First, anything tracked explicitly and stored an array is a liability if that array is not updated properly\u2014conversely implicit relationships can be abstracted away behind helper functions, and need not be carefully maintained. Second, implicit relationships tend to lead fast implementations out of the box, avoiding performance hacking which runs a huge risk of breaking correctness. Permutation halfedge mesh Here\u2019s a neat fact: a halfedge mesh can be represented by a single permutation of length nHalfedges . How? First, consider an enumeration of the halfedges. We can implicitly encode the twin() relationship by storing twinned halfedges adjacent to one another\u2013 that is, the twin of an even-numbered halfedge numbered he is he+1 , and the twin of and odd-numbered halfedge is he-1 . We then use the permutation to encode the next() relationships. The faces are the orbits of the next() operation, enumerated in the order they are encountered. The edges are the orbits of the twin() operation, which can be enumerated implicitly from the index. The vertices are the orbits of the twin().next() operation, again enumerated in the order they are encountered. This idea of a permutation is essentially the representation used for our halfedge mesh data structure: a single permutation array encodes the next() map, while the twin() , edge() , and edge.halfedge() maps are implicitly defined. However, although vertices and faces could be represented implicitly by an enumeration of orbits, doing so is inconvenient and expensive to update. Instead, we include additional arrays storing the he.vertex() , he.face() , v.halfedge() and f.halfedge() maps which are explicitly maintained. Basic structures Our halfedge mesh is index-based. Each {halfedge,edge,vertex,face} is identified by a 0-based index. The SurfaceMesh class then holds the following explicit arrays encoding the connectivity between these indexed elements (the remaining relationships are implicitly defined). class SurfaceMesh { ... private: std::vector<size_t> heNext; // for he.next() std::vector<size_t> heVertex; // for he.vertex() std::vector<size_t> heFace; // for he.face() std::vector<size_t> vHalfedge; // for v.halfedge() std::vector<size_t> fHalfedge; // for f.face() ... }; The Halfedge , Vertex , etc. classes serve as typed wrappers referring to a mesh element. These wrappers store the index of the underlying element, as well as pointer to the mesh object itself. Traversal operations like he.next() are either implemented implicitly via index arithmetic, or by lookup in to the appropriate array. class Halfedge { ... size_t ind; SurfaceMesh* mesh; Halfedge next() { return Halfedge{mesh->heNext[ind], mesh}; } // explicit Halfedge twin() { return Halfedge{ind ^ 1, mesh}; } // implicit ... }; Why not pointers? One potential drawback to the index-based design is that each element must store its index as well as a pointer to the underlying mesh data structure. For instance, the smallest possible data layout of Halfedge would look something like struct Halfedge { size_t ind; SurfaceMesh* mesh; }; , because the ind is useless unless we know what arrays to index in to (e.g., to implement next() ). This extra storage could be avoided by replacing size_t ind with a pointer directly to memory encoding data about the halfedge. This design would reduce the sizeof(Halfedge) from 16 bytes to 8, as well as potentially avoiding some offset index instructions. So why don\u2019t we do that instead? In fact, the first implementation of this library used exactly that pointer-based design. However, it turned out to have two main downsides: semantics of pointer invalidation: In C++, doing nearly anything with an invalid pointer incurs undefined behavior, and expanding our buffers invalidates pointers. This meant that an \u201cunder the hood\u201d resize event would invalidate all of the user\u2019s Halfedge objects, necessitating frequent expensive use of DynamicHalfedge , rather than just around compress() as in the current design. implementation complexity: Working with raw pointers makes a lot of easy things hard. Significant pointer gymnastics were needed to internally implement resize operations without running afoul of invalid pointer rules. Simple operations like copying meshes and mesh data required pointer translation. Indexing in to a container essentially required a dense index from the element, so the codebase ended up littered with operations to construct indices from pointer offsets. The cumulative effect was quite error-prone. Ultimately, the index-based design seems preferrable. Invariants In addition to the basic properties of the twin() and next() maps, the halfedge mesh data structure offers a few useful invariants about its indexing scheme which must be maintained by all operations. on a boundary edge, e.halfedge() is the interior halfedge on a boundary vertex, v.halfedge() is the unique real interior halfedge along the boundary (so v.halfedge().twin() is necessarily exterior, and traversing in CCW order walks the wedge) The validateConnectivity() function is extremely useful for checking invariants while developing the data structure. void SurfaceMesh :: validateConnectivity () Perform a lot of sanity checks about the halfedge mesh. Throws if any fail. Resizing and deleting To enable (amortized) \\mathcal{O}(1) \\mathcal{O}(1) mutation, the buffers containing mesh data are lazily reallocated like a std::vector when needed. As such the actual buffers like mesh.heNext might be larger than the current number of elements in the mesh; we separately track the count of real, valid elements to avoid accessing the extra regions of the array. The special index value INVALID_IND (which happens to be std::numeric_limits<size_t>::max() ) is used to fill index values that have no meaning. A similar issue arises with deletion. When a mesh element is deleted, it would be too expensive to shift the indices of all subsequent elements. Instead, we simply mark the element as deleted, leaving a hole in our index space. Deleted halfedges and their edges are implicitly encoded by heNext[he] == INVALID_IND , while deleted edges and vertices are encoded by vHalfedge[v] == INVALID_IND and fHalfedge[f] == INVALID_IND . Thus at any point in time, some indices may be invalid elements, left from previous deletions, and other array entries might correspond to extra elements allocated during the last resizing, waiting to be used. In all iterators and counts, explicit logic ensures that invalid elements are skipped. Traversal functions do not need any such logic, as it should be impossible to traverse from a valid element to an invalid element. The SurfaceMesh::compress() function is provided to re-index all mesh elements, and ensure a dense packing with no deleted elements. The following diagram lays out what this index space might look like. General Surface Meshes To represent more general surfaces meshes which might be nonmanifold or oriented, we augment our representation with a few extra arrays of data. In particular, we depart from implicit indexing schemes, and explicitly store halfedge siblings and edges, as well as each edge\u2019s halfedge. We also store an orientation bit for each halfedge along its edge, and and in implicit linked list of halfedges incident on each vertex. The last of which is particularly unsatisfying, but otherwise iterating around vertices is quite difficult. Exterior boundary elements ( ManifoldSurfaceMesh only) One complexity in our implementation is the existence of exterior boundary elements. Recall that boundaries of our mesh are represented by filling each hole with a single, many-sided boundary loop; the halfedges incident on this face are \u201cexterior\u201d. This definition is convenient because it saves us from constantly special-casing elements on the boundary, but introduces some complexity because the user probably doesn\u2019t want to think about these boundary loops as faces most of the time. Exterior halfedges are enumerated alongside their interior counterparts, and generally are treated just like normal interior halfedges; most routines do not distinguish between the two. In contrast, although boundary loops are just faces internally, the API provides the illusion that they are a distinct type from the faces of the mesh. To enable this treatment, boundary loops are always stored at the back of the face index space. In general, the layout of the allocated index space will consist of first actual mesh faces, then any extra not-yet-used space, and finally boundary loops. Resize callbacks As the halfedge mesh is mutated, all MeshData<> containers automatically resize to stay in sync. This is implemented under the hood with a system of callback functions registered with the mesh itself. Whenever the mesh resizes or compresses one of its index spaces, it invokes a callback for each associated MeshData<> to do the same. DynamicHalfedge and friends also register themselves with the callback system, to stay valid as the mesh resizes. However, this results in a callback per dynamic element, which is why the dynamic elements are more expensive. Fortunately, dynamic elements can be used sparingly.","title":"Internals"},{"location":"surface/surface_mesh/internals/#halfedge-mesh-internals","text":"This section contains details about the internal implementation of the halfedge mesh data structure. Typical users should not need to care about these details, but they may be useful for extension and debugging. The halfedge mesh structure is designed to simultaneously satisfy two core principles: contiguous storage: elements and mesh data are stored in flat buffers of memory. This makes traversing and storing data on the mesh fast. O(1) updates: dynamic operations that add and remove new elements must be supported in (amortized) constant time. This makes modifying the mesh fast. The solution to these two requirements is a dynamically-resizing, array-based mesh. Like a std::vector , elements are stored in contiguous buffers of memory, which are transparently expanded and copied sporadically. Of course, this expansion is largely hidden from the user. Philosophically, our halfedge mesh aims to be as-implicit-as-possible : whenever we can, we represent connectivity and properties implicitly by indices. Although this strategy runs the risk of being \u201coverly clever\u201d programming, it has proven effective for two reasons. First, anything tracked explicitly and stored an array is a liability if that array is not updated properly\u2014conversely implicit relationships can be abstracted away behind helper functions, and need not be carefully maintained. Second, implicit relationships tend to lead fast implementations out of the box, avoiding performance hacking which runs a huge risk of breaking correctness.","title":"Halfedge mesh internals"},{"location":"surface/surface_mesh/internals/#permutation-halfedge-mesh","text":"Here\u2019s a neat fact: a halfedge mesh can be represented by a single permutation of length nHalfedges . How? First, consider an enumeration of the halfedges. We can implicitly encode the twin() relationship by storing twinned halfedges adjacent to one another\u2013 that is, the twin of an even-numbered halfedge numbered he is he+1 , and the twin of and odd-numbered halfedge is he-1 . We then use the permutation to encode the next() relationships. The faces are the orbits of the next() operation, enumerated in the order they are encountered. The edges are the orbits of the twin() operation, which can be enumerated implicitly from the index. The vertices are the orbits of the twin().next() operation, again enumerated in the order they are encountered. This idea of a permutation is essentially the representation used for our halfedge mesh data structure: a single permutation array encodes the next() map, while the twin() , edge() , and edge.halfedge() maps are implicitly defined. However, although vertices and faces could be represented implicitly by an enumeration of orbits, doing so is inconvenient and expensive to update. Instead, we include additional arrays storing the he.vertex() , he.face() , v.halfedge() and f.halfedge() maps which are explicitly maintained.","title":"Permutation halfedge mesh"},{"location":"surface/surface_mesh/internals/#basic-structures","text":"Our halfedge mesh is index-based. Each {halfedge,edge,vertex,face} is identified by a 0-based index. The SurfaceMesh class then holds the following explicit arrays encoding the connectivity between these indexed elements (the remaining relationships are implicitly defined). class SurfaceMesh { ... private: std::vector<size_t> heNext; // for he.next() std::vector<size_t> heVertex; // for he.vertex() std::vector<size_t> heFace; // for he.face() std::vector<size_t> vHalfedge; // for v.halfedge() std::vector<size_t> fHalfedge; // for f.face() ... }; The Halfedge , Vertex , etc. classes serve as typed wrappers referring to a mesh element. These wrappers store the index of the underlying element, as well as pointer to the mesh object itself. Traversal operations like he.next() are either implemented implicitly via index arithmetic, or by lookup in to the appropriate array. class Halfedge { ... size_t ind; SurfaceMesh* mesh; Halfedge next() { return Halfedge{mesh->heNext[ind], mesh}; } // explicit Halfedge twin() { return Halfedge{ind ^ 1, mesh}; } // implicit ... }; Why not pointers? One potential drawback to the index-based design is that each element must store its index as well as a pointer to the underlying mesh data structure. For instance, the smallest possible data layout of Halfedge would look something like struct Halfedge { size_t ind; SurfaceMesh* mesh; }; , because the ind is useless unless we know what arrays to index in to (e.g., to implement next() ). This extra storage could be avoided by replacing size_t ind with a pointer directly to memory encoding data about the halfedge. This design would reduce the sizeof(Halfedge) from 16 bytes to 8, as well as potentially avoiding some offset index instructions. So why don\u2019t we do that instead? In fact, the first implementation of this library used exactly that pointer-based design. However, it turned out to have two main downsides: semantics of pointer invalidation: In C++, doing nearly anything with an invalid pointer incurs undefined behavior, and expanding our buffers invalidates pointers. This meant that an \u201cunder the hood\u201d resize event would invalidate all of the user\u2019s Halfedge objects, necessitating frequent expensive use of DynamicHalfedge , rather than just around compress() as in the current design. implementation complexity: Working with raw pointers makes a lot of easy things hard. Significant pointer gymnastics were needed to internally implement resize operations without running afoul of invalid pointer rules. Simple operations like copying meshes and mesh data required pointer translation. Indexing in to a container essentially required a dense index from the element, so the codebase ended up littered with operations to construct indices from pointer offsets. The cumulative effect was quite error-prone. Ultimately, the index-based design seems preferrable.","title":"Basic structures"},{"location":"surface/surface_mesh/internals/#invariants","text":"In addition to the basic properties of the twin() and next() maps, the halfedge mesh data structure offers a few useful invariants about its indexing scheme which must be maintained by all operations. on a boundary edge, e.halfedge() is the interior halfedge on a boundary vertex, v.halfedge() is the unique real interior halfedge along the boundary (so v.halfedge().twin() is necessarily exterior, and traversing in CCW order walks the wedge) The validateConnectivity() function is extremely useful for checking invariants while developing the data structure. void SurfaceMesh :: validateConnectivity () Perform a lot of sanity checks about the halfedge mesh. Throws if any fail.","title":"Invariants"},{"location":"surface/surface_mesh/internals/#resizing-and-deleting","text":"To enable (amortized) \\mathcal{O}(1) \\mathcal{O}(1) mutation, the buffers containing mesh data are lazily reallocated like a std::vector when needed. As such the actual buffers like mesh.heNext might be larger than the current number of elements in the mesh; we separately track the count of real, valid elements to avoid accessing the extra regions of the array. The special index value INVALID_IND (which happens to be std::numeric_limits<size_t>::max() ) is used to fill index values that have no meaning. A similar issue arises with deletion. When a mesh element is deleted, it would be too expensive to shift the indices of all subsequent elements. Instead, we simply mark the element as deleted, leaving a hole in our index space. Deleted halfedges and their edges are implicitly encoded by heNext[he] == INVALID_IND , while deleted edges and vertices are encoded by vHalfedge[v] == INVALID_IND and fHalfedge[f] == INVALID_IND . Thus at any point in time, some indices may be invalid elements, left from previous deletions, and other array entries might correspond to extra elements allocated during the last resizing, waiting to be used. In all iterators and counts, explicit logic ensures that invalid elements are skipped. Traversal functions do not need any such logic, as it should be impossible to traverse from a valid element to an invalid element. The SurfaceMesh::compress() function is provided to re-index all mesh elements, and ensure a dense packing with no deleted elements. The following diagram lays out what this index space might look like.","title":"Resizing and deleting"},{"location":"surface/surface_mesh/internals/#general-surface-meshes","text":"To represent more general surfaces meshes which might be nonmanifold or oriented, we augment our representation with a few extra arrays of data. In particular, we depart from implicit indexing schemes, and explicitly store halfedge siblings and edges, as well as each edge\u2019s halfedge. We also store an orientation bit for each halfedge along its edge, and and in implicit linked list of halfedges incident on each vertex. The last of which is particularly unsatisfying, but otherwise iterating around vertices is quite difficult.","title":"General Surface Meshes"},{"location":"surface/surface_mesh/internals/#exterior-boundary-elements","text":"( ManifoldSurfaceMesh only) One complexity in our implementation is the existence of exterior boundary elements. Recall that boundaries of our mesh are represented by filling each hole with a single, many-sided boundary loop; the halfedges incident on this face are \u201cexterior\u201d. This definition is convenient because it saves us from constantly special-casing elements on the boundary, but introduces some complexity because the user probably doesn\u2019t want to think about these boundary loops as faces most of the time. Exterior halfedges are enumerated alongside their interior counterparts, and generally are treated just like normal interior halfedges; most routines do not distinguish between the two. In contrast, although boundary loops are just faces internally, the API provides the illusion that they are a distinct type from the faces of the mesh. To enable this treatment, boundary loops are always stored at the back of the face index space. In general, the layout of the allocated index space will consist of first actual mesh faces, then any extra not-yet-used space, and finally boundary loops.","title":"Exterior boundary elements"},{"location":"surface/surface_mesh/internals/#resize-callbacks","text":"As the halfedge mesh is mutated, all MeshData<> containers automatically resize to stay in sync. This is implemented under the hood with a system of callback functions registered with the mesh itself. Whenever the mesh resizes or compresses one of its index spaces, it invokes a callback for each associated MeshData<> to do the same. DynamicHalfedge and friends also register themselves with the callback system, to stay valid as the mesh resizes. However, this results in a callback per dynamic element, which is why the dynamic elements are more expensive. Fortunately, dynamic elements can be used sparingly.","title":"Resize callbacks"},{"location":"surface/surface_mesh/mutation/","text":"These routines allow modification of the mesh connectivity and insertion/deletion of elements. Geometry-central is designed from the ground up to have good support for mesh mutation. The underlying SurfaceMesh data structure is index-based, with lazy expansion and deletion, so all operations run in (amortized) constant time with respect to the number of mesh elements, and usually do not incur any memory allocations. Containers automatically update after mesh operations. As much as possible, these routines will check for validity before executing and throw an exception if something isn\u2019t right. The NGC_SAFETY_CHECKS define disables this behavior for a modest increase in performance, but checks are enabled by default even in release builds. Note that aggressive use of these routines may reduce a mesh from a simplicial complex to a \\Delta \\Delta -complex . For instance, flipping enough edges in a mesh might create self-edges, which connect a vertex to itself. See the \\Delta \\Delta -complex section for details, and an explanation of why these complexes are important. General SurfaceMesh Many of these operations could be defined for a general SurfaceMesh , but are currently only implemented on the ManifoldSurfaceMesh . Future releases of geometry-central will gradually port them over. In-place modifications These routines modify a mesh, but do not require inserting or deleting elements. bool SurfaceMesh :: flip ( Edge e , bool preventSelfEdges = true ) Flip an edge by rotating counter-clockwise. An edge cannot be combinatorially flipped if it is: a boundary edge incident on a degree-1 vertex. If true is passed as the optional argument preventSelfEdges , then the edge will also not be flipped if it would result in both endpoints of the edge becoming the same vertex. Return: true if the edge was actually flipped Insertions These routines modify a mesh by inserting new elements. Element references remain valid, and containers will automatically resize themselves to accommodate the new elements. Note that some operations my re-use existing elements to create their output. For instance, splitEdge() turns a single edge in to two; the input edge will be re-used as one of the two output edges, and data along that edge will be unchanged in any containers. Halfedge ManifoldSurfaceMesh :: insertVertexAlongEdge ( Edge e ) Adds a degree 2 vertex along an edge. Unlike splitEdge() , this does not triangulate the adjacent faces; the degree of adjacent faces will be increased by 1. Works as expected on boundary edges. Returns a halfedge he along the newly created edge, which points in the same direction as e.halfedge() , and such that he.vertex() is the newly inserted vertex. Preserves canonical direction of edge.halfedge() for both halves of new edge. The original edge is repurposed as one of the two new edges (same for original halfedges). Halfedge ManifoldSurfaceMesh :: splitEdge ( Edge e ) Inserts a vertex along an edge, and triangulates the adjacent faces. On a triangle mesh, the newly inserted vertex will be a degree 4 vertex. Works as expected on boundary edges. Returns a halfedge he along the newly created edge, which points in the same direction as e.halfedge() , and such that he.vertex() is the newly inserted vertex. Preserves canonical direction of edge.halfedge() for both halves of new edge. The original edge is repurposed as one of the new edges (same for original halfedges). Vertex ManifoldSurfaceMesh :: insertVertex ( Face f ) TODO // Add vertex inside face and triangulate. Returns new vertex. Vertex insertVertex(Face f); Halfedge connectVertices ( Halfedge heA , Halfedge heB ) Call to add an edge to a face, splitting it to two faces. Creates a new edge connecting heA.vertex() to heB.vertex() . The initial shared face will be repurposed as one of the two resulting faces. heA and heB must be distinct halfedges in the same face, and their vertices must not already be adjacent in that face. Returns new halfedge with heA.vertex() at tail, and he.twin().face() is the new face. std :: vector < Face > ManifoldSurfaceMesh :: triangulate ( Face face ) Triangulate a face in the mesh, returning all of the resulting faces. One of the returned faces will be the input face, repurposed as a face in the triangulation. Trimming storage To amortize the cost of allocation, mesh buffers are resized sporadically in large increments; these resized buffers might significantly increase (e.g., double) the storage size of a mesh and the associated containers. Calling trimStorage() frees up any unused storage space to reduce memory usage. void ManifoldSurfaceMesh :: trimStorage () Free any additional storage associated with the mesh. Does not invalidate elements. Trimming storage does not put the mesh in compressed mode , though compressing the mesh does trim storage. This function costs O(n) O(n) and should not be called in a tight loop. Deletions These routines delete mesh elements. Elements (like Vertex ) and containers (like VertexData<> ) will remain valid through deletions. However, performing any deletion will cause the mesh to no longer be compressed . Vertex ManifoldSurfaceMesh :: collapseEdgeTriangular ( Edge e ) // Collapse an edge. Returns the vertex adjacent to that edge which still exists. Returns Vertex() if not // collapsible. Vertex collapseEdgeTriangular(Edge e); bool ManifoldSurfaceMesh :: removeFaceAlongBoundary ( Face f ) // Remove a face which is adjacent to the boundary of the mesh (along with its edge on the boundary). // Face must have exactly one boundary edge. // Returns true if could remove bool removeFaceAlongBoundary(Face f); Compressed mode Internally, the halfedge mesh is represented by dense arrays of indices which are lazily expanded (see interals for details). To support fast deletion operations, we simply mark elements as deleted, without re-packing the index space. We say that the mesh is compressed if the index space is dense and there are no such marked elements. When a mesh is not compressed, the index of a mesh element no longer serves as a proper enumeration from [0,N) , but merely as a unique ID. There are two consequences to being non-compressed: Some operations cannot be implemented efficiently/correctly (e.g., random access of the i\u2019th vertex), as noted in the documentation. Calling such function will generally throw an error in Debug mode, but may fail silently in Release. Storage space is wasted by deleted elements. All meshes are compressed after construction, and only become non-compressed if the user performs a deletion operation. The compress() function can be called to re-index the elements of the mesh as a proper enumeration from [0,N) . The compress() function invalidates pointers, and incurs an update of existing containers. As such, it is recommended to be called sporadically, after a sequence of operations is completed. bool SurfaceMesh :: isCompressed () Returns true if the mesh is compressed. void SurfaceMesh :: compress () Re-index the elements of the mesh to yield a dense enumeration. Invalidates all Vertex , Edge (etc) objects. All VertexData<> , FaceData<> , etc containers are automatically resized and re-indexed. Does nothing if the mesh is already compressed. Preserving notable elements In some rare situations, you might want to manually keep track of a significant mesh elements (vertices, faces, etc) through a call to compress() (which invalidates all element references). One way to do this is to leverage the MeshData<> containers, which automatically stay valid through updates: SurfaceMesh & mesh ; // our mesh Vertex vA , vB ; // two special vertices we want to keep track of // Label the special vertices VertexData < int > specialVerts ( mesh , 0 ); specialVerts [ vA ] = 1 ; specialVerts [ vB ] = 2 ; // Compress the mesh // (invalidating the Vertex objects) mesh . compress (); // specialVerts is automatically maintained through the compression // Find the interesting vertices by label for ( Vertex v : mesh . vertices ()) { if ( specialVerts [ v ] == 1 ) vA = v ; if ( specialVerts [ v ] == 2 ) vB = v ; } This is an intentionally simplistic example, but generally speaking the MeshData<> arrays can be used to track mesh elements and other data through a compress() .","title":"Mutation"},{"location":"surface/surface_mesh/mutation/#in-place-modifications","text":"These routines modify a mesh, but do not require inserting or deleting elements. bool SurfaceMesh :: flip ( Edge e , bool preventSelfEdges = true ) Flip an edge by rotating counter-clockwise. An edge cannot be combinatorially flipped if it is: a boundary edge incident on a degree-1 vertex. If true is passed as the optional argument preventSelfEdges , then the edge will also not be flipped if it would result in both endpoints of the edge becoming the same vertex. Return: true if the edge was actually flipped","title":"In-place modifications"},{"location":"surface/surface_mesh/mutation/#insertions","text":"These routines modify a mesh by inserting new elements. Element references remain valid, and containers will automatically resize themselves to accommodate the new elements. Note that some operations my re-use existing elements to create their output. For instance, splitEdge() turns a single edge in to two; the input edge will be re-used as one of the two output edges, and data along that edge will be unchanged in any containers. Halfedge ManifoldSurfaceMesh :: insertVertexAlongEdge ( Edge e ) Adds a degree 2 vertex along an edge. Unlike splitEdge() , this does not triangulate the adjacent faces; the degree of adjacent faces will be increased by 1. Works as expected on boundary edges. Returns a halfedge he along the newly created edge, which points in the same direction as e.halfedge() , and such that he.vertex() is the newly inserted vertex. Preserves canonical direction of edge.halfedge() for both halves of new edge. The original edge is repurposed as one of the two new edges (same for original halfedges). Halfedge ManifoldSurfaceMesh :: splitEdge ( Edge e ) Inserts a vertex along an edge, and triangulates the adjacent faces. On a triangle mesh, the newly inserted vertex will be a degree 4 vertex. Works as expected on boundary edges. Returns a halfedge he along the newly created edge, which points in the same direction as e.halfedge() , and such that he.vertex() is the newly inserted vertex. Preserves canonical direction of edge.halfedge() for both halves of new edge. The original edge is repurposed as one of the new edges (same for original halfedges). Vertex ManifoldSurfaceMesh :: insertVertex ( Face f ) TODO // Add vertex inside face and triangulate. Returns new vertex. Vertex insertVertex(Face f); Halfedge connectVertices ( Halfedge heA , Halfedge heB ) Call to add an edge to a face, splitting it to two faces. Creates a new edge connecting heA.vertex() to heB.vertex() . The initial shared face will be repurposed as one of the two resulting faces. heA and heB must be distinct halfedges in the same face, and their vertices must not already be adjacent in that face. Returns new halfedge with heA.vertex() at tail, and he.twin().face() is the new face. std :: vector < Face > ManifoldSurfaceMesh :: triangulate ( Face face ) Triangulate a face in the mesh, returning all of the resulting faces. One of the returned faces will be the input face, repurposed as a face in the triangulation.","title":"Insertions"},{"location":"surface/surface_mesh/mutation/#trimming-storage","text":"To amortize the cost of allocation, mesh buffers are resized sporadically in large increments; these resized buffers might significantly increase (e.g., double) the storage size of a mesh and the associated containers. Calling trimStorage() frees up any unused storage space to reduce memory usage. void ManifoldSurfaceMesh :: trimStorage () Free any additional storage associated with the mesh. Does not invalidate elements. Trimming storage does not put the mesh in compressed mode , though compressing the mesh does trim storage. This function costs O(n) O(n) and should not be called in a tight loop.","title":"Trimming storage"},{"location":"surface/surface_mesh/mutation/#deletions","text":"These routines delete mesh elements. Elements (like Vertex ) and containers (like VertexData<> ) will remain valid through deletions. However, performing any deletion will cause the mesh to no longer be compressed . Vertex ManifoldSurfaceMesh :: collapseEdgeTriangular ( Edge e ) // Collapse an edge. Returns the vertex adjacent to that edge which still exists. Returns Vertex() if not // collapsible. Vertex collapseEdgeTriangular(Edge e); bool ManifoldSurfaceMesh :: removeFaceAlongBoundary ( Face f ) // Remove a face which is adjacent to the boundary of the mesh (along with its edge on the boundary). // Face must have exactly one boundary edge. // Returns true if could remove bool removeFaceAlongBoundary(Face f);","title":"Deletions"},{"location":"surface/surface_mesh/mutation/#compressed-mode","text":"Internally, the halfedge mesh is represented by dense arrays of indices which are lazily expanded (see interals for details). To support fast deletion operations, we simply mark elements as deleted, without re-packing the index space. We say that the mesh is compressed if the index space is dense and there are no such marked elements. When a mesh is not compressed, the index of a mesh element no longer serves as a proper enumeration from [0,N) , but merely as a unique ID. There are two consequences to being non-compressed: Some operations cannot be implemented efficiently/correctly (e.g., random access of the i\u2019th vertex), as noted in the documentation. Calling such function will generally throw an error in Debug mode, but may fail silently in Release. Storage space is wasted by deleted elements. All meshes are compressed after construction, and only become non-compressed if the user performs a deletion operation. The compress() function can be called to re-index the elements of the mesh as a proper enumeration from [0,N) . The compress() function invalidates pointers, and incurs an update of existing containers. As such, it is recommended to be called sporadically, after a sequence of operations is completed. bool SurfaceMesh :: isCompressed () Returns true if the mesh is compressed. void SurfaceMesh :: compress () Re-index the elements of the mesh to yield a dense enumeration. Invalidates all Vertex , Edge (etc) objects. All VertexData<> , FaceData<> , etc containers are automatically resized and re-indexed. Does nothing if the mesh is already compressed. Preserving notable elements In some rare situations, you might want to manually keep track of a significant mesh elements (vertices, faces, etc) through a call to compress() (which invalidates all element references). One way to do this is to leverage the MeshData<> containers, which automatically stay valid through updates: SurfaceMesh & mesh ; // our mesh Vertex vA , vB ; // two special vertices we want to keep track of // Label the special vertices VertexData < int > specialVerts ( mesh , 0 ); specialVerts [ vA ] = 1 ; specialVerts [ vB ] = 2 ; // Compress the mesh // (invalidating the Vertex objects) mesh . compress (); // specialVerts is automatically maintained through the compression // Find the interesting vertices by label for ( Vertex v : mesh . vertices ()) { if ( specialVerts [ v ] == 1 ) vA = v ; if ( specialVerts [ v ] == 2 ) vB = v ; } This is an intentionally simplistic example, but generally speaking the MeshData<> arrays can be used to track mesh elements and other data through a compress() .","title":"Compressed mode"},{"location":"surface/surface_mesh/navigation/","text":"Collection Iterators Use these routines to iterate over all of the elements in the mesh. Note: Generally, modifying the mesh while iterating is allowed, but the new elements may or may not be iterated over, and previous elements might even appear again later later in the iteration after modifying. SurfaceMesh :: vertices () Iterate over the vertices in a mesh. for ( Vertex v : mesh . vertices ()) { // do science here } SurfaceMesh :: halfedges () Iterate over all of the halfedges in a mesh (both real and imaginary, if the mesh has boundary). for ( Halfedge he : mesh . halfedges ()) { // do science here } SurfaceMesh :: realHalfedges () Iterate over the real halfedges in a mesh. for ( Halfedge he : mesh . realHalfedges ()) { // do science here } Note that on a boundary edge between vertices i <--> j , this set will only include a halfedge from i --> j , but not from j --> i (or vice versa). SurfaceMesh :: exteriorHalfedges () Iterate over the exterior halfedges in a mesh. (only useful on ManifoldSurfaceMesh ) for ( Halfedge he : mesh . exteriorHalfedges ()) { // do science here } Note that on a boundary edge between vertices i <--> j , this set will only include a halfedge from i --> j , but not from j --> i (or vice versa). SurfaceMesh :: edges () Iterate over the edges in a mesh. for ( Edge e : mesh . edges ()) { // do science here } SurfaceMesh :: faces () Iterate over the faces in a mesh. for ( Face f : mesh . faces ()) { // do science here } SurfaceMesh :: boundaryLoops () Iterate over the boundary loops for a mesh. Remember that only ManifoldSurfaceMesh s have well-defined boundary loops. for ( BoundaryLoop bl : mesh . boundaryLoops ()) { // do science here } Neighborhood Iterators Use these routines to iterate over the neighbors of a mesh element. Note: neighborhoods on \\Delta \\Delta -complexes The iterators in this section may have unexpected behavior in the advanced case of a \\Delta \\Delta -complex, when there are (e.g.) self-edges, or multiple edges between a pair of vertices. Essentially, these iterators always naively traverse the local neighborhood, even if that neighborhood might include duplicate elements. For instance, if a \\Delta \\Delta -complex has multiple edges connecting vertex va to vertex vb , then iterating va.adjacentVertices() will return vb multiple times. Of course, for ordinary triangle mesh they will behave as expected. See the Delta complex section for more information. Around a vertex Vertex :: outgoingHalfedges () Iterate over the halfedges which point outward from a vertex. for ( Halfedge he : vert . outgoingHalfedges ()) { assert ( he . vertex () == vert ); // true // do science here } Vertex :: incomingHalfedges () Iterate over the halfedges which point inward at a vertex. for ( Halfedge he : vert . incomingHalfedges ()) { assert ( he . twin (). vertex () == vert ); // true // do science here } Vertex :: adjacentVertices () Iterate over the vertices edge-connected to this vertex. for ( Vertex v : vert . adjacentVertices ()) { // do science here } Vertex :: adjacentEdges () Iterate over the edges incident on this vertex. for ( Edge e : vert . adjacentEdges ()) { // do science here } Vertex :: adjacentFaces () Iterate over the faces incident on this vertex. for ( Face f : vert . adjacentFaces ()) { // do science here } Around an edge Edge :: adjacentHalfedges () Iterate over the halfedges incident on this edge. for ( Halfedge he : edge . adjacentHalfedges ()) { // do science here } Edge :: adjacentFaces () Iterate over the (one or two) faces incident on this edge. for ( Face f : edge . adjacentFaces ()) { // do science here } Edge :: adjacentVertices () Iterate over the (two) vertices which are endpoints of the edge. for ( Vertex v : edge . adjacentVertices ()) { // do science here } Note: unlike most navigators, this routine actually returns a fixed-size array, so you can alternately write things like: std :: array < Vertex , 2 > verts = edge . adjacentVertices (); Edge :: diamondBoundary () Iterate over the four halfedges bounding the diamond with this edge as its center diagonal. More precisely, for an interior edge on a manifold triangle mesh, this returns Halfedge he = edge . halfedge (); return { he . next (), he . next (). next (), he . twin (). next (), he . twin (). next (). next ()} Example: for ( Halfedge he : edge . diamondBoundary ()) { // do science here } Throws an exception if there are non-triangular faces, the edge is on the boundary, or if the edge is nonmanifold. Note: unlike most navigators, this routine actually returns a fixed-size array, so you can alternately write things like: std :: array < Halfedge , 4 > halfedges = edge . diamondBoundary (); Around a face Face :: adjacentVertices () Iterate over the vertices adjacent to a face. for ( Vertex v : face . adjacentVertices ()) { // do science here } Face :: adjacentHalfedges () Iterate over the halfedges incident on a face. for ( Halfedge he : face . adjacentHalfedges ()) { // do science here } Face :: adjacentEdges () Iterate over the edges on the boundary of a face. for ( Edge e : face . adjacentEdges ()) { // do science here } Face :: adjacentFaces () Iterate over the faces adjacent to a face, across each edge. for ( Face f : face . adjacentFaces ()) { // do science here } Around a boundary loop BoundaryLoop :: adjacentVertices () Iterate over the vertices adjacent to a boundary loop. for ( Vertex v : boundaryLoop . adjacentVertices ()) { // do science here } BoundaryLoop :: adjacentHalfedges () Iterate over the (exterior) halfedges incident on a boundary loop. for ( Halfedge he : boundaryLoop . adjacentHalfedges ()) { // do science here } BoundaryLoop :: adjacentEdges () Iterate over the edges on the boundary of a boundary loop. for ( Edge e : boundaryLoop . adjacentEdges ()) { // do science here } Accessors Use these routines to access elements of the mesh by their index. Warning The indexing routines in the section are only valid when the mesh is compressed . Halfedge SurfaceMesh :: halfedge ( size_t index ) Constructs a reference to the i\u2019th halfedge in the mesh. 0 <= index < nHalfedges() . Vertex SurfaceMesh :: vertex ( size_t index ) Constructs a reference to the i\u2019th vertex in the mesh. 0 <= index < nVertices() . Face SurfaceMesh :: face ( size_t index ) Constructs a reference to the i\u2019th face in the mesh. 0 <= index < nFaces() . Edge SurfaceMesh :: edge ( size_t index ) Constructs a reference to the i\u2019th edge in the mesh. 0 <= index < nEdges() . Face SurfaceMesh :: face ( size_t index ) Constructs a reference to the i\u2019th face in the mesh. 0 <= index < nFaces() . Face SurfaceMesh :: boundaryLoop ( size_t index ) Constructs a reference to the i\u2019th boundary loop in the mesh. 0 <= index < nBoundaryLoops() .","title":"Navigation and Iteration"},{"location":"surface/surface_mesh/navigation/#collection-iterators","text":"Use these routines to iterate over all of the elements in the mesh. Note: Generally, modifying the mesh while iterating is allowed, but the new elements may or may not be iterated over, and previous elements might even appear again later later in the iteration after modifying. SurfaceMesh :: vertices () Iterate over the vertices in a mesh. for ( Vertex v : mesh . vertices ()) { // do science here } SurfaceMesh :: halfedges () Iterate over all of the halfedges in a mesh (both real and imaginary, if the mesh has boundary). for ( Halfedge he : mesh . halfedges ()) { // do science here } SurfaceMesh :: realHalfedges () Iterate over the real halfedges in a mesh. for ( Halfedge he : mesh . realHalfedges ()) { // do science here } Note that on a boundary edge between vertices i <--> j , this set will only include a halfedge from i --> j , but not from j --> i (or vice versa). SurfaceMesh :: exteriorHalfedges () Iterate over the exterior halfedges in a mesh. (only useful on ManifoldSurfaceMesh ) for ( Halfedge he : mesh . exteriorHalfedges ()) { // do science here } Note that on a boundary edge between vertices i <--> j , this set will only include a halfedge from i --> j , but not from j --> i (or vice versa). SurfaceMesh :: edges () Iterate over the edges in a mesh. for ( Edge e : mesh . edges ()) { // do science here } SurfaceMesh :: faces () Iterate over the faces in a mesh. for ( Face f : mesh . faces ()) { // do science here } SurfaceMesh :: boundaryLoops () Iterate over the boundary loops for a mesh. Remember that only ManifoldSurfaceMesh s have well-defined boundary loops. for ( BoundaryLoop bl : mesh . boundaryLoops ()) { // do science here }","title":"Collection Iterators"},{"location":"surface/surface_mesh/navigation/#neighborhood-iterators","text":"Use these routines to iterate over the neighbors of a mesh element. Note: neighborhoods on \\Delta \\Delta -complexes The iterators in this section may have unexpected behavior in the advanced case of a \\Delta \\Delta -complex, when there are (e.g.) self-edges, or multiple edges between a pair of vertices. Essentially, these iterators always naively traverse the local neighborhood, even if that neighborhood might include duplicate elements. For instance, if a \\Delta \\Delta -complex has multiple edges connecting vertex va to vertex vb , then iterating va.adjacentVertices() will return vb multiple times. Of course, for ordinary triangle mesh they will behave as expected. See the Delta complex section for more information.","title":"Neighborhood Iterators"},{"location":"surface/surface_mesh/navigation/#around-a-vertex","text":"Vertex :: outgoingHalfedges () Iterate over the halfedges which point outward from a vertex. for ( Halfedge he : vert . outgoingHalfedges ()) { assert ( he . vertex () == vert ); // true // do science here } Vertex :: incomingHalfedges () Iterate over the halfedges which point inward at a vertex. for ( Halfedge he : vert . incomingHalfedges ()) { assert ( he . twin (). vertex () == vert ); // true // do science here } Vertex :: adjacentVertices () Iterate over the vertices edge-connected to this vertex. for ( Vertex v : vert . adjacentVertices ()) { // do science here } Vertex :: adjacentEdges () Iterate over the edges incident on this vertex. for ( Edge e : vert . adjacentEdges ()) { // do science here } Vertex :: adjacentFaces () Iterate over the faces incident on this vertex. for ( Face f : vert . adjacentFaces ()) { // do science here }","title":"Around a vertex"},{"location":"surface/surface_mesh/navigation/#around-an-edge","text":"Edge :: adjacentHalfedges () Iterate over the halfedges incident on this edge. for ( Halfedge he : edge . adjacentHalfedges ()) { // do science here } Edge :: adjacentFaces () Iterate over the (one or two) faces incident on this edge. for ( Face f : edge . adjacentFaces ()) { // do science here } Edge :: adjacentVertices () Iterate over the (two) vertices which are endpoints of the edge. for ( Vertex v : edge . adjacentVertices ()) { // do science here } Note: unlike most navigators, this routine actually returns a fixed-size array, so you can alternately write things like: std :: array < Vertex , 2 > verts = edge . adjacentVertices (); Edge :: diamondBoundary () Iterate over the four halfedges bounding the diamond with this edge as its center diagonal. More precisely, for an interior edge on a manifold triangle mesh, this returns Halfedge he = edge . halfedge (); return { he . next (), he . next (). next (), he . twin (). next (), he . twin (). next (). next ()} Example: for ( Halfedge he : edge . diamondBoundary ()) { // do science here } Throws an exception if there are non-triangular faces, the edge is on the boundary, or if the edge is nonmanifold. Note: unlike most navigators, this routine actually returns a fixed-size array, so you can alternately write things like: std :: array < Halfedge , 4 > halfedges = edge . diamondBoundary ();","title":"Around an edge"},{"location":"surface/surface_mesh/navigation/#around-a-face","text":"Face :: adjacentVertices () Iterate over the vertices adjacent to a face. for ( Vertex v : face . adjacentVertices ()) { // do science here } Face :: adjacentHalfedges () Iterate over the halfedges incident on a face. for ( Halfedge he : face . adjacentHalfedges ()) { // do science here } Face :: adjacentEdges () Iterate over the edges on the boundary of a face. for ( Edge e : face . adjacentEdges ()) { // do science here } Face :: adjacentFaces () Iterate over the faces adjacent to a face, across each edge. for ( Face f : face . adjacentFaces ()) { // do science here }","title":"Around a face"},{"location":"surface/surface_mesh/navigation/#around-a-boundary-loop","text":"BoundaryLoop :: adjacentVertices () Iterate over the vertices adjacent to a boundary loop. for ( Vertex v : boundaryLoop . adjacentVertices ()) { // do science here } BoundaryLoop :: adjacentHalfedges () Iterate over the (exterior) halfedges incident on a boundary loop. for ( Halfedge he : boundaryLoop . adjacentHalfedges ()) { // do science here } BoundaryLoop :: adjacentEdges () Iterate over the edges on the boundary of a boundary loop. for ( Edge e : boundaryLoop . adjacentEdges ()) { // do science here }","title":"Around a boundary loop"},{"location":"surface/surface_mesh/navigation/#accessors","text":"Use these routines to access elements of the mesh by their index. Warning The indexing routines in the section are only valid when the mesh is compressed . Halfedge SurfaceMesh :: halfedge ( size_t index ) Constructs a reference to the i\u2019th halfedge in the mesh. 0 <= index < nHalfedges() . Vertex SurfaceMesh :: vertex ( size_t index ) Constructs a reference to the i\u2019th vertex in the mesh. 0 <= index < nVertices() . Face SurfaceMesh :: face ( size_t index ) Constructs a reference to the i\u2019th face in the mesh. 0 <= index < nFaces() . Edge SurfaceMesh :: edge ( size_t index ) Constructs a reference to the i\u2019th edge in the mesh. 0 <= index < nEdges() . Face SurfaceMesh :: face ( size_t index ) Constructs a reference to the i\u2019th face in the mesh. 0 <= index < nFaces() . Face SurfaceMesh :: boundaryLoop ( size_t index ) Constructs a reference to the i\u2019th boundary loop in the mesh. 0 <= index < nBoundaryLoops() .","title":"Accessors"},{"location":"surface/utilities/io/","text":"#include \"geometrycentral/surface/meshio.h\" Reading meshes Construct a surface mesh from a file on disk, or more generally any std::istream . #include \"geometrycentral/surface/meshio.h\" using namespace geometrycentral :: surface ; // Load a surface mesh which is required to be manifold std :: unique_ptr < ManifoldSurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readManifoldSurfaceMesh ( \"spot.obj\" ); // Load a more general surface mesh, which might be nonmanifold std :: unique_ptr < SurfaceMesh > mesh2 ; std :: unique_ptr < VertexPositionGeometry > geometry2 ; std :: tie ( mesh2 , geometry2 ) = readSurfaceMesh ( \"spot_messy.obj\" ); Why use std::unique_ptr<> ? The mesh loader, like many functions in geometry-central, returns constructed objects via a unique_ptr . Unique pointers are an important tool for memory management in modern C++; if you haven\u2019t used them before, we suggest you give them a try! In most ways, a unique_ptr acts just like a normal C++ pointer. You can dereference it with *uPtr , and access its members and function like uPtr->function() . However, the unique_ptr helps prevent common memory-management mistakes, and communicates the programmer\u2019s intent about object lifetime. This is accomplished with two properties: You don\u2019t need to call delete on a unique_ptr , it happens automatically when the pointer is destructed, e.g. when it goes out of scope at the end of a function, or when the object it is a member of gets deleted. This helps prevent memory leaks where you forget to deallocate the object. You cannot copy the unique_ptr ; hence it is \u201cunique\u201d! You can still pass around references, or std::move() the pointer, which are sufficient for most reasonable uses. This helps prevent you from creating a copy, and then accidentally deleting the pointer twice. The general paradigm in geometry-central (and a recommended style in modern C++) is to return long-lived, allocated objects with a unique_ptr , and pass these objects in to functions and dependent classes by reference. For instance, we might write a function which takes a mesh as an argument like void processMesh ( SurfaceMesh & inputMesh ) { /* do stuff */ } and call it by dereferencing the unique pointer to pass a reference std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readSurfaceMesh ( \"spot.obj\" ); processMesh ( * mesh ); For more details about unique pointers, see the language documentation , or many tutorials around the web. If you really don\u2019t want to use unique pointers, you can simply release the unique pointer to an ordinary pointer: std :: unique_ptr < SurfaceMesh > mesh /* populated as above */ ; SurfaceMesh * meshPtr = mesh . release (); The meshPtr now points the mesh object, and you are responsible for eventually deleting this pointer. After calling release() , the unique pointer points to nothing and will no longer deallocate the object. std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> readSurfaceMesh ( std :: string filename , std :: string type = \"\" ) Load a general, not-necessarily-manifold mesh from file. Returns both a SurfaceMesh representing the connectivity, and a Geometry representing the geometry. See the example above to concisely unpack. If the file includes vertices which do not appear in any face, they will be stripped from the vertex listing and ignored. The type parameter determines the type of file to load. For example, type=\"ply\" will attempt to read the target file as a .ply file. If no type is given, the type will be inferred from the file extension. See the matrix below for all supported file types. std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> readSurfaceMesh ( std :: istream & in , std :: string type ) Same as above, but reads from a general istream object rather than a filename. When reading from a stream, the type must be specified and cannot be automatically inferred. std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> readManifoldSurfaceMesh ( std :: string filename , std :: string type = \"\" ) Load a manifold mesh from file. Returns both a ManifoldSurfaceMesh representing the connectivity, and a Geometry representing the geometry. See the example above to concisely unpack. If the mesh to be loaded is not manifold, an exception will be thrown. If the file includes vertices which do not appear in any face, they will be stripped from the vertex listing and ignored. The type parameter determines the type of file to load. For example, type=\"ply\" will attempt to read the target file as a .ply file. If no type is given, the type will be inferred from the file extension. See the matrix below for all supported file types. std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> readManifoldSurfaceMesh ( std :: istream & in , std :: string type ) Same as above, but reads from a general istream object rather than a filename. When reading from a stream, the type must be specified and cannot be automatically inferred. std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < VertexPositionGeometry > , std :: unique_ptr < CornerData < Vector2 >>> readParameterizedManifoldSurfaceMesh ( std :: string filename , std :: string type = \"\" ) Loads a manifold surface mesh plus UV (texture) coordinates from a file. See other variants for details. Currently only OBJ files are supported. std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < VertexPositionGeometry > , std :: unique_ptr < CornerData < Vector2 >>> readParameterizedSurfaceMesh ( std :: string filename , std :: string type = \"\" ) Loads a general surface mesh plus UV (texture) coordinates from a file. See other variants for details. Currently only OBJ files are supported. Writing meshes Write a mesh to file, or more generally any std::ostream . #include \"geometrycentral/surface/meshio.h\" using namespace geometrycentral :: surface ; // Write a surface mesh // Recall that ManifoldSurfaceMesh is a subclass of SurfaceMesh, so // it can be used just the same std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; writeSurfaceMesh ( * mesh , * geometry , \"my_mesh.obj\" ); void writeSurfaceMesh ( SurfaceMesh & mesh , EmbeddedGeometryInterface & geometry , std :: string filename , std :: string type = \"\" ) Write a mesh to file. The type parameter determines the type of file to write. For example, type=\"obj\" will write the target file as a .obj file. If no type is given, the type will be inferred from the file extension. See the matrix below for all supported file types. void writeSurfaceMesh ( SurfaceMesh & mesh , EmbeddedGeometryInterface & geometry , CornerData < Vector2 >& texCoords , std :: string filename , std :: string type = \"\" ) Write a mesh to file as above, except corner per-corner coordinates are also written, if supported by the file format. void writeSurfaceMesh ( SurfaceMesh & mesh , EmbeddedGeometryInterface & geometry , std :: ostream & out , std :: string type ) Write a mesh to file as above, to a general std::ostream rather than directly to a named file. When writing to a stream, the type must be specified and cannot be automatically inferred. void writeSurfaceMesh ( SurfaceMesh & mesh , EmbeddedGeometryInterface & geometry , CornerData < Vector2 >& texCoords , std :: ostream & out , std :: string type ) Write a mesh to file as above, to a general std::ostream and with the specified texture coordinates, if the file format supports it. When writing to a stream, the type must be specified and cannot be automatically inferred. Packing scalar data A handy trick for transferring data between programs (e.g., to create visualizations) is to pack scalar data in to texture coordinates when writing a mesh to file. To make this easier, the helper packToParam() stores data as corner coordinates which can be passed to the writers. #include \"geometrycentral/surface/meshio.h\" using namespace geometrycentral :: surface ; std :: unique_ptr < SurfaceMesh > mesh ; // some mesh std :: unique_ptr < VertexPositionGeometry > geometry ; // some geometry VertexData < double > vals ; // some values at vertices writeSurfaceMesh ( * mesh , * geometry , packToParam ( * mesh , vals ), \"my_mesh.obj\" ); CornerData < Vector2 > packToParam ( SurfaceMesh & mesh , VertexData < double >& vals ) Create a CornerData with the value from vals stored in the first coordinate at each corner. The second coordinate will hold 0 s. CornerData < Vector2 > packToParam ( SurfaceMesh & mesh , VertexData < double >& valsX , VertexData < double >& valsY ) Create a CornerData with the value from valsX stored in the first coordinate at each corner, and valsY stored in the second coordinate. Supported file types key reading writing tex coords notes obj \u2705 \u2705 \u2705 ply \u2705 off \u2705 stl \u2705 Exactly colocated vertices are automatically merged Rich Surface Mesh Data The RichSurfaceMeshData offers advanced IO which interoperates directly with the geometry-central mesh data structures. In particular, it has two useful features: Data stored in MeshData<> containers ( VertexData<> , EdgeData<> , etc.) can be automatically written to and read from file The internal representation used by SurfaceMesh is directly written to file, improving performance and supporting meshes which cannot be represented as face index lists. The written files can hold mesh\u2019s connectivity, associated geometry and/or any number of properties. These files can be used to load/save a whole mesh from file, or to load/save individual properties associated with some existing mesh. Internally, data is stored as additional custom fields of a .ply file. Here, we\u2019re using the .ply format as a general container for structured data\u2014other software will not automatically understand the additional fields in these files. A benefit of the ply format is that data can be written in both efficient binary or plaintext ascii formats\u2014the default is binary. The RichSurfaceMeshData class is used to read and write these souped-up .ply files, and is distinct from the simple mesh-loading .ply interface above. #include \"geometrycentral/surface/rich_surface_mesh_data.h\" Example: loading and saving data on a surface #include \"geometrycentral/surface/rich_surface_mesh_data.h\" using namespace geometrycentral :: surface ; // Open a file and load the mesh therein std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: unique_ptr < RichSurfaceMeshData > richData ; std :: tie ( mesh , richData ) = RichSurfaceMeshData :: readMeshAndData ( \"archive.ply\" ); geometry = richData -> getGeometry (); // Read a stored value FaceData < double > faceValues = richData -> getFaceProperty < double > ( \"name_a\" ); // Do some science CornerData < double > cornerValues = /* something important */ EdgeData < int > edgeValues = /* something else important */ // Add these values to the reader/writer // Note: alternately you could create a new record like // RichSurfaceMeshData newData(*mesh); richData -> addCornerProperty ( \"name_b\" , cornerValues ); richData -> addEdgeProperty ( \"name_c\" , edgeValues ); // Write the data to file richData -> write ( \"new_archive.ply\" ) Example: saving and loading a surface along with some properties #include \"geometrycentral/surface/rich_surface_mesh_data.h\" using namespace geometrycentral :: surface ; // Your existing mesh and data std :: unique_ptr < SurfaceMesh > mesh ; // your mesh std :: unique_ptr < VertexPositionGeometry > geometry ; // your geometry EdgeData < double > data ; // your data // Store data RichSurfaceMeshData richData ( * mesh ); richData . addMeshConnectivity (); richData . addGeometry ( * geometry ); richData . addEdgeProperty ( \"my prop\" , data ); // Write to file richData . write ( \"file.ply\" ); later, when loading\u2026 // Load the mesh and the data from file std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < RichSurfaceMeshData > richData ; std :: tie ( mesh , richData ) = RichSurfaceMeshData :: readMeshAndData ( \"file.ply\" ); std :: unique_ptr < VertexPositionGeometry > geometry = richData -> getGeometry (); EdgeData < double > data = richData -> getEdgeProperty < double > ( \"my prop\" ); Writing rich data These methods add properties to the RichSurfaceMeshData object, which will be written when write() is called. The set of scalar types supported is the same as the .ply format, including list types. For instance, a property of type double on vertices could written to a new ply file with. RichSurfaceMeshData richData ( * mesh ); VertexData < double > values = /* incredibly important data */ richData . addVertexProperty ( \"important_values\" , values ); richData . write ( \"my_file.ply\" ); The following routines can create the data object and write it to file: RichSurfaceMeshData :: RichSurfaceMeshData ( SurfaceMesh & mesh ) Construct a data object from an existing mesh. void RichSurfaceMeshData :: write ( std :: string filename ) Write the object to file. The binary/ascii writing mode is determined by the RichSurfaceMeshData::outputFormat option. Note that if this reader/writer was created by loading a file, and is later written using write() all fields from the initial file will be automatically written out. void RichSurfaceMeshData :: write ( std :: ostream & out ) Write the object to stream. The binary/ascii writing mode is determined by the RichSurfaceMeshData::outputFormat option. Note that if this reader/writer was created by loading a file, and is later written using write() all fields from the initial file will be automatically written out. To store the mesh connectivity itself in the file, call addMeshConnectivity() \u2014this is required if you want to load the mesh from the file later. Similarly, the addGeometry() helpers will store geometry as vertex positions or edge lengths. void RichSurfaceMeshData :: addMeshConnectivity () Store the meshes connectivity in the file. This routine always stores both the internal SurfaceMesh representation (for use with geometry-central), and a traditional face-index list representation (for use with other software). void RichSurfaceMeshData :: addGeometry ( const EmbeddedGeometryInterface & geometry ) Add geometry to the record, which will written as double vertex coordinates properties named \u201cx\u201d, \u201cy\u201d, and \u201cz\u201d. void RichSurfaceMeshData :: addIntrinsicGeometry ( const IntrinsicGeometryInterface & geometry ) Add geometry to the record, which will written as a double edge propery called intrinsic_edge_lengths . General properties can then be written as: void RichSurfaceMeshData :: addVertexProperty <> ( std :: string name , const VertexData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a VertexData<double> . void RichSurfaceMeshData :: addHalfedgeProperty <> ( std :: string name , const HalfedgeData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a HalfedgeData<double> . void PlyCornerMeshData :: addCornerProperty <> ( std :: string name , const CornerData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a CornerData<double> . void RichSurfaceMeshData :: addEdgeProperty <> ( std :: string name , const EdgeData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a EdgeData<double> . void RichSurfaceMeshData :: addFaceProperty <> ( std :: string name , const FaceData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a FaceData<double> . void RichSurfaceMeshData :: addBoundaryLoopProperty <> ( std :: string name , const BoundaryLoopData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a BoundaryLoopData<double> . Reading rich data When reading a RichSurfaceMeshData object, you have two options: Option A Open the object on an existing mesh, like RichSurfaceMeshData(*mesh, \"file.ply\") . All resulting properties will be defined on this mesh. The existing mesh must be the \u201csame\u201d as the one the file was saved from, with the same number of elements in the same semantic ordering. RichSurfaceMeshData :: RichSurfaceMeshData ( SurfaceMesh & mesh , std :: string filename ) Open a ply file, and interpret its fields as living on the existing halfedge mesh mesh . Any read properties will be returned in containers defined on mesh . RichSurfaceMeshData :: RichSurfaceMeshData ( SurfaceMesh & mesh , std :: istream & in ) Same as above, loading from a general istream . Option B Simultaneously construct a new mesh from the file, and open the file on that mesh, via readMeshAndData(...) . The file must have been saved with mesh connectivity included by calling addMeshConnectivity() . static std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < RichSurfaceMeshData >> RichSurfaceMeshData :: readMeshAndData ( std :: string filename ) Convenience factory function to open a rich .ply file and load the mesh contained within, as well as creating a RichSurfaceMeshData reader/writer to access any other properties stored in the file. The base class of the created SurfaceMesh will match the mesh from which is was created. static std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < RichSurfaceMeshData >> RichSurfaceMeshData :: readMeshAndData ( std :: istream & in ) Same as above, loading from a stream. static std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < RichSurfaceMeshData >> RichSurfaceMeshData :: readManifoldMeshAndData ( std :: string filename ) Convenience factory function to open a rich .ply file and load the mesh contained within, as well as creating a RichSurfaceMeshData reader/writer to access any other properties stored in the file. Returns a manifold mesh, erroring out out if the file was not saved from a ManifoldSurfaceMesh . static std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < RichSurfaceMeshData >> RichSurfaceMeshData :: readManifoldMeshAndData ( std :: istream & in ) Same as above, loading from a stream. Once the RichSurfaceMeshData has been opened, properties can then be read from the file like getVertexProperty<double>(name) , etc. The template argument to this function will likely be necessary to resolve the expected type of the data. For instance, a property of type double on vertices could be accessed with. RichSurfaceMeshData data ( mesh , \"my_file.ply\" ); VertexData < double > values = data . getVertexProperty < double > ( \"important_values\" ); The automatic type promotion in hapPLY gives some flexibility in specifying the type of the read data\u2014 for instance if property \"propName\" in the example above was stored as a float , it could still be read as a double . See the documentation there for details. Properties can then be read as: VertexData < T > RichSurfaceMeshData :: getVertexProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. HalfedgeData < T > RichSurfaceMeshData :: getHalfedgeProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. CornerData < T > PlyCornerMeshData :: getCornerProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. EdgeData < T > RichSurfaceMeshData :: getEdgeProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. FaceData < T > RichSurfaceMeshData :: getFaceProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. BoundaryLoopData < T > RichSurfaceMeshData :: getBoundaryLoopProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. std :: unique_ptr < VertexPositionGeometry > RichSurfaceMeshData :: getGeometry () Build a new geometry object from vertex postions stored in a file (by addGeometry() ). std :: unique_ptr < EdgeLengthGeometry > RichSurfaceMeshData :: getIntrinsicGeometry () Build a new geometry object from edge lengths stored in a file (by addIntrinsicGeometry() ). Factory constructors These simultaneously construct the connectivity and geometry of a mesh, and are used internally in many of the subroutines above. #include \"geometrycentral/surface/surface_mesh_factories.h\" Construct a mesh and geometry from a list of polygons and vertex positions: std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> makeSurfaceMeshAndGeometry ( const std :: vector < std :: vector < size_t >>& polygons , const std :: vector < Vector3 > vertexPositions ) Construct a new surface mesh and geometry from a list of face indices and a list of vertex positions. See the constructors of SurfaceMesh and VertexPositionGeometry for more details about their semantics. polygons is a nested list of zero-indexed face indices vertexPositions is a list of 3D vertex positions std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> makeManifoldSurfaceMeshAndGeometry ( const std :: vector < std :: vector < size_t >>& polygons , const std :: vector < Vector3 > vertexPositions ) Same as above, but the result is a ManifoldSurfaceMesh (and thus the connectivity must describe a manifold mesh). Construct a mesh and geometry from face indices and vertex positions, stored in dense (Eigen) matrices: #include \"geometrycentral/surface/surface_mesh_factories.h\" // matrices describing mesh (populated somehow) Eigen :: MatrixXd vMat = /* ... */ ; // V x 3 array of vertex positions Eigen :: MatrixXi fMat = /* ... */ ; // F x 3 array of zero-indexed face indices // (or F x 4 for quads, etc) // construct geometry-central mesh types std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = makeSurfaceMeshAndGeometry ( vMat , fMat ); // OR to construct a mesh which must be manifold std :: unique_ptr < ManifoldSurfaceMesh > meshManifold ; std :: unique_ptr < VertexPositionGeometry > geometryManifold ; std :: tie ( meshManifold , geometryManifold ) = makeManifoldSurfaceMeshAndGeometry ( vMat , fMat ); std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> makeSurfaceMeshAndGeometry ( const Eigen :: MatrixBase < Scalar_V >& vMat , const Eigen :: MatrixBase < Scalar_F >& fMat ) Construct a new surface mesh and geometry from a list of face indices and a list of vertex positions. See the constructors of SurfaceMesh and VertexPositionGeometry for more details about their semantics. Note that these arguments are ordered V,F to match MATLAB & friends conventions. vMat is a Vx3 floating-point valued matrix of vertex positions. Any floating point type can be used. fMat is an FxD index valued matrix of zero-indexed face indices (e.g. an Fx3 array of triangles, of Fx4 array of quads). The index type can be any integer type (like size_t or int ). The Eigen:MatrixBase<T> type is just a general type which accepts most Eigen matrix types as input, including geometry-central\u2019s nicely-named wrapper DenseMatrix<T> . std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> makeManifoldSurfaceMeshAndGeometry ( const Eigen :: MatrixBase < Scalar_V >& vMat , const Eigen :: MatrixBase < Scalar_F >& fMat ) Same as above, but the result is a ManifoldSurfaceMesh (and thus the connectivity must describe a manifold mesh).","title":"I/O"},{"location":"surface/utilities/io/#reading-meshes","text":"Construct a surface mesh from a file on disk, or more generally any std::istream . #include \"geometrycentral/surface/meshio.h\" using namespace geometrycentral :: surface ; // Load a surface mesh which is required to be manifold std :: unique_ptr < ManifoldSurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readManifoldSurfaceMesh ( \"spot.obj\" ); // Load a more general surface mesh, which might be nonmanifold std :: unique_ptr < SurfaceMesh > mesh2 ; std :: unique_ptr < VertexPositionGeometry > geometry2 ; std :: tie ( mesh2 , geometry2 ) = readSurfaceMesh ( \"spot_messy.obj\" ); Why use std::unique_ptr<> ? The mesh loader, like many functions in geometry-central, returns constructed objects via a unique_ptr . Unique pointers are an important tool for memory management in modern C++; if you haven\u2019t used them before, we suggest you give them a try! In most ways, a unique_ptr acts just like a normal C++ pointer. You can dereference it with *uPtr , and access its members and function like uPtr->function() . However, the unique_ptr helps prevent common memory-management mistakes, and communicates the programmer\u2019s intent about object lifetime. This is accomplished with two properties: You don\u2019t need to call delete on a unique_ptr , it happens automatically when the pointer is destructed, e.g. when it goes out of scope at the end of a function, or when the object it is a member of gets deleted. This helps prevent memory leaks where you forget to deallocate the object. You cannot copy the unique_ptr ; hence it is \u201cunique\u201d! You can still pass around references, or std::move() the pointer, which are sufficient for most reasonable uses. This helps prevent you from creating a copy, and then accidentally deleting the pointer twice. The general paradigm in geometry-central (and a recommended style in modern C++) is to return long-lived, allocated objects with a unique_ptr , and pass these objects in to functions and dependent classes by reference. For instance, we might write a function which takes a mesh as an argument like void processMesh ( SurfaceMesh & inputMesh ) { /* do stuff */ } and call it by dereferencing the unique pointer to pass a reference std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readSurfaceMesh ( \"spot.obj\" ); processMesh ( * mesh ); For more details about unique pointers, see the language documentation , or many tutorials around the web. If you really don\u2019t want to use unique pointers, you can simply release the unique pointer to an ordinary pointer: std :: unique_ptr < SurfaceMesh > mesh /* populated as above */ ; SurfaceMesh * meshPtr = mesh . release (); The meshPtr now points the mesh object, and you are responsible for eventually deleting this pointer. After calling release() , the unique pointer points to nothing and will no longer deallocate the object. std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> readSurfaceMesh ( std :: string filename , std :: string type = \"\" ) Load a general, not-necessarily-manifold mesh from file. Returns both a SurfaceMesh representing the connectivity, and a Geometry representing the geometry. See the example above to concisely unpack. If the file includes vertices which do not appear in any face, they will be stripped from the vertex listing and ignored. The type parameter determines the type of file to load. For example, type=\"ply\" will attempt to read the target file as a .ply file. If no type is given, the type will be inferred from the file extension. See the matrix below for all supported file types. std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> readSurfaceMesh ( std :: istream & in , std :: string type ) Same as above, but reads from a general istream object rather than a filename. When reading from a stream, the type must be specified and cannot be automatically inferred. std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> readManifoldSurfaceMesh ( std :: string filename , std :: string type = \"\" ) Load a manifold mesh from file. Returns both a ManifoldSurfaceMesh representing the connectivity, and a Geometry representing the geometry. See the example above to concisely unpack. If the mesh to be loaded is not manifold, an exception will be thrown. If the file includes vertices which do not appear in any face, they will be stripped from the vertex listing and ignored. The type parameter determines the type of file to load. For example, type=\"ply\" will attempt to read the target file as a .ply file. If no type is given, the type will be inferred from the file extension. See the matrix below for all supported file types. std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> readManifoldSurfaceMesh ( std :: istream & in , std :: string type ) Same as above, but reads from a general istream object rather than a filename. When reading from a stream, the type must be specified and cannot be automatically inferred. std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < VertexPositionGeometry > , std :: unique_ptr < CornerData < Vector2 >>> readParameterizedManifoldSurfaceMesh ( std :: string filename , std :: string type = \"\" ) Loads a manifold surface mesh plus UV (texture) coordinates from a file. See other variants for details. Currently only OBJ files are supported. std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < VertexPositionGeometry > , std :: unique_ptr < CornerData < Vector2 >>> readParameterizedSurfaceMesh ( std :: string filename , std :: string type = \"\" ) Loads a general surface mesh plus UV (texture) coordinates from a file. See other variants for details. Currently only OBJ files are supported.","title":"Reading meshes"},{"location":"surface/utilities/io/#writing-meshes","text":"Write a mesh to file, or more generally any std::ostream . #include \"geometrycentral/surface/meshio.h\" using namespace geometrycentral :: surface ; // Write a surface mesh // Recall that ManifoldSurfaceMesh is a subclass of SurfaceMesh, so // it can be used just the same std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; writeSurfaceMesh ( * mesh , * geometry , \"my_mesh.obj\" ); void writeSurfaceMesh ( SurfaceMesh & mesh , EmbeddedGeometryInterface & geometry , std :: string filename , std :: string type = \"\" ) Write a mesh to file. The type parameter determines the type of file to write. For example, type=\"obj\" will write the target file as a .obj file. If no type is given, the type will be inferred from the file extension. See the matrix below for all supported file types. void writeSurfaceMesh ( SurfaceMesh & mesh , EmbeddedGeometryInterface & geometry , CornerData < Vector2 >& texCoords , std :: string filename , std :: string type = \"\" ) Write a mesh to file as above, except corner per-corner coordinates are also written, if supported by the file format. void writeSurfaceMesh ( SurfaceMesh & mesh , EmbeddedGeometryInterface & geometry , std :: ostream & out , std :: string type ) Write a mesh to file as above, to a general std::ostream rather than directly to a named file. When writing to a stream, the type must be specified and cannot be automatically inferred. void writeSurfaceMesh ( SurfaceMesh & mesh , EmbeddedGeometryInterface & geometry , CornerData < Vector2 >& texCoords , std :: ostream & out , std :: string type ) Write a mesh to file as above, to a general std::ostream and with the specified texture coordinates, if the file format supports it. When writing to a stream, the type must be specified and cannot be automatically inferred.","title":"Writing meshes"},{"location":"surface/utilities/io/#packing-scalar-data","text":"A handy trick for transferring data between programs (e.g., to create visualizations) is to pack scalar data in to texture coordinates when writing a mesh to file. To make this easier, the helper packToParam() stores data as corner coordinates which can be passed to the writers. #include \"geometrycentral/surface/meshio.h\" using namespace geometrycentral :: surface ; std :: unique_ptr < SurfaceMesh > mesh ; // some mesh std :: unique_ptr < VertexPositionGeometry > geometry ; // some geometry VertexData < double > vals ; // some values at vertices writeSurfaceMesh ( * mesh , * geometry , packToParam ( * mesh , vals ), \"my_mesh.obj\" ); CornerData < Vector2 > packToParam ( SurfaceMesh & mesh , VertexData < double >& vals ) Create a CornerData with the value from vals stored in the first coordinate at each corner. The second coordinate will hold 0 s. CornerData < Vector2 > packToParam ( SurfaceMesh & mesh , VertexData < double >& valsX , VertexData < double >& valsY ) Create a CornerData with the value from valsX stored in the first coordinate at each corner, and valsY stored in the second coordinate.","title":"Packing scalar data"},{"location":"surface/utilities/io/#supported-file-types","text":"key reading writing tex coords notes obj \u2705 \u2705 \u2705 ply \u2705 off \u2705 stl \u2705 Exactly colocated vertices are automatically merged","title":"Supported file types"},{"location":"surface/utilities/io/#rich-surface-mesh-data","text":"The RichSurfaceMeshData offers advanced IO which interoperates directly with the geometry-central mesh data structures. In particular, it has two useful features: Data stored in MeshData<> containers ( VertexData<> , EdgeData<> , etc.) can be automatically written to and read from file The internal representation used by SurfaceMesh is directly written to file, improving performance and supporting meshes which cannot be represented as face index lists. The written files can hold mesh\u2019s connectivity, associated geometry and/or any number of properties. These files can be used to load/save a whole mesh from file, or to load/save individual properties associated with some existing mesh. Internally, data is stored as additional custom fields of a .ply file. Here, we\u2019re using the .ply format as a general container for structured data\u2014other software will not automatically understand the additional fields in these files. A benefit of the ply format is that data can be written in both efficient binary or plaintext ascii formats\u2014the default is binary. The RichSurfaceMeshData class is used to read and write these souped-up .ply files, and is distinct from the simple mesh-loading .ply interface above. #include \"geometrycentral/surface/rich_surface_mesh_data.h\" Example: loading and saving data on a surface #include \"geometrycentral/surface/rich_surface_mesh_data.h\" using namespace geometrycentral :: surface ; // Open a file and load the mesh therein std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: unique_ptr < RichSurfaceMeshData > richData ; std :: tie ( mesh , richData ) = RichSurfaceMeshData :: readMeshAndData ( \"archive.ply\" ); geometry = richData -> getGeometry (); // Read a stored value FaceData < double > faceValues = richData -> getFaceProperty < double > ( \"name_a\" ); // Do some science CornerData < double > cornerValues = /* something important */ EdgeData < int > edgeValues = /* something else important */ // Add these values to the reader/writer // Note: alternately you could create a new record like // RichSurfaceMeshData newData(*mesh); richData -> addCornerProperty ( \"name_b\" , cornerValues ); richData -> addEdgeProperty ( \"name_c\" , edgeValues ); // Write the data to file richData -> write ( \"new_archive.ply\" ) Example: saving and loading a surface along with some properties #include \"geometrycentral/surface/rich_surface_mesh_data.h\" using namespace geometrycentral :: surface ; // Your existing mesh and data std :: unique_ptr < SurfaceMesh > mesh ; // your mesh std :: unique_ptr < VertexPositionGeometry > geometry ; // your geometry EdgeData < double > data ; // your data // Store data RichSurfaceMeshData richData ( * mesh ); richData . addMeshConnectivity (); richData . addGeometry ( * geometry ); richData . addEdgeProperty ( \"my prop\" , data ); // Write to file richData . write ( \"file.ply\" ); later, when loading\u2026 // Load the mesh and the data from file std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < RichSurfaceMeshData > richData ; std :: tie ( mesh , richData ) = RichSurfaceMeshData :: readMeshAndData ( \"file.ply\" ); std :: unique_ptr < VertexPositionGeometry > geometry = richData -> getGeometry (); EdgeData < double > data = richData -> getEdgeProperty < double > ( \"my prop\" );","title":"Rich Surface Mesh Data"},{"location":"surface/utilities/io/#writing-rich-data","text":"These methods add properties to the RichSurfaceMeshData object, which will be written when write() is called. The set of scalar types supported is the same as the .ply format, including list types. For instance, a property of type double on vertices could written to a new ply file with. RichSurfaceMeshData richData ( * mesh ); VertexData < double > values = /* incredibly important data */ richData . addVertexProperty ( \"important_values\" , values ); richData . write ( \"my_file.ply\" ); The following routines can create the data object and write it to file: RichSurfaceMeshData :: RichSurfaceMeshData ( SurfaceMesh & mesh ) Construct a data object from an existing mesh. void RichSurfaceMeshData :: write ( std :: string filename ) Write the object to file. The binary/ascii writing mode is determined by the RichSurfaceMeshData::outputFormat option. Note that if this reader/writer was created by loading a file, and is later written using write() all fields from the initial file will be automatically written out. void RichSurfaceMeshData :: write ( std :: ostream & out ) Write the object to stream. The binary/ascii writing mode is determined by the RichSurfaceMeshData::outputFormat option. Note that if this reader/writer was created by loading a file, and is later written using write() all fields from the initial file will be automatically written out. To store the mesh connectivity itself in the file, call addMeshConnectivity() \u2014this is required if you want to load the mesh from the file later. Similarly, the addGeometry() helpers will store geometry as vertex positions or edge lengths. void RichSurfaceMeshData :: addMeshConnectivity () Store the meshes connectivity in the file. This routine always stores both the internal SurfaceMesh representation (for use with geometry-central), and a traditional face-index list representation (for use with other software). void RichSurfaceMeshData :: addGeometry ( const EmbeddedGeometryInterface & geometry ) Add geometry to the record, which will written as double vertex coordinates properties named \u201cx\u201d, \u201cy\u201d, and \u201cz\u201d. void RichSurfaceMeshData :: addIntrinsicGeometry ( const IntrinsicGeometryInterface & geometry ) Add geometry to the record, which will written as a double edge propery called intrinsic_edge_lengths . General properties can then be written as: void RichSurfaceMeshData :: addVertexProperty <> ( std :: string name , const VertexData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a VertexData<double> . void RichSurfaceMeshData :: addHalfedgeProperty <> ( std :: string name , const HalfedgeData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a HalfedgeData<double> . void PlyCornerMeshData :: addCornerProperty <> ( std :: string name , const CornerData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a CornerData<double> . void RichSurfaceMeshData :: addEdgeProperty <> ( std :: string name , const EdgeData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a EdgeData<double> . void RichSurfaceMeshData :: addFaceProperty <> ( std :: string name , const FaceData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a FaceData<double> . void RichSurfaceMeshData :: addBoundaryLoopProperty <> ( std :: string name , const BoundaryLoopData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a BoundaryLoopData<double> .","title":"Writing rich data"},{"location":"surface/utilities/io/#reading-rich-data","text":"When reading a RichSurfaceMeshData object, you have two options: Option A Open the object on an existing mesh, like RichSurfaceMeshData(*mesh, \"file.ply\") . All resulting properties will be defined on this mesh. The existing mesh must be the \u201csame\u201d as the one the file was saved from, with the same number of elements in the same semantic ordering. RichSurfaceMeshData :: RichSurfaceMeshData ( SurfaceMesh & mesh , std :: string filename ) Open a ply file, and interpret its fields as living on the existing halfedge mesh mesh . Any read properties will be returned in containers defined on mesh . RichSurfaceMeshData :: RichSurfaceMeshData ( SurfaceMesh & mesh , std :: istream & in ) Same as above, loading from a general istream . Option B Simultaneously construct a new mesh from the file, and open the file on that mesh, via readMeshAndData(...) . The file must have been saved with mesh connectivity included by calling addMeshConnectivity() . static std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < RichSurfaceMeshData >> RichSurfaceMeshData :: readMeshAndData ( std :: string filename ) Convenience factory function to open a rich .ply file and load the mesh contained within, as well as creating a RichSurfaceMeshData reader/writer to access any other properties stored in the file. The base class of the created SurfaceMesh will match the mesh from which is was created. static std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < RichSurfaceMeshData >> RichSurfaceMeshData :: readMeshAndData ( std :: istream & in ) Same as above, loading from a stream. static std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < RichSurfaceMeshData >> RichSurfaceMeshData :: readManifoldMeshAndData ( std :: string filename ) Convenience factory function to open a rich .ply file and load the mesh contained within, as well as creating a RichSurfaceMeshData reader/writer to access any other properties stored in the file. Returns a manifold mesh, erroring out out if the file was not saved from a ManifoldSurfaceMesh . static std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < RichSurfaceMeshData >> RichSurfaceMeshData :: readManifoldMeshAndData ( std :: istream & in ) Same as above, loading from a stream. Once the RichSurfaceMeshData has been opened, properties can then be read from the file like getVertexProperty<double>(name) , etc. The template argument to this function will likely be necessary to resolve the expected type of the data. For instance, a property of type double on vertices could be accessed with. RichSurfaceMeshData data ( mesh , \"my_file.ply\" ); VertexData < double > values = data . getVertexProperty < double > ( \"important_values\" ); The automatic type promotion in hapPLY gives some flexibility in specifying the type of the read data\u2014 for instance if property \"propName\" in the example above was stored as a float , it could still be read as a double . See the documentation there for details. Properties can then be read as: VertexData < T > RichSurfaceMeshData :: getVertexProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. HalfedgeData < T > RichSurfaceMeshData :: getHalfedgeProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. CornerData < T > PlyCornerMeshData :: getCornerProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. EdgeData < T > RichSurfaceMeshData :: getEdgeProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. FaceData < T > RichSurfaceMeshData :: getFaceProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. BoundaryLoopData < T > RichSurfaceMeshData :: getBoundaryLoopProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. std :: unique_ptr < VertexPositionGeometry > RichSurfaceMeshData :: getGeometry () Build a new geometry object from vertex postions stored in a file (by addGeometry() ). std :: unique_ptr < EdgeLengthGeometry > RichSurfaceMeshData :: getIntrinsicGeometry () Build a new geometry object from edge lengths stored in a file (by addIntrinsicGeometry() ).","title":"Reading rich data"},{"location":"surface/utilities/io/#factory-constructors","text":"These simultaneously construct the connectivity and geometry of a mesh, and are used internally in many of the subroutines above. #include \"geometrycentral/surface/surface_mesh_factories.h\" Construct a mesh and geometry from a list of polygons and vertex positions: std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> makeSurfaceMeshAndGeometry ( const std :: vector < std :: vector < size_t >>& polygons , const std :: vector < Vector3 > vertexPositions ) Construct a new surface mesh and geometry from a list of face indices and a list of vertex positions. See the constructors of SurfaceMesh and VertexPositionGeometry for more details about their semantics. polygons is a nested list of zero-indexed face indices vertexPositions is a list of 3D vertex positions std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> makeManifoldSurfaceMeshAndGeometry ( const std :: vector < std :: vector < size_t >>& polygons , const std :: vector < Vector3 > vertexPositions ) Same as above, but the result is a ManifoldSurfaceMesh (and thus the connectivity must describe a manifold mesh). Construct a mesh and geometry from face indices and vertex positions, stored in dense (Eigen) matrices: #include \"geometrycentral/surface/surface_mesh_factories.h\" // matrices describing mesh (populated somehow) Eigen :: MatrixXd vMat = /* ... */ ; // V x 3 array of vertex positions Eigen :: MatrixXi fMat = /* ... */ ; // F x 3 array of zero-indexed face indices // (or F x 4 for quads, etc) // construct geometry-central mesh types std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = makeSurfaceMeshAndGeometry ( vMat , fMat ); // OR to construct a mesh which must be manifold std :: unique_ptr < ManifoldSurfaceMesh > meshManifold ; std :: unique_ptr < VertexPositionGeometry > geometryManifold ; std :: tie ( meshManifold , geometryManifold ) = makeManifoldSurfaceMeshAndGeometry ( vMat , fMat ); std :: tuple < std :: unique_ptr < SurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> makeSurfaceMeshAndGeometry ( const Eigen :: MatrixBase < Scalar_V >& vMat , const Eigen :: MatrixBase < Scalar_F >& fMat ) Construct a new surface mesh and geometry from a list of face indices and a list of vertex positions. See the constructors of SurfaceMesh and VertexPositionGeometry for more details about their semantics. Note that these arguments are ordered V,F to match MATLAB & friends conventions. vMat is a Vx3 floating-point valued matrix of vertex positions. Any floating point type can be used. fMat is an FxD index valued matrix of zero-indexed face indices (e.g. an Fx3 array of triangles, of Fx4 array of quads). The index type can be any integer type (like size_t or int ). The Eigen:MatrixBase<T> type is just a general type which accepts most Eigen matrix types as input, including geometry-central\u2019s nicely-named wrapper DenseMatrix<T> . std :: tuple < std :: unique_ptr < ManifoldSurfaceMesh > , std :: unique_ptr < VertexPositionGeometry >> makeManifoldSurfaceMeshAndGeometry ( const Eigen :: MatrixBase < Scalar_V >& vMat , const Eigen :: MatrixBase < Scalar_F >& fMat ) Same as above, but the result is a ManifoldSurfaceMesh (and thus the connectivity must describe a manifold mesh).","title":"Factory constructors"},{"location":"surface/utilities/simple_polygon_mesh/","text":"SimplePolygonMesh is small mesh helper class which stores vertex positions, and indexed list of faces, and (optionally) texture coordinates. Used mainly as an intermediate representation for input and output. #include \"geometrycentral/surface/simple_polygon_mesh.h\" This is not the mesh you\u2019re looking for SurfaceMesh is the main mesh class in geometry-central . It supports a wide range of traversals, geometry, and other operations, and is used in all higher-level algorithms. This class, SimplePolygonMesh , is a small utility used mainly for input/output and occasionally as an implementation detail for other algorithms. If you are implementing any nontrivial algorithm, you should almost certainly be using SurfaceMesh instead. PolygonSoupMesh deprecation In a previous version of geometry-central, this class was called PolygonSoupMesh \u2014that name was potentially misleading. To avoid breaking existing code, polygon_soup_mesh.h now simply typedefs PolygonSoupMesh as SimplePolygonMesh . Please use SimplePolygonMesh in all new code. Members std::vector<Vector3> vertexCoordinates 3D positions for each vertex in the mesh. std::vector<std::vector<size_t>> polygons The list of polygonal faces comprising the mesh. Each inner vector is a face, given by the 0-based vertex indices in to the vertexCoordinates array. The ordering of these indices is interpreted as the orientation of the face, via a counter-clockwise ordering of the vertices. std::vector<std::vector<Vector2>> paramCoordinates (optional) 2D parameterization coordinates associated with each corner of each face. If non-empty, the dimensions of this array should be exactly the same as polygons ; each coordinate corresponds to the matching polygon corner in polygons . Constructors SimplePolygonMesh :: SimplePolygonMesh () Create an empty mesh. SimplePolygonMesh :: SimplePolygonMesh ( std :: string filename , std :: string type = \"\" ) Load a mesh from file. See documentation for readMeshFromFile() below. SimplePolygonMesh :: SimplePolygonMesh ( std :: istream & in , std :: string type ) Load a mesh from file. See documentation for readMeshFromFile() below. SimplePolygonMesh :: SimplePolygonMesh ( const std :: vector < std :: vector < size_t >>& polygons_ , const std :: vector < Vector3 >& vertexCoordinates_ ) Construct a mesh from a list of polygons and vertex coordinates. SimplePolygonMesh :: SimplePolygonMesh ( const std :: vector < std :: vector < size_t >>& polygons_ , const std :: vector < Vector3 >& vertexCoordinates_ , const std :: vector < std :: vector < Vector2 >>& paramCoordinates_ ) Construct a mesh from a list of polygons, vertex coordinates, and parameterization coordinates. std :: unique_ptr < SimplePolygonMesh > unionMeshes ( const std :: vector < SimplePolygonMesh >& meshes ) Union a collection of polygon meshes in to a single mesh. Input & Output Currently the following mesh types are supported for reading: obj ply (using hapPLY ) stl off Currently, UV coordinates are only read from file for the obj format. For writing, only obj is supported. Note that RichSurfaceMeshData provides additional ply writing routines for surface meshes, including storing buffers of data. The desired file type can be passed as the type to any of the routines below as an unpunctuated lower-case string, like readMeshFromFile ( myFilename , \"stl\" ) . void SimplePolygonMesh :: readMeshFromFile ( std :: istream & in , std :: string type ); Read a mesh from an input stream. Type must be specificed (see above). Clears any existing data from the file before loading. void SimplePolygonMesh :: readMeshFromFile ( std :: string filename , std :: string type = \"\" ); Read a mesh from a file. filename should be the full path to the file. The type can be manually specified (see above), or given as the empty string ( \"\" ) to attempt to auto-detect from the filename extension. Clears any existing data from the file before loading. void SimplePolygonMesh :: writeMesh ( std :: ostream & out , std :: string type ); Write a mesh to an input stream. Type must be specificed (see above). void SimplePolygonMesh :: writeMesh ( std :: string filename , std :: string type = \"\" ); Write a mesh to file. filename should be the full path to the file. The type can be manually specified (see above), or given as the empty string ( \"\" ) to attempt to auto-detect from the filename extension. Accessors size_t SimplePolygonMesh :: nFaces () The number of faces in the mesh. size_t SimplePolygonMesh :: nVertices () The number of vertices in the mesh. bool SimplePolygonMesh :: hasParameterization () True if the mesh has a 2D corner parameterization in the paramCoordinates member. Modification void SimplePolygonMesh :: mergeIdenticalVertices () Vertices with identical coordinates are merged to be a single vertex entry, and the face indices are updated accordingly. Identity is tested using a simple exact floating-point comparison test, no radius or threshold is supported. std :: vector < size_t > SimplePolygonMesh :: stripUnusedVertices () Remove vertices from vertexCoordinates which do not appear in any face. Face indices are updated accordingly. Returns an index translation vector mapping old indices to new, such that vec[ind_old] == ind_new . Holds INVALID_IND for any old indices which were stripped. void SimplePolygonMesh :: stripFacesWithDuplicateVertices () Remove any faces from polygons for which some vertex index appears multiple times. void SimplePolygonMesh :: triangulate () All faces with more than 3 sides are triangulated, replacing the original face with multiple triangular faces. Currently uses a naive fan triangulation strategy. An error is thrown for any faces with < 3 sides. void SimplePolygonMesh :: clear () Empty all data arrays for the mesh.","title":"Simple Polygon Mesh"},{"location":"surface/utilities/simple_polygon_mesh/#members","text":"std::vector<Vector3> vertexCoordinates 3D positions for each vertex in the mesh. std::vector<std::vector<size_t>> polygons The list of polygonal faces comprising the mesh. Each inner vector is a face, given by the 0-based vertex indices in to the vertexCoordinates array. The ordering of these indices is interpreted as the orientation of the face, via a counter-clockwise ordering of the vertices. std::vector<std::vector<Vector2>> paramCoordinates (optional) 2D parameterization coordinates associated with each corner of each face. If non-empty, the dimensions of this array should be exactly the same as polygons ; each coordinate corresponds to the matching polygon corner in polygons .","title":"Members"},{"location":"surface/utilities/simple_polygon_mesh/#constructors","text":"SimplePolygonMesh :: SimplePolygonMesh () Create an empty mesh. SimplePolygonMesh :: SimplePolygonMesh ( std :: string filename , std :: string type = \"\" ) Load a mesh from file. See documentation for readMeshFromFile() below. SimplePolygonMesh :: SimplePolygonMesh ( std :: istream & in , std :: string type ) Load a mesh from file. See documentation for readMeshFromFile() below. SimplePolygonMesh :: SimplePolygonMesh ( const std :: vector < std :: vector < size_t >>& polygons_ , const std :: vector < Vector3 >& vertexCoordinates_ ) Construct a mesh from a list of polygons and vertex coordinates. SimplePolygonMesh :: SimplePolygonMesh ( const std :: vector < std :: vector < size_t >>& polygons_ , const std :: vector < Vector3 >& vertexCoordinates_ , const std :: vector < std :: vector < Vector2 >>& paramCoordinates_ ) Construct a mesh from a list of polygons, vertex coordinates, and parameterization coordinates. std :: unique_ptr < SimplePolygonMesh > unionMeshes ( const std :: vector < SimplePolygonMesh >& meshes ) Union a collection of polygon meshes in to a single mesh.","title":"Constructors"},{"location":"surface/utilities/simple_polygon_mesh/#input-output","text":"Currently the following mesh types are supported for reading: obj ply (using hapPLY ) stl off Currently, UV coordinates are only read from file for the obj format. For writing, only obj is supported. Note that RichSurfaceMeshData provides additional ply writing routines for surface meshes, including storing buffers of data. The desired file type can be passed as the type to any of the routines below as an unpunctuated lower-case string, like readMeshFromFile ( myFilename , \"stl\" ) . void SimplePolygonMesh :: readMeshFromFile ( std :: istream & in , std :: string type ); Read a mesh from an input stream. Type must be specificed (see above). Clears any existing data from the file before loading. void SimplePolygonMesh :: readMeshFromFile ( std :: string filename , std :: string type = \"\" ); Read a mesh from a file. filename should be the full path to the file. The type can be manually specified (see above), or given as the empty string ( \"\" ) to attempt to auto-detect from the filename extension. Clears any existing data from the file before loading. void SimplePolygonMesh :: writeMesh ( std :: ostream & out , std :: string type ); Write a mesh to an input stream. Type must be specificed (see above). void SimplePolygonMesh :: writeMesh ( std :: string filename , std :: string type = \"\" ); Write a mesh to file. filename should be the full path to the file. The type can be manually specified (see above), or given as the empty string ( \"\" ) to attempt to auto-detect from the filename extension.","title":"Input &amp; Output"},{"location":"surface/utilities/simple_polygon_mesh/#accessors","text":"size_t SimplePolygonMesh :: nFaces () The number of faces in the mesh. size_t SimplePolygonMesh :: nVertices () The number of vertices in the mesh. bool SimplePolygonMesh :: hasParameterization () True if the mesh has a 2D corner parameterization in the paramCoordinates member.","title":"Accessors"},{"location":"surface/utilities/simple_polygon_mesh/#modification","text":"void SimplePolygonMesh :: mergeIdenticalVertices () Vertices with identical coordinates are merged to be a single vertex entry, and the face indices are updated accordingly. Identity is tested using a simple exact floating-point comparison test, no radius or threshold is supported. std :: vector < size_t > SimplePolygonMesh :: stripUnusedVertices () Remove vertices from vertexCoordinates which do not appear in any face. Face indices are updated accordingly. Returns an index translation vector mapping old indices to new, such that vec[ind_old] == ind_new . Holds INVALID_IND for any old indices which were stripped. void SimplePolygonMesh :: stripFacesWithDuplicateVertices () Remove any faces from polygons for which some vertex index appears multiple times. void SimplePolygonMesh :: triangulate () All faces with more than 3 sides are triangulated, replacing the original face with multiple triangular faces. Currently uses a naive fan triangulation strategy. An error is thrown for any faces with < 3 sides. void SimplePolygonMesh :: clear () Empty all data arrays for the mesh.","title":"Modification"},{"location":"surface/utilities/surface_point/","text":"A SurfacePoint is a generic location on a surface, which might be at a vertex, along an edge, or inside a face. Surface points are used throughout geometry-central for methods that input or output arbitrary locations on surfaces. #include \"geometrycentral/surface/surface_point.h\" The field SurfacePoint::type is an enum: enum class SurfacePointType { Vertex = 0 , Edge , Face }; which indicates what kind of point this is. if the surface point is a vertex , the field SurfacePoint::vertex indicates which vertex. Otherwise it is the null default vertex. if the surface point is along an edge , the field SurfacePoint::edge indicates which edge. Otherwise it is the null default edge. The field SurfacePoint::tEdge indicates the location along that edge, in the range [0,1] , with 0 at edge.halfedge().vertex() . if the surface point is inside a face , the field SurfacePoint::face indicates which face. Otherwise it is the null default face. The field SurfacePoint::faceCoords indicates the location inside that face, as barycentric coordinates (numbered according to the iteration order of vertices about the face, as usual). Surface points have a few useful utility methods: T SurfacePoint :: interpolate ( const VertexData < T >& data ) Given data of tempalte type T defined at vertices, linearly interpolates to a value at this location. SurfacePoint SurfacePoint :: inSomeFace () All surface points (vertex, edge, face) have an equivalent point in one or many adjacent faces. For instance, a vertex could be equivalently a point in any of the incident faces, with a single 1 barycentric coordinate, or a point on an edge could be a point in either of the two adjacent faces. This function returns one of the equivalent surface points in a face (chosen arbitrarily). If this point is a face point, the output is a copy of this point. Vertex SurfacePoint :: nearestVertex () Returns the nearest vertex which is adjacent to this point. For surface points which are vertices, it will return the same vertex. For surface points which are along edges, it will return one of the two incident vertices. For surface points which are inside faces, it will return one of the three incident vertices.","title":"Surface Point"},{"location":"tutorials/basic_mutation/","text":"This tutorial explores the surface mesh data structure in geometry-central, via a simple example which splits and flips edges to perform 4:1 subidivision of a triangle mesh. View full, runnable source code in the tutorial repository. Basic setup To begin we include headers, bring in namespaces, See the first tutorial for more info on these steps. #include \"geometrycentral/surface/manifold_surface_mesh.h\" #include \"geometrycentral/surface/meshio.h\" #include \"geometrycentral/surface/surface_mesh.h\" #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" using namespace geometrycentral ; using namespace geometrycentral :: surface ; Again as before, load an input mesh from file, and visualize it using Polyscope. Here, we\u2019ll require that the mesh be manifold. std :: unique_ptr < ManifoldSurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readManifoldSurfaceMesh ( args :: get ( inputFilename )); polyscope :: init (); polyscope :: registerSurfaceMesh ( \"input mesh\" , geometry -> inputVertexPositions , mesh -> getFaceVertexList ()); // call polyscope::show(); to inspect the mesh at this point Now, we\u2019ll evaluate a 4:1 sudivision via the following algorithm: split each edge and connect to opposite vertices flip any new edge connecting a new to old vertex First, we\u2019ll create two MeshData<> containers. They associate data with mesh elements. We initialize them both with true values, because initially all vertices (resp. edges) are original. We\u2019ll also track a list of edges to flip in the second phase. VertexData < bool > isOrigVert ( * mesh , true ); EdgeData < bool > isOrigEdge ( * mesh , true ); std :: vector < Edge > toFlip ; Now our main algorithm loop (commented inline). for ( Edge e : mesh -> edges ()) { // loop over all edges if ( ! isOrigEdge [ e ]) continue ; // don't keep processing new edges // gather both vertices incident on the edge, and their positions Vertex oldA = e . halfedge (). tipVertex (); Vertex oldB = e . halfedge (). tailVertex (); Vector3 oldAPos = geometry -> inputVertexPositions [ oldA ]; Vector3 oldBPos = geometry -> inputVertexPositions [ oldB ]; // split the edge Vertex newV = mesh -> splitEdgeTriangular ( e ). vertex (); isOrigVert [ newV ] = false ; // position the new vertex Vector3 newPos = 0.5 * ( oldAPos + oldBPos ); geometry -> inputVertexPositions [ newV ] = newPos ; // iterate through the edges incident on the new vertex for ( Edge e : newV . adjacentEdges ()) { isOrigEdge [ e ] = false ; // mark the new edges Vertex otherV = e . otherVertex ( newV ); // other side of edge // if this is a new edge between an old an new vertex, save for flipping if ( isOrigVert [ otherV ] && otherV != oldA && otherV != oldB ) { toFlip . push_back ( e ); } } } and finally, we can actually flip the edges to complete the second phase for ( Edge e : toFlip ) { mesh -> flip ( e ); } we now register this new mesh with geometry-central auto * psMesh = polyscope :: registerSurfaceMesh ( \"subdiv mesh\" , geometry -> inputVertexPositions , mesh -> getFaceVertexList ()); polyscope :: show (); and as expected get the subdivided mesh. Before: After:","title":"Basic Mutation"},{"location":"tutorials/basic_mutation/#basic-setup","text":"To begin we include headers, bring in namespaces, See the first tutorial for more info on these steps. #include \"geometrycentral/surface/manifold_surface_mesh.h\" #include \"geometrycentral/surface/meshio.h\" #include \"geometrycentral/surface/surface_mesh.h\" #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" using namespace geometrycentral ; using namespace geometrycentral :: surface ; Again as before, load an input mesh from file, and visualize it using Polyscope. Here, we\u2019ll require that the mesh be manifold. std :: unique_ptr < ManifoldSurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readManifoldSurfaceMesh ( args :: get ( inputFilename )); polyscope :: init (); polyscope :: registerSurfaceMesh ( \"input mesh\" , geometry -> inputVertexPositions , mesh -> getFaceVertexList ()); // call polyscope::show(); to inspect the mesh at this point Now, we\u2019ll evaluate a 4:1 sudivision via the following algorithm: split each edge and connect to opposite vertices flip any new edge connecting a new to old vertex First, we\u2019ll create two MeshData<> containers. They associate data with mesh elements. We initialize them both with true values, because initially all vertices (resp. edges) are original. We\u2019ll also track a list of edges to flip in the second phase. VertexData < bool > isOrigVert ( * mesh , true ); EdgeData < bool > isOrigEdge ( * mesh , true ); std :: vector < Edge > toFlip ; Now our main algorithm loop (commented inline). for ( Edge e : mesh -> edges ()) { // loop over all edges if ( ! isOrigEdge [ e ]) continue ; // don't keep processing new edges // gather both vertices incident on the edge, and their positions Vertex oldA = e . halfedge (). tipVertex (); Vertex oldB = e . halfedge (). tailVertex (); Vector3 oldAPos = geometry -> inputVertexPositions [ oldA ]; Vector3 oldBPos = geometry -> inputVertexPositions [ oldB ]; // split the edge Vertex newV = mesh -> splitEdgeTriangular ( e ). vertex (); isOrigVert [ newV ] = false ; // position the new vertex Vector3 newPos = 0.5 * ( oldAPos + oldBPos ); geometry -> inputVertexPositions [ newV ] = newPos ; // iterate through the edges incident on the new vertex for ( Edge e : newV . adjacentEdges ()) { isOrigEdge [ e ] = false ; // mark the new edges Vertex otherV = e . otherVertex ( newV ); // other side of edge // if this is a new edge between an old an new vertex, save for flipping if ( isOrigVert [ otherV ] && otherV != oldA && otherV != oldB ) { toFlip . push_back ( e ); } } } and finally, we can actually flip the edges to complete the second phase for ( Edge e : toFlip ) { mesh -> flip ( e ); } we now register this new mesh with geometry-central auto * psMesh = polyscope :: registerSurfaceMesh ( \"subdiv mesh\" , geometry -> inputVertexPositions , mesh -> getFaceVertexList ()); polyscope :: show (); and as expected get the subdivided mesh. Before: After:","title":"Basic setup"},{"location":"tutorials/direction_fields/","text":"This tutorial shows a higher-level example in geometry-central, where we use a built-in routine to visualize a direction field. View full, runnable source code in the tutorial repository. Basic setup To begin we include headers, bring in namespaces, See the first tutorial for more info on these steps. #include \"geometrycentral/surface/manifold_surface_mesh.h\" #include \"geometrycentral/surface/meshio.h\" #include \"geometrycentral/surface/surface_mesh.h\" #include \"geometrycentral/surface/direction_fields.h\" #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" using namespace geometrycentral ; using namespace geometrycentral :: surface ; Again, load an input mesh from file, and visualize it using Polyscope. We\u2019ll require that the mesh be manifold so we have obvious vertex tangent spaces. std :: unique_ptr < ManifoldSurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readManifoldSurfaceMesh ( args :: get ( inputFilename )); polyscope :: init (); auto * psMesh = polyscope :: registerSurfaceMesh ( \"input mesh\" , geometry -> inputVertexPositions , mesh -> getFaceVertexList ()); Now, computing the direction field itself amoutns to a single function call VertexData < Vector2 > field = computeSmoothestVertexDirectionField ( * geometry ); Before we visualize this direction field, we need to do a little more setup. The tangent vectors are defined in an abritrary, intrinsic tangent space at each vertex. We need to tell Polyscope how these tangent spaces sit in 3D space. geometry -> requireVertexTangentBasis (); VertexData < Vector3 > vBasisX ( * mesh ); for ( Vertex v : mesh -> vertices ()) { vBasisX [ v ] = geometry -> vertexTangentBasis [ v ][ 0 ]; } psMesh -> setVertexTangentBasisX ( vBasisX ); Now we can add the vector field to Polyscope and inspect it! psMesh -> addVertexIntrinsicVectorQuantity ( \"vectors\" , field ); polyscope :: show (); Result:","title":"Direction fields"},{"location":"tutorials/direction_fields/#basic-setup","text":"To begin we include headers, bring in namespaces, See the first tutorial for more info on these steps. #include \"geometrycentral/surface/manifold_surface_mesh.h\" #include \"geometrycentral/surface/meshio.h\" #include \"geometrycentral/surface/surface_mesh.h\" #include \"geometrycentral/surface/direction_fields.h\" #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" using namespace geometrycentral ; using namespace geometrycentral :: surface ; Again, load an input mesh from file, and visualize it using Polyscope. We\u2019ll require that the mesh be manifold so we have obvious vertex tangent spaces. std :: unique_ptr < ManifoldSurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readManifoldSurfaceMesh ( args :: get ( inputFilename )); polyscope :: init (); auto * psMesh = polyscope :: registerSurfaceMesh ( \"input mesh\" , geometry -> inputVertexPositions , mesh -> getFaceVertexList ()); Now, computing the direction field itself amoutns to a single function call VertexData < Vector2 > field = computeSmoothestVertexDirectionField ( * geometry ); Before we visualize this direction field, we need to do a little more setup. The tangent vectors are defined in an abritrary, intrinsic tangent space at each vertex. We need to tell Polyscope how these tangent spaces sit in 3D space. geometry -> requireVertexTangentBasis (); VertexData < Vector3 > vBasisX ( * mesh ); for ( Vertex v : mesh -> vertices ()) { vBasisX [ v ] = geometry -> vertexTangentBasis [ v ][ 0 ]; } psMesh -> setVertexTangentBasisX ( vBasisX ); Now we can add the vector field to Polyscope and inspect it! psMesh -> addVertexIntrinsicVectorQuantity ( \"vectors\" , field ); polyscope :: show (); Result:","title":"Basic setup"},{"location":"tutorials/load_mesh/","text":"This tutorial walks through some basics with geometry-central, showing how to load a mesh from file and iterate through its elements. View full, runnable source code in the tutorial repository. Basic setup To begin, we include the relevant headers, including some for visualization using Polyscope . #include \"geometrycentral/surface/manifold_surface_mesh.h\" #include \"geometrycentral/surface/meshio.h\" #include \"geometrycentral/surface/surface_mesh.h\" #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" All functionality of geometry-central is contained within the geometrycentral namespace; surface meshes live in geometrycentral::surface . We will bring both in to scope so we can just type SurfaceMesh instead of geometrycentral::surface::SurfaceMesh , etc. using namespace geometrycentral ; using namespace geometrycentral :: surface ; Now, we use the mesh loaders to construct a surface mesh\u2019s connectivity and geometry from file. Many common file formats like .obj , .ply , and .stl are supported. By default, this mesh class represents very general polygonal meshes, including nonmanifold meshes. std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readSurfaceMesh ( \"spot.obj\" ); Alternately, you could construct a mesh which is required to be manifold. std :: tie ( mesh , geometry ) = readManifoldSurfaceMesh ( \"spot.obj\" ); If you\u2019r not already familiar with std::unique_ptr<> , the following gives a bit more context (click to expand). Why use std::unique_ptr<> ? The mesh loader, like many functions in geometry-central, returns constructed objects via a unique_ptr . Unique pointers are an important tool for memory management in modern C++; if you haven\u2019t used them before, we suggest you give them a try! In most ways, a unique_ptr acts just like a normal C++ pointer. You can dereference it with *uPtr , and access its members and function like uPtr->function() . However, the unique_ptr helps prevent common memory-management mistakes, and communicates the programmer\u2019s intent about object lifetime. This is accomplished with two properties: You don\u2019t need to call delete on a unique_ptr , it happens automatically when the pointer is destructed, e.g. when it goes out of scope at the end of a function, or when the object it is a member of gets deleted. This helps prevent memory leaks where you forget to deallocate the object. You cannot copy the unique_ptr ; hence it is \u201cunique\u201d! You can still pass around references, or std::move() the pointer, which are sufficient for most reasonable uses. This helps prevent you from creating a copy, and then accidentally deleting the pointer twice. The general paradigm in geometry-central (and a recommended style in modern C++) is to return long-lived, allocated objects with a unique_ptr , and pass these objects in to functions and dependent classes by reference. For instance, we might write a function which takes a mesh as an argument like void processMesh ( SurfaceMesh & inputMesh ) { /* do stuff */ } and call it by dereferencing the unique pointer to pass a reference std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readSurfaceMesh ( \"spot.obj\" ); processMesh ( * mesh ); For more details about unique pointers, see the language documentation , or many tutorials around the web. If you really don\u2019t want to use unique pointers, you can simply release the unique pointer to an ordinary pointer: std :: unique_ptr < SurfaceMesh > mesh /* populated as above */ ; SurfaceMesh * meshPtr = mesh . release (); The meshPtr now points the mesh object, and you are responsible for eventually deleting this pointer. After calling release() , the unique pointer points to nothing and will no longer deallocate the object. Traverse the mesh As a simple demonstration of the mesh data structure, lets iterate through the vertices of the mesh, and for each vertex print the adjacent faces. for ( Vertex v : mesh -> vertices ()) { std :: cout << \"Vertex \" << v << \" has degree \" << v . degree () << \" \\n \" ; for ( Face fn : v . adjacentFaces ()) { std :: cout << \" incident on face \" << fn << \" \\n \" ; } } This prints something like: ... Vertex v_2907 has degree 6 incident on face f_5815 incident on face f_2885 incident on face f_2887 incident on face f_5812 incident on face f_5813 incident on face f_5814 Vertex v_2908 has degree 6 incident on face f_5822 incident on face f_2888 ... Visualize the mesh with Polyscope Finally, we can easily visualize the mesh we loaded via Polyscope. polyscope :: init (); // initialize the gui // add the mesh to the gui polyscope :: registerSurfaceMesh ( \"my mesh\" , geometry -> inputVertexPositions , mesh -> getFaceVertexList ()); polyscope :: show (); // pass control to the gui until the user exits","title":"Load & navigate a mesh"},{"location":"tutorials/load_mesh/#basic-setup","text":"To begin, we include the relevant headers, including some for visualization using Polyscope . #include \"geometrycentral/surface/manifold_surface_mesh.h\" #include \"geometrycentral/surface/meshio.h\" #include \"geometrycentral/surface/surface_mesh.h\" #include \"polyscope/polyscope.h\" #include \"polyscope/surface_mesh.h\" All functionality of geometry-central is contained within the geometrycentral namespace; surface meshes live in geometrycentral::surface . We will bring both in to scope so we can just type SurfaceMesh instead of geometrycentral::surface::SurfaceMesh , etc. using namespace geometrycentral ; using namespace geometrycentral :: surface ; Now, we use the mesh loaders to construct a surface mesh\u2019s connectivity and geometry from file. Many common file formats like .obj , .ply , and .stl are supported. By default, this mesh class represents very general polygonal meshes, including nonmanifold meshes. std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readSurfaceMesh ( \"spot.obj\" ); Alternately, you could construct a mesh which is required to be manifold. std :: tie ( mesh , geometry ) = readManifoldSurfaceMesh ( \"spot.obj\" ); If you\u2019r not already familiar with std::unique_ptr<> , the following gives a bit more context (click to expand). Why use std::unique_ptr<> ? The mesh loader, like many functions in geometry-central, returns constructed objects via a unique_ptr . Unique pointers are an important tool for memory management in modern C++; if you haven\u2019t used them before, we suggest you give them a try! In most ways, a unique_ptr acts just like a normal C++ pointer. You can dereference it with *uPtr , and access its members and function like uPtr->function() . However, the unique_ptr helps prevent common memory-management mistakes, and communicates the programmer\u2019s intent about object lifetime. This is accomplished with two properties: You don\u2019t need to call delete on a unique_ptr , it happens automatically when the pointer is destructed, e.g. when it goes out of scope at the end of a function, or when the object it is a member of gets deleted. This helps prevent memory leaks where you forget to deallocate the object. You cannot copy the unique_ptr ; hence it is \u201cunique\u201d! You can still pass around references, or std::move() the pointer, which are sufficient for most reasonable uses. This helps prevent you from creating a copy, and then accidentally deleting the pointer twice. The general paradigm in geometry-central (and a recommended style in modern C++) is to return long-lived, allocated objects with a unique_ptr , and pass these objects in to functions and dependent classes by reference. For instance, we might write a function which takes a mesh as an argument like void processMesh ( SurfaceMesh & inputMesh ) { /* do stuff */ } and call it by dereferencing the unique pointer to pass a reference std :: unique_ptr < SurfaceMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = readSurfaceMesh ( \"spot.obj\" ); processMesh ( * mesh ); For more details about unique pointers, see the language documentation , or many tutorials around the web. If you really don\u2019t want to use unique pointers, you can simply release the unique pointer to an ordinary pointer: std :: unique_ptr < SurfaceMesh > mesh /* populated as above */ ; SurfaceMesh * meshPtr = mesh . release (); The meshPtr now points the mesh object, and you are responsible for eventually deleting this pointer. After calling release() , the unique pointer points to nothing and will no longer deallocate the object.","title":"Basic setup"},{"location":"tutorials/load_mesh/#traverse-the-mesh","text":"As a simple demonstration of the mesh data structure, lets iterate through the vertices of the mesh, and for each vertex print the adjacent faces. for ( Vertex v : mesh -> vertices ()) { std :: cout << \"Vertex \" << v << \" has degree \" << v . degree () << \" \\n \" ; for ( Face fn : v . adjacentFaces ()) { std :: cout << \" incident on face \" << fn << \" \\n \" ; } } This prints something like: ... Vertex v_2907 has degree 6 incident on face f_5815 incident on face f_2885 incident on face f_2887 incident on face f_5812 incident on face f_5813 incident on face f_5814 Vertex v_2908 has degree 6 incident on face f_5822 incident on face f_2888 ...","title":"Traverse the mesh"},{"location":"tutorials/load_mesh/#visualize-the-mesh-with-polyscope","text":"Finally, we can easily visualize the mesh we loaded via Polyscope. polyscope :: init (); // initialize the gui // add the mesh to the gui polyscope :: registerSurfaceMesh ( \"my mesh\" , geometry -> inputVertexPositions , mesh -> getFaceVertexList ()); polyscope :: show (); // pass control to the gui until the user exits","title":"Visualize the mesh with Polyscope"},{"location":"utilities/eigenmap/","text":"Helper functions to interface with Eigen data in interesting ways. #include \"geometrycentral/utilities/eigen_interop_helpers.h\" Expanding a homogenous POD type into an Eigen::Matrix Eigen :: Map < Eigen :: Matrix < T , Eigen :: Dynamic , k , Options > , Alignment > EigenMap ( MeshData < E , O > & data ) Given MeshData storing a POD type O like Vector3 which can be meaningfully decomposed into a set of k other types T , this function maps the memory of the vector of O as a Matrix<T, Dynamic, k> . E.g., MeshData<Vertex, Vector3> (N x 1) -> Map<Matrix<double, Dynamic, 3>> (N x 3). The template Options allows you to specify is the underlying data should be bound in RowMajor or ColMajor order. VertexData < Vector3 > pos ; // auto resolves to Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, 3, Eigen::RowMajor>, Alignment> auto mapped_position_matrix = EigenMap < double , 3 , Eigen :: RowMajor > ( pos ); Note that it is unnecessary to specify Eigen::RowMajor in this example since it is the default template option. Furthermore template options E and O corresponding to the Mesh Element and Data Type need not be explicitly specified since the compiler can infer it for us. Most important, modifications to mapped_position_matrix will be reflected in pos since they share the same memory! Eigen :: Map < const Eigen :: Matrix < T , Eigen :: Dynamic , k , Options > , Alignment > EigenMap ( const MeshData < E , O > & data ) Const version of the above. Flattening a homogeneous POD type into an Eigen::Vector Eigen :: Map < Eigen :: Matrix < T , Eigen :: Dynamic , 1 , Options > , Alignment > FlattenedEigenMap ( MeshData < E , O > & data ) Given MeshData storing a POD type O like Vector3 which can be meaningfully decomposed into a set of k other types T , this function maps the memory of the vector of O as a vector of T ( Matrix<T, Dynamic, 1> ). E.g., MeshData<Vertex, Vector3> (N x 1) -> Map<Matrix<double, Dynamic, 1>> (3N x 1). The template Options allows you to specify is the underlying data should be bound in RowMajor or ColMajor order. VertexData < Vector3 > pos ; // auto resolves to Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, 1, Eigen::ColMajor>, Alignment> auto mapped_flat_position_matrix = FlattenedEigenMap < double , 3 > ( pos ); Note that the return defaults to ColMajor order. The template options E and O corresponding to the Mesh Element and Data Type need not be explicitly specified since the compiler can infer it for us. Most important, modifications to mapped_flat_position_matrix will be reflected in pos since they share the same memory! Eigen :: Map < const Eigen :: Matrix < T , Eigen :: Dynamic , 1 , Options > , Alignment > FlattenedEigenMap ( const MeshData < E , O > & data ) Const version of the above.","title":"Utilities for Eigen Interoperability"},{"location":"utilities/eigenmap/#expanding-a-homogenous-pod-type-into-an-eigenmatrix","text":"Eigen :: Map < Eigen :: Matrix < T , Eigen :: Dynamic , k , Options > , Alignment > EigenMap ( MeshData < E , O > & data ) Given MeshData storing a POD type O like Vector3 which can be meaningfully decomposed into a set of k other types T , this function maps the memory of the vector of O as a Matrix<T, Dynamic, k> . E.g., MeshData<Vertex, Vector3> (N x 1) -> Map<Matrix<double, Dynamic, 3>> (N x 3). The template Options allows you to specify is the underlying data should be bound in RowMajor or ColMajor order. VertexData < Vector3 > pos ; // auto resolves to Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, 3, Eigen::RowMajor>, Alignment> auto mapped_position_matrix = EigenMap < double , 3 , Eigen :: RowMajor > ( pos ); Note that it is unnecessary to specify Eigen::RowMajor in this example since it is the default template option. Furthermore template options E and O corresponding to the Mesh Element and Data Type need not be explicitly specified since the compiler can infer it for us. Most important, modifications to mapped_position_matrix will be reflected in pos since they share the same memory! Eigen :: Map < const Eigen :: Matrix < T , Eigen :: Dynamic , k , Options > , Alignment > EigenMap ( const MeshData < E , O > & data ) Const version of the above.","title":"Expanding a homogenous POD type into an Eigen::Matrix"},{"location":"utilities/eigenmap/#flattening-a-homogeneous-pod-type-into-an-eigenvector","text":"Eigen :: Map < Eigen :: Matrix < T , Eigen :: Dynamic , 1 , Options > , Alignment > FlattenedEigenMap ( MeshData < E , O > & data ) Given MeshData storing a POD type O like Vector3 which can be meaningfully decomposed into a set of k other types T , this function maps the memory of the vector of O as a vector of T ( Matrix<T, Dynamic, 1> ). E.g., MeshData<Vertex, Vector3> (N x 1) -> Map<Matrix<double, Dynamic, 1>> (3N x 1). The template Options allows you to specify is the underlying data should be bound in RowMajor or ColMajor order. VertexData < Vector3 > pos ; // auto resolves to Eigen::Map<Eigen::Matrix<double, Eigen::Dynamic, 1, Eigen::ColMajor>, Alignment> auto mapped_flat_position_matrix = FlattenedEigenMap < double , 3 > ( pos ); Note that the return defaults to ColMajor order. The template options E and O corresponding to the Mesh Element and Data Type need not be explicitly specified since the compiler can infer it for us. Most important, modifications to mapped_flat_position_matrix will be reflected in pos since they share the same memory! Eigen :: Map < const Eigen :: Matrix < T , Eigen :: Dynamic , 1 , Options > , Alignment > FlattenedEigenMap ( const MeshData < E , O > & data ) Const version of the above.","title":"Flattening a homogeneous POD type into an Eigen::Vector"},{"location":"utilities/miscellaneous/","text":"Miscellaneous utility functions. #include \"geometrycentral/utilities/utilities.h\" Constants size_t INVALID_IND Used to represent invalid indices. Defined as std::numeric_limits<size_t>::max() double PI Defined to be 3 . Just kidding. Angles and arithmetic T clamp ( T val , T low , T high ) Returns val clamped to lie bewteen low and high (using comparison operators). double regularizeAngle ( double theta ) Shifts an angle to lie in the range [ 0 0 , 2 \\pi 2 \\pi ]. Random numbers All random values are drawn from a generator seeded at program initialization. The generator is seeded via std::random_device , so results will not be consistent between repeated runs of the program. double unitRand () Returns a uniformly-distributed value on [0,1] [0,1] . double randomReal () Returns a uniformly-distributed value on [0,1] [0,1] . double randomNormal ( double mean = 0.0 , double stddev = 1.0 ) Returns a normally-distributed value from the specified mean and variance. int randomInt ( int lower , int upper ) Returns a uniformly-distributed integer on the INCLUSIVE range [lower, upper] size_t randomIndex ( size_t size ) Returns a uniformly-distributed integer on the range [0, size) . Indices and lists std :: vector < T > applyPermutation ( const std :: vector < T >& sourceData , const std :: vector < size_t >& permOldToNew ) Apply a permutation to reorder a vector, such that output[i] = sourceData[permOldToNew[i]] . The permutation should be an injection to [0,sourceData.size()) . The sourceData , permOldToNew , and the output should all have same size. Printing and strings std :: string to_string ( std :: vector < T > const & v ) Print the elements of vector to a string using the << operator for each element. std :: string str_printf ( const std :: string & format , Args ... args ) Print directly to a string, where format and args obey printf semantics. Memory management void safeDelete ( T *& x ) Call delete on a pointer. If the pointer is nullptr , does nothing. If it is non-null, sets to nullptr after deleting. void safeDeleteArray ( T *& x ) Like safeDelete() , but for arrays. Type names Useful for debugging templated code. Uses typeid() from <typeinfo> . std :: string typeNameString ( T & x ) Returns the name of a type as a string. std :: string typeNameString ( T * x ) Like typeNameString(T& x) , but for pointers.","title":"Miscellaneous"},{"location":"utilities/miscellaneous/#constants","text":"size_t INVALID_IND Used to represent invalid indices. Defined as std::numeric_limits<size_t>::max() double PI Defined to be 3 . Just kidding.","title":"Constants"},{"location":"utilities/miscellaneous/#angles-and-arithmetic","text":"T clamp ( T val , T low , T high ) Returns val clamped to lie bewteen low and high (using comparison operators). double regularizeAngle ( double theta ) Shifts an angle to lie in the range [ 0 0 , 2 \\pi 2 \\pi ].","title":"Angles and arithmetic"},{"location":"utilities/miscellaneous/#random-numbers","text":"All random values are drawn from a generator seeded at program initialization. The generator is seeded via std::random_device , so results will not be consistent between repeated runs of the program. double unitRand () Returns a uniformly-distributed value on [0,1] [0,1] . double randomReal () Returns a uniformly-distributed value on [0,1] [0,1] . double randomNormal ( double mean = 0.0 , double stddev = 1.0 ) Returns a normally-distributed value from the specified mean and variance. int randomInt ( int lower , int upper ) Returns a uniformly-distributed integer on the INCLUSIVE range [lower, upper] size_t randomIndex ( size_t size ) Returns a uniformly-distributed integer on the range [0, size) .","title":"Random numbers"},{"location":"utilities/miscellaneous/#indices-and-lists","text":"std :: vector < T > applyPermutation ( const std :: vector < T >& sourceData , const std :: vector < size_t >& permOldToNew ) Apply a permutation to reorder a vector, such that output[i] = sourceData[permOldToNew[i]] . The permutation should be an injection to [0,sourceData.size()) . The sourceData , permOldToNew , and the output should all have same size.","title":"Indices and lists"},{"location":"utilities/miscellaneous/#printing-and-strings","text":"std :: string to_string ( std :: vector < T > const & v ) Print the elements of vector to a string using the << operator for each element. std :: string str_printf ( const std :: string & format , Args ... args ) Print directly to a string, where format and args obey printf semantics.","title":"Printing and strings"},{"location":"utilities/miscellaneous/#memory-management","text":"void safeDelete ( T *& x ) Call delete on a pointer. If the pointer is nullptr , does nothing. If it is non-null, sets to nullptr after deleting. void safeDeleteArray ( T *& x ) Like safeDelete() , but for arrays.","title":"Memory management"},{"location":"utilities/miscellaneous/#type-names","text":"Useful for debugging templated code. Uses typeid() from <typeinfo> . std :: string typeNameString ( T & x ) Returns the name of a type as a string. std :: string typeNameString ( T * x ) Like typeNameString(T& x) , but for pointers.","title":"Type names"},{"location":"utilities/vector2/","text":"geometrycentral::Vector2 is the basic 2D vector type in geometry central. Like a good turkey sandwich, it aims to be unsurprising yet satisfying. Of particular interest, Vector2 is also used to encode 2D rotations, by supporting multiplication as a complex number. See the rotations section . #include \"geometrycentral/utilities/vector2.h\" Construction Vector2 is a POD type, so you should use brace-initialization sytax: #include \"geometrycentral/vector2.h using namespace geometrycentral ; Vector2 myVec { 3.8 , 2.9 }; //create myVec = Vector2 { 1.1 , 2.2 }; // reassign Factory methods can construct a few common values: static Vector2 Vector2 :: zero () Returns the zero vector static Vector2 Vector2 :: constant ( double c ) Returns a vector with all components set to c c static Vector2 Vector2 :: infinity () Returns the infinite vector (\\infty, \\infty) (\\infty, \\infty) . static Vector2 Vector2 :: undefined () Returns the undefined vector (NaN, NaN) . And serve as constructors: static Vector2 Vector2 :: fromAngle ( double theta ) Returns the vector (\\cos(\\theta), \\sin(\\theta)) (\\cos(\\theta), \\sin(\\theta)) . static Vector2 Vector2 :: fromComplex ( std :: complex < double > c ) Converts a std::complex<double> to a Vector2 . Access The two elements of the vector can be accessed as vec.x and vec.y . Alternately, the two elements can be indexed as vec[0] and vec[1] . Conversion Vector2 :: operator std :: complex < double > () Vector2 is implicitly convertible to std::complex<double> . Vector2 :: operator << () Vector2 can be serialized. Vector2 v { 1.2 , 3.4 }; std :: cout << v << std :: endl ; // prints something like: <1.2, 3.4> Arithmetic Vector2 supports the element-wise addition, subraction, and scalar multiplication you would probably expect. Rotations and complex multiplication Our Vector2 types further obey the multiplication and division rules of complex arithmetic, and thus can be used to represent rotations. For instance, a unit 2D vector representing a rotation can be used to rotate another vector like: Vector2 v = /* your vector */ Vector2 r = Vector2 :: fromAngle ( PI / 4 ); // rotation by 45 degrees Vector2 vRot = r * v ; This is fundamentally no different from using 2x2 rotation matrices, but leads to much cleaner code (try using division to compute relative rotations!). Member operations These methods do not change the underlying Vector2 , but return a new Vector2 . Vector2 vec { 1. , 2. }; vec . rotate90 (); // does nothing vec = vec . rotate90 (); // much better Vector2 Vector2 :: normalize () Returns a unit-norm vector with the same direction. If the input is the zero vector, the result will contain NaNs. Vector2 Vector2 :: normalizeCutoff ( double mag = 0. ) Returns a unit-norm vector with the same direction. If the input has magnitude less <= mag , the vector is unchanged. Vector2 Vector2 :: unit () Alias for normalize() . Vector2 Vector2 :: rotate ( double theta ) Rotate the vector by angle \\theta \\theta in the counter-clockwise direction. Vector2 Vector2 :: rotate90 () Rotate the vector by 90^{\\circ} 90^{\\circ} in the counter-clockwise direction. Vector2 Vector2 :: pow ( double p ) Raise the vector to a real power, in the sense of complex arithmetic. (see std::pow ) Vector2 Vector2 :: pow ( Vector2 p ) Raise the vector to a complex power, in the sense of complex arithmetic. (see std::pow ) Vector2 Vector2 :: conj () Transform the vector to its complex conjugate, negating the y component. Vector2 Vector2 :: inv () Invert the vector, in the sense of complex arithmetic. Equivalent to Vector2{1., 0.} / v . Function operations These operations do not change the vector on which they are called. double norm ( Vector2 v ) Returns the magnitude of the vector. Also available as v.norm() . double norm2 ( Vector2 v ) Returns the squared magnitude of the vector. Also available as v.norm() . Vector2 normalize ( Vector2 v ) Returns normalized copy of the vector. Vector2 normalizeCutoff ( Vector2 v , double mag = 0. ) Returns a normalized copy of the vector. If the input has magnitude less <= mag , the vector is unchanged. Vector2 unit ( Vector2 v ) Alias for normalize(v) . double arg ( Vector2 v ) Returns the argument in the sense of complex arithmetic (i.e., the angle against the x x -axis). Also available as v.arg() . double dot ( Vector2 u , Vector2 v ) Returns the dot product between two vectors. double cross ( Vector2 u , Vector2 v ) Returns the \u201ccross\u201d product between two vectors, that is u.x * v.y - u.y * v.x . Intuitively, the z z -component of the 3D cross product of vectors in the plane. Vector3 cross3 ( Vector2 u , Vector2 v ) Returns the 3D cross product of vectors in the plane. double angle ( Vector2 u , Vector2 v ) Returns the angle between two not-necessarily-unit vectors. Output in the range [0, \\pi] [0, \\pi] . Vector2 clamp ( Vector2 val , Vector2 low , Vector2 high ) Returns returns a a vector where each component has been clamped to be between the corresponding compnents of low and high . Vector2 componentwiseMin ( Vector2 u , Vector2 v ) Returns a new vector, each component of which is the minimum of that component in u and v . Vector2 componentwiseMax ( Vector2 u , Vector2 v ) Returns a new vector, each component of which is the maximum of that component in u and v . Properties bool isfinite ( Vector2 u ) Returns true if both of the components of the vector are finite. Note: this function is intentionally not camel-cased out of solidarity with std::isfinite() . Also available as u.isFinite() . bool isDefined ( Vector2 u ) Returns true if both of the components of the vector are not NaN. Also available as u.isDefined() .","title":"Vector2"},{"location":"utilities/vector2/#construction","text":"Vector2 is a POD type, so you should use brace-initialization sytax: #include \"geometrycentral/vector2.h using namespace geometrycentral ; Vector2 myVec { 3.8 , 2.9 }; //create myVec = Vector2 { 1.1 , 2.2 }; // reassign Factory methods can construct a few common values: static Vector2 Vector2 :: zero () Returns the zero vector static Vector2 Vector2 :: constant ( double c ) Returns a vector with all components set to c c static Vector2 Vector2 :: infinity () Returns the infinite vector (\\infty, \\infty) (\\infty, \\infty) . static Vector2 Vector2 :: undefined () Returns the undefined vector (NaN, NaN) . And serve as constructors: static Vector2 Vector2 :: fromAngle ( double theta ) Returns the vector (\\cos(\\theta), \\sin(\\theta)) (\\cos(\\theta), \\sin(\\theta)) . static Vector2 Vector2 :: fromComplex ( std :: complex < double > c ) Converts a std::complex<double> to a Vector2 .","title":"Construction"},{"location":"utilities/vector2/#access","text":"The two elements of the vector can be accessed as vec.x and vec.y . Alternately, the two elements can be indexed as vec[0] and vec[1] .","title":"Access"},{"location":"utilities/vector2/#conversion","text":"Vector2 :: operator std :: complex < double > () Vector2 is implicitly convertible to std::complex<double> . Vector2 :: operator << () Vector2 can be serialized. Vector2 v { 1.2 , 3.4 }; std :: cout << v << std :: endl ; // prints something like: <1.2, 3.4>","title":"Conversion"},{"location":"utilities/vector2/#arithmetic","text":"Vector2 supports the element-wise addition, subraction, and scalar multiplication you would probably expect.","title":"Arithmetic"},{"location":"utilities/vector2/#rotations-and-complex-multiplication","text":"Our Vector2 types further obey the multiplication and division rules of complex arithmetic, and thus can be used to represent rotations. For instance, a unit 2D vector representing a rotation can be used to rotate another vector like: Vector2 v = /* your vector */ Vector2 r = Vector2 :: fromAngle ( PI / 4 ); // rotation by 45 degrees Vector2 vRot = r * v ; This is fundamentally no different from using 2x2 rotation matrices, but leads to much cleaner code (try using division to compute relative rotations!).","title":"Rotations and complex multiplication"},{"location":"utilities/vector2/#member-operations","text":"These methods do not change the underlying Vector2 , but return a new Vector2 . Vector2 vec { 1. , 2. }; vec . rotate90 (); // does nothing vec = vec . rotate90 (); // much better Vector2 Vector2 :: normalize () Returns a unit-norm vector with the same direction. If the input is the zero vector, the result will contain NaNs. Vector2 Vector2 :: normalizeCutoff ( double mag = 0. ) Returns a unit-norm vector with the same direction. If the input has magnitude less <= mag , the vector is unchanged. Vector2 Vector2 :: unit () Alias for normalize() . Vector2 Vector2 :: rotate ( double theta ) Rotate the vector by angle \\theta \\theta in the counter-clockwise direction. Vector2 Vector2 :: rotate90 () Rotate the vector by 90^{\\circ} 90^{\\circ} in the counter-clockwise direction. Vector2 Vector2 :: pow ( double p ) Raise the vector to a real power, in the sense of complex arithmetic. (see std::pow ) Vector2 Vector2 :: pow ( Vector2 p ) Raise the vector to a complex power, in the sense of complex arithmetic. (see std::pow ) Vector2 Vector2 :: conj () Transform the vector to its complex conjugate, negating the y component. Vector2 Vector2 :: inv () Invert the vector, in the sense of complex arithmetic. Equivalent to Vector2{1., 0.} / v .","title":"Member operations"},{"location":"utilities/vector2/#function-operations","text":"These operations do not change the vector on which they are called. double norm ( Vector2 v ) Returns the magnitude of the vector. Also available as v.norm() . double norm2 ( Vector2 v ) Returns the squared magnitude of the vector. Also available as v.norm() . Vector2 normalize ( Vector2 v ) Returns normalized copy of the vector. Vector2 normalizeCutoff ( Vector2 v , double mag = 0. ) Returns a normalized copy of the vector. If the input has magnitude less <= mag , the vector is unchanged. Vector2 unit ( Vector2 v ) Alias for normalize(v) . double arg ( Vector2 v ) Returns the argument in the sense of complex arithmetic (i.e., the angle against the x x -axis). Also available as v.arg() . double dot ( Vector2 u , Vector2 v ) Returns the dot product between two vectors. double cross ( Vector2 u , Vector2 v ) Returns the \u201ccross\u201d product between two vectors, that is u.x * v.y - u.y * v.x . Intuitively, the z z -component of the 3D cross product of vectors in the plane. Vector3 cross3 ( Vector2 u , Vector2 v ) Returns the 3D cross product of vectors in the plane. double angle ( Vector2 u , Vector2 v ) Returns the angle between two not-necessarily-unit vectors. Output in the range [0, \\pi] [0, \\pi] . Vector2 clamp ( Vector2 val , Vector2 low , Vector2 high ) Returns returns a a vector where each component has been clamped to be between the corresponding compnents of low and high . Vector2 componentwiseMin ( Vector2 u , Vector2 v ) Returns a new vector, each component of which is the minimum of that component in u and v . Vector2 componentwiseMax ( Vector2 u , Vector2 v ) Returns a new vector, each component of which is the maximum of that component in u and v .","title":"Function operations"},{"location":"utilities/vector2/#properties","text":"bool isfinite ( Vector2 u ) Returns true if both of the components of the vector are finite. Note: this function is intentionally not camel-cased out of solidarity with std::isfinite() . Also available as u.isFinite() . bool isDefined ( Vector2 u ) Returns true if both of the components of the vector are not NaN. Also available as u.isDefined() .","title":"Properties"},{"location":"utilities/vector3/","text":"geometrycentral::Vector3 is the basic 3D vector type in geometry central. There are many like it, but this one is ours. #include \"geometrycentral/utilities/vector3.h\" Construction Vector3 is a POD type, so you should use brace-initialization sytax: #include \"geometrycentral/vector3.h using namespace geometrycentral ; Vector3 myVec { 3.8 , 2.9 , 1.1 }; //create myVec = Vector3 { 1.1 , 2.2 , 3.3 }; // reassign Factory methods can construct a few common values: static Vector3 Vector3 :: zero () Returns the zero vector static Vector3 Vector3 :: constant ( double c ) Returns a vector with all components set to c c static Vector3 Vector3 :: infinity () Returns the infinite vector (\\infty, \\infty, \\infty) (\\infty, \\infty, \\infty) . static Vector3 Vector3 :: undefined () Returns the undefined vector (NaN, NaN, NaN) . Access The three elements of the vector can be accessed as vec.x and vec.y and vec.z . Alternately, the elements can be indexed as vec[0] and vec[1] and vec[2] . Conversion Vector3 :: operator << () Vector3 can be serialized. Vector3 v { 1.2 , 3.4 , 5.6 }; std :: cout << v << std :: endl ; // prints something like: <1.2, 3.4, 5.6> Arithmetic Vector3 supports the element-wise addition, subtraction, and scalar multiplication you would probably expect. Member operations These methods do not change the underlying Vector3 , but return a new Vector3 . Vector3 vec { 1. , 2. , 3. }; vec . normalize (); // does nothing vec = vec . normalize (); // much better Vector3 Vector3 :: normalize () Returns a unit-norm vector pointing in the same direction. If the input is the zero vector, the result will contain NaNs. Vector3 Vector3 :: normalizeCutoff ( double mag = 0. ) Returns a unit-norm vector with the same direction. If the input has magnitude less <= mag , the vector is unchanged. Vector3 Vector3 :: unit () Alias for normalize() . Vector3 Vector3 :: rotateAround ( Vector3 axis , double theta ) Rotate the vector by angle \\theta \\theta around axis in the right-handed direction. axis need not be a unit vector. Vector3 Vector3 :: removeComponent ( Vector3 unitDir ) Removes any component of this vector in the direction unitDir , making the result orthogonal to unitDir . As the name suggests, unitDir must be a unit vector. double Vector3 :: norm () Returns the magnitude of the vector. Also available as norm(v) . double Vector3 :: norm2 () Returns the squared magnitude of the vector. Also available as norm2(v) . Function operations These operations do not change the vector on which they are called. double norm ( Vector3 v ) Returns the magnitude of the vector. Also available as v.norm() . double norm2 ( Vector3 v ) Returns the squared magnitude of the vector. Also available as v.norm2() . Vector3 normalize ( Vector3 v ) Returns normalized copy of the vector. Vector3 normalizeCutoff ( Vector3 v , double mag = 0. ) Returns a normalized copy of the vector. If the input has magnitude less <= mag , the vector is unchanged. Vector3 unit ( Vector3 v ) Alias for normalize(v) . double dot ( Vector3 u , Vector3 v ) Returns the dot product between two vectors. double sum ( Vector3 u ) Returns the sum of the coordinates of a vector Vector3 cross ( Vector3 u , Vector3 v ) Returns the cross product between two vectors. double angle ( Vector3 u , Vector3 v ) Returns the angle between two not-necessarily-unit vectors. Output in the range [0, \\pi] [0, \\pi] . double angleInPlane ( Vector3 u , Vector3 v , Vector3 normal ) Returns the signed angle between two not-necessarily-unit vectors, measured in the plane defined by normal (which need not be a unit vector). Output is in the range [-\\pi, \\pi] [-\\pi, \\pi] , as in atan2 . Vector3 clamp ( Vector3 val , Vector3 low , Vector3 high ) Returns returns a a vector where each component has been clamped to be between the corresponding compnents of low and high . Vector3 componentwiseMin ( Vector3 u , Vector3 v ) Returns a new vector, each component of which is the minimum of that component in u and v . Vector3 componentwiseMax ( Vector3 u , Vector3 v ) Returns a new vector, each component of which is the maximum of that component in u and v . Properties bool isfinite ( Vector3 u ) Returns true if all of the components of the vector are finite. Note: this function is intentionally not camel-cased out of solidarity with std::isfinite() . Also available as u.isFinite() . bool isDefined ( Vector3 u ) Returns true if all of the components of the vector are not NaN. Also available as u.isDefined() .","title":"Vector3"},{"location":"utilities/vector3/#construction","text":"Vector3 is a POD type, so you should use brace-initialization sytax: #include \"geometrycentral/vector3.h using namespace geometrycentral ; Vector3 myVec { 3.8 , 2.9 , 1.1 }; //create myVec = Vector3 { 1.1 , 2.2 , 3.3 }; // reassign Factory methods can construct a few common values: static Vector3 Vector3 :: zero () Returns the zero vector static Vector3 Vector3 :: constant ( double c ) Returns a vector with all components set to c c static Vector3 Vector3 :: infinity () Returns the infinite vector (\\infty, \\infty, \\infty) (\\infty, \\infty, \\infty) . static Vector3 Vector3 :: undefined () Returns the undefined vector (NaN, NaN, NaN) .","title":"Construction"},{"location":"utilities/vector3/#access","text":"The three elements of the vector can be accessed as vec.x and vec.y and vec.z . Alternately, the elements can be indexed as vec[0] and vec[1] and vec[2] .","title":"Access"},{"location":"utilities/vector3/#conversion","text":"Vector3 :: operator << () Vector3 can be serialized. Vector3 v { 1.2 , 3.4 , 5.6 }; std :: cout << v << std :: endl ; // prints something like: <1.2, 3.4, 5.6>","title":"Conversion"},{"location":"utilities/vector3/#arithmetic","text":"Vector3 supports the element-wise addition, subtraction, and scalar multiplication you would probably expect.","title":"Arithmetic"},{"location":"utilities/vector3/#member-operations","text":"These methods do not change the underlying Vector3 , but return a new Vector3 . Vector3 vec { 1. , 2. , 3. }; vec . normalize (); // does nothing vec = vec . normalize (); // much better Vector3 Vector3 :: normalize () Returns a unit-norm vector pointing in the same direction. If the input is the zero vector, the result will contain NaNs. Vector3 Vector3 :: normalizeCutoff ( double mag = 0. ) Returns a unit-norm vector with the same direction. If the input has magnitude less <= mag , the vector is unchanged. Vector3 Vector3 :: unit () Alias for normalize() . Vector3 Vector3 :: rotateAround ( Vector3 axis , double theta ) Rotate the vector by angle \\theta \\theta around axis in the right-handed direction. axis need not be a unit vector. Vector3 Vector3 :: removeComponent ( Vector3 unitDir ) Removes any component of this vector in the direction unitDir , making the result orthogonal to unitDir . As the name suggests, unitDir must be a unit vector. double Vector3 :: norm () Returns the magnitude of the vector. Also available as norm(v) . double Vector3 :: norm2 () Returns the squared magnitude of the vector. Also available as norm2(v) .","title":"Member operations"},{"location":"utilities/vector3/#function-operations","text":"These operations do not change the vector on which they are called. double norm ( Vector3 v ) Returns the magnitude of the vector. Also available as v.norm() . double norm2 ( Vector3 v ) Returns the squared magnitude of the vector. Also available as v.norm2() . Vector3 normalize ( Vector3 v ) Returns normalized copy of the vector. Vector3 normalizeCutoff ( Vector3 v , double mag = 0. ) Returns a normalized copy of the vector. If the input has magnitude less <= mag , the vector is unchanged. Vector3 unit ( Vector3 v ) Alias for normalize(v) . double dot ( Vector3 u , Vector3 v ) Returns the dot product between two vectors. double sum ( Vector3 u ) Returns the sum of the coordinates of a vector Vector3 cross ( Vector3 u , Vector3 v ) Returns the cross product between two vectors. double angle ( Vector3 u , Vector3 v ) Returns the angle between two not-necessarily-unit vectors. Output in the range [0, \\pi] [0, \\pi] . double angleInPlane ( Vector3 u , Vector3 v , Vector3 normal ) Returns the signed angle between two not-necessarily-unit vectors, measured in the plane defined by normal (which need not be a unit vector). Output is in the range [-\\pi, \\pi] [-\\pi, \\pi] , as in atan2 . Vector3 clamp ( Vector3 val , Vector3 low , Vector3 high ) Returns returns a a vector where each component has been clamped to be between the corresponding compnents of low and high . Vector3 componentwiseMin ( Vector3 u , Vector3 v ) Returns a new vector, each component of which is the minimum of that component in u and v . Vector3 componentwiseMax ( Vector3 u , Vector3 v ) Returns a new vector, each component of which is the maximum of that component in u and v .","title":"Function operations"},{"location":"utilities/vector3/#properties","text":"bool isfinite ( Vector3 u ) Returns true if all of the components of the vector are finite. Note: this function is intentionally not camel-cased out of solidarity with std::isfinite() . Also available as u.isFinite() . bool isDefined ( Vector3 u ) Returns true if all of the components of the vector are not NaN. Also available as u.isDefined() .","title":"Properties"}]}