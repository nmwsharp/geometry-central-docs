{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Geometry Central Geometry-central is a modern C++ library of data structures and algorithms for geometry processing, with a particular focus on surface meshes. Features include: A polished halfedge mesh class, with efficient support for mesh modification, and a system of containers for associating data with mesh elements. Implementations of canonical geometric quantities on surfaces, ranging from normals and curvatures to tangent vector bases to operators from discrete differential geometry. A suite of powerful algorithms , including computing distances on surface, generating direction fields, and manipulating intrinsic Delaunay triangulations. A coherent set of sparse linear algebra tools , based on Eigen and augmented to automatically utilize better solvers if available on your system. Under construction As of July 30, 2019, geometry-central and its documentation are still under active development. You are welcome and encouraged to start using the library, but some components are still being built and modified. Sample: // Load a mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( \"spot.obj\" ); // Compute vertex areas VertexData < double > vertArea ( * mesh , 0. ); geometry -> requireFaceAreas (); for ( Vertex v : mesh -> vertices ()) { for ( Face f : v . adjacentVertices ()) { vertArea [ v ] += geometry -> faceAreas [ f ] / f . degree (); } } For more, see the tutorials . To get started with the code, see building . What is geometry-central not? A user interface . Geometry-central does not include any facilities for user interaction; it is an algorithms and data structures library on which you might build user-facing tools. This philosphy keeps the library lightweight, and avoids dependencies on rendering and windowing systems. For a UI that interoperates well with geometry-central, see Polyscope . A research code dump . Geometry-central was built by researchers, and is used to prototype research projects. However, we strive to ensure that this library contains only polished & tested, broadly useful algorithms. Related alternatives: CGAL , libIGL , OpenMesh , Polygon Mesh Processing Library , CinoLib Credits Geometry-central is developed primarily by Nicholas Sharp , with contributions from Keenan Crane , Yousuf Soliman , Mark Gillespie , Rohan Sawhney , and many others. If geometry-central contributes to an academic publication, cite it as: @misc { geometrycentral , title = {geometry-central} , author = {Nicholas Sharp and Keenan Crane and others} , note = {www.geometry-central.net} , year = {2019} } Development of this software was funded in part by NSF Award 1717320, an NSF graduate research fellowship, and gifts from Adobe Research and Autodesk, Inc.","title":"Home"},{"location":"#welcome-to-geometry-central","text":"Geometry-central is a modern C++ library of data structures and algorithms for geometry processing, with a particular focus on surface meshes. Features include: A polished halfedge mesh class, with efficient support for mesh modification, and a system of containers for associating data with mesh elements. Implementations of canonical geometric quantities on surfaces, ranging from normals and curvatures to tangent vector bases to operators from discrete differential geometry. A suite of powerful algorithms , including computing distances on surface, generating direction fields, and manipulating intrinsic Delaunay triangulations. A coherent set of sparse linear algebra tools , based on Eigen and augmented to automatically utilize better solvers if available on your system. Under construction As of July 30, 2019, geometry-central and its documentation are still under active development. You are welcome and encouraged to start using the library, but some components are still being built and modified. Sample: // Load a mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( \"spot.obj\" ); // Compute vertex areas VertexData < double > vertArea ( * mesh , 0. ); geometry -> requireFaceAreas (); for ( Vertex v : mesh -> vertices ()) { for ( Face f : v . adjacentVertices ()) { vertArea [ v ] += geometry -> faceAreas [ f ] / f . degree (); } } For more, see the tutorials . To get started with the code, see building . What is geometry-central not? A user interface . Geometry-central does not include any facilities for user interaction; it is an algorithms and data structures library on which you might build user-facing tools. This philosphy keeps the library lightweight, and avoids dependencies on rendering and windowing systems. For a UI that interoperates well with geometry-central, see Polyscope . A research code dump . Geometry-central was built by researchers, and is used to prototype research projects. However, we strive to ensure that this library contains only polished & tested, broadly useful algorithms. Related alternatives: CGAL , libIGL , OpenMesh , Polygon Mesh Processing Library , CinoLib Credits Geometry-central is developed primarily by Nicholas Sharp , with contributions from Keenan Crane , Yousuf Soliman , Mark Gillespie , Rohan Sawhney , and many others. If geometry-central contributes to an academic publication, cite it as: @misc { geometrycentral , title = {geometry-central} , author = {Nicholas Sharp and Keenan Crane and others} , note = {www.geometry-central.net} , year = {2019} } Development of this software was funded in part by NSF Award 1717320, an NSF graduate research fellowship, and gifts from Adobe Research and Autodesk, Inc.","title":"Welcome to Geometry Central"},{"location":"build/building/","text":"Building geometry-central uses CMake for to configure the build system. The basic workflow for downloading and compiling geometry-central via a terminal is: git clone --recurse-submodules https://github.com/nmwsharp/geometry-central.git cd geometry-central mkdir build && cd build cmake -DCMAKE_BUILD_TYPE = Release .. make -j4 However, since geometry-central is just a library, this does not build any executables, it merely compiles the library. You can add geometry-central to an existing project\u2019s CMakeLists . txt like add_subdirectory ( \"path/to/geometry-central\" ) # wherever you put it target_link_libraries ( your-project-target geometry-central ) Example For a simple example project using geometry-central (with Polyscope for visualization), see gc-polyscope-project-template . This is a good starting point for new projects using geometry-central. On Windows When using Visual Studio on Windows, CMake can be used (either via the terminal or gui) to generate Visual Studio project and solution files. The project has been verified to compile out of the box with Visual Studio 2017 & 2019 (older versions not tested).","title":"Building"},{"location":"build/building/#building","text":"geometry-central uses CMake for to configure the build system. The basic workflow for downloading and compiling geometry-central via a terminal is: git clone --recurse-submodules https://github.com/nmwsharp/geometry-central.git cd geometry-central mkdir build && cd build cmake -DCMAKE_BUILD_TYPE = Release .. make -j4 However, since geometry-central is just a library, this does not build any executables, it merely compiles the library. You can add geometry-central to an existing project\u2019s CMakeLists . txt like add_subdirectory ( \"path/to/geometry-central\" ) # wherever you put it target_link_libraries ( your-project-target geometry-central )","title":"Building"},{"location":"build/building/#example","text":"For a simple example project using geometry-central (with Polyscope for visualization), see gc-polyscope-project-template . This is a good starting point for new projects using geometry-central.","title":"Example"},{"location":"build/building/#on-windows","text":"When using Visual Studio on Windows, CMake can be used (either via the terminal or gui) to generate Visual Studio project and solution files. The project has been verified to compile out of the box with Visual Studio 2017 & 2019 (older versions not tested).","title":"On Windows"},{"location":"build/dependencies/","text":"Dependencies geometry-central manages its dependenices via a mix of git submodules, configure-time downloading, and system libraries. However, the build system is explicitly set up such that cloning and building should immediately work on any vaguely reasonable machine, without chasing down dependencies. Remember, clone with: git clone --recurse-submodules https://github.com/nmwsharp/geometry-central.git to ensure you resolve git submodules. If you cloned without submodules, you can get them afterwards with: git submodule update --init --recursive Eigen Eigen is used for linear algebra within geometry-central. Eigen presents a bit of a special challenge as a dependency because many programmers already have Eigen in the project or system, and intermingling multiple copies of Eigen can be problematic. As such, the build system uses the following strategies in order to resolve Eigen: Using Eigen in any directory passed via the GC_EIGEN_LOCATION CMake variable (empty by default) Using Eigen from your system libraries, as resolved via find_package ( Eigen3 3 . 3 ) Downloading a copy of Eigen in to the deps / downloads / directory For instance, if your project already has a copy of Eigen in its source tree, you can use with (1) by setting GC_EIGEN_LOCATION . If not, many programmers have installed Eigen, which will be found in (2). Finally, as a last resort the build system will download a copy of Eigen as in (3). geometry-central is known to work with version 3.3 of Eigen; other versions have not been tested (but recent versions probably work). Note: once upon a time, Eigen was a submodule of geometry-central. If updating from an old version, you may need to manually delete deps / eigen - git - mirror . Suitesparse geometry-central\u2019s linear solvers will automatically use Suitesparse routines under the hood if detected at configure time. The output of the CMake script will indicate whether or not suitesparse was found. At any time, setting the SUITESPARSE CMake variable to false will stop the build system from using Suitesparse, even if it is availble. Installing suitesparse is up to the user. If using homebrew on OSX, brew install suitesparse should be sufficient. On Ubuntu, try apt - get install libsuitesparse - dev . Suitesparse is notoriously difficult to install on Windows\u2014if you find a good method, let us know!","title":"Dependencies"},{"location":"build/dependencies/#dependencies","text":"geometry-central manages its dependenices via a mix of git submodules, configure-time downloading, and system libraries. However, the build system is explicitly set up such that cloning and building should immediately work on any vaguely reasonable machine, without chasing down dependencies. Remember, clone with: git clone --recurse-submodules https://github.com/nmwsharp/geometry-central.git to ensure you resolve git submodules. If you cloned without submodules, you can get them afterwards with: git submodule update --init --recursive","title":"Dependencies"},{"location":"build/dependencies/#eigen","text":"Eigen is used for linear algebra within geometry-central. Eigen presents a bit of a special challenge as a dependency because many programmers already have Eigen in the project or system, and intermingling multiple copies of Eigen can be problematic. As such, the build system uses the following strategies in order to resolve Eigen: Using Eigen in any directory passed via the GC_EIGEN_LOCATION CMake variable (empty by default) Using Eigen from your system libraries, as resolved via find_package ( Eigen3 3 . 3 ) Downloading a copy of Eigen in to the deps / downloads / directory For instance, if your project already has a copy of Eigen in its source tree, you can use with (1) by setting GC_EIGEN_LOCATION . If not, many programmers have installed Eigen, which will be found in (2). Finally, as a last resort the build system will download a copy of Eigen as in (3). geometry-central is known to work with version 3.3 of Eigen; other versions have not been tested (but recent versions probably work). Note: once upon a time, Eigen was a submodule of geometry-central. If updating from an old version, you may need to manually delete deps / eigen - git - mirror .","title":"Eigen"},{"location":"build/dependencies/#suitesparse","text":"geometry-central\u2019s linear solvers will automatically use Suitesparse routines under the hood if detected at configure time. The output of the CMake script will indicate whether or not suitesparse was found. At any time, setting the SUITESPARSE CMake variable to false will stop the build system from using Suitesparse, even if it is availble. Installing suitesparse is up to the user. If using homebrew on OSX, brew install suitesparse should be sufficient. On Ubuntu, try apt - get install libsuitesparse - dev . Suitesparse is notoriously difficult to install on Windows\u2014if you find a good method, let us know!","title":"Suitesparse"},{"location":"build/tests/","text":"Building and running tests Compile and run the tests with: cd test mkdir build && cd build cmake -DCMAKE_BUILD_TYPE = Debug .. make -j12 && ./bin/geometry-central-test Tests organization All tests are stored in the test / subdirectory, which is not touched by the usual build system. googletest We use googletest as a testing framework. Most users do not need the tests, so rather than packing it as a git submodule which would unavoidably be cloned, the build system downloads a binary of the googletest when the tests are built\u2014a consequence is that you must have a network connection to build tests for the first time (TODO: enable using a system install of googletest). Assets The tests / assets / directory contains a handful of input files for various tests. The absolute paths to these files are baked in to the test executable by the build system, so moving this directory after compiling tests may cause problems. The disk footprint of assets should be kept as small as possible since they are stored in the library repository.","title":"Tests"},{"location":"build/tests/#building-and-running-tests","text":"Compile and run the tests with: cd test mkdir build && cd build cmake -DCMAKE_BUILD_TYPE = Debug .. make -j12 && ./bin/geometry-central-test","title":"Building and running tests"},{"location":"build/tests/#tests-organization","text":"All tests are stored in the test / subdirectory, which is not touched by the usual build system.","title":"Tests organization"},{"location":"build/tests/#googletest","text":"We use googletest as a testing framework. Most users do not need the tests, so rather than packing it as a git submodule which would unavoidably be cloned, the build system downloads a binary of the googletest when the tests are built\u2014a consequence is that you must have a network connection to build tests for the first time (TODO: enable using a system install of googletest).","title":"googletest"},{"location":"build/tests/#assets","text":"The tests / assets / directory contains a handful of input files for various tests. The absolute paths to these files are baked in to the test executable by the build system, so moving this directory after compiling tests may cause problems. The disk footprint of assets should be kept as small as possible since they are stored in the library repository.","title":"Assets"},{"location":"numerical/linear_algebra_utilities/","text":"Linear algebra utilities Construct and convert SparseMatrix < T > identityMatrix ( size_t N ) Construct and N x N identity matrix of the requested type. void shiftDiagonal ( SparseMatrix < T >& m , T shiftAmount = 1e-4 ) Shift the diagonal of matrix, by adding A + shiftDiagonal * identityMatrix () . SparseMatrix < T > verticalStack ( const std :: vector < SparseMatrix < T >>& mats ) Vertically stack sparse matrices like A,B,C \\to \\begin{bmatrix} A \\\\ B \\\\ C \\end{bmatrix} A,B,C \\to \\begin{bmatrix} A \\\\ B \\\\ C \\end{bmatrix} all matrices must have the same number of columns. Example: SparseMatrix < double > matA = /* 35 x N */ SparseMatrix < double > matB = /* 10 x N */ SparseMatrix < double > matC = /* 2 x N */ SparseMatrix < double > stacked = verticalStack < double > ({ matA , matB , matC }); SparseMatrix < T > horizontalStack ( const std :: vector < SparseMatrix < T >>& mats ) Vertically stack sparse matrices like A,B,C \\to \\begin{bmatrix} A & B & C \\end{bmatrix} A,B,C \\to \\begin{bmatrix} A & B & C \\end{bmatrix} all matrices must have the same number of rows.. Example: SparseMatrix < double > matA = /* N x 35 */ SparseMatrix < double > matB = /* N x 10 */ SparseMatrix < double > matC = /* N x 2 */ SparseMatrix < double > stacked = horizontalStack < double > ({ matA , matB , matC }); SparseMatrix < double > complexToReal ( const SparseMatrix < std :: complex < double >>& m ) Convert an N x M complex matrix to a 2 N x 2 M real matrix, expanding each complex component in to a 2 x 2 block to evaluate the complex product. Vector < double > complexToReal ( const Vector < std :: complex < double >>& v ) Convert an length N complex vector to a length 2 N real vector, expanding each complex component in to consecutive real and imaginary components. Validate matrix properties void checkFinite ( const Eigen :: Matrix <>& m ) Verify that all entries in an matrix are finite, throwing if not. Defined for all Eigen matrix, vector, and sparse matrix types. void checkSymmetric ( const Eigen :: SparseMatrix <>& m , double absoluteEPS =- 1. ) Verify that a matrix is symmetric, throwing if not. Defined for all Eigen sparse matrix types. absoluteEPS is an epsilon to use for the element-wise comparison test. If the default value of - 1 is given, a reasonable epsilon is automatically computed from the matrix entries. void checkHermitian ( const Eigen :: SparseMatrix <>& m , double absoluteEPS =- 1. ) Verify that a matrix is Hermitian, throwing if not. Defined for all Eigen sparse matrix types. For real matrices, identical to check symmetric. absoluteEPS is an epsilon to use for the element-wise comparison test. If the default value of - 1 is given, a reasonable epsilon is automatically computed from the matrix entries. Block decomposition These routines assist with decomposing a square matrix in to interleaved submatrix blocks, where the blocks might not necessarily be contiguous. One common usage is extracting boundary components of a finite element matrix to apply boundary conditions, as in the example below. Example usage: // Hypothetical input data SparseMatrix < double > mat = /* your square matrix */ ; size_t N = mat . rows (); size_t NBoundary = /* ... */ ; Vector < double > rhsVals = Vector < double >:: Zero ( N ); // rhs for the system Vector < double > bcVals = Vector < double >:: Ones ( NBoundary ); // boundary values at // some nodes // Build the membership vector, which indicates which entries should be separated // in to set \"A\" (others are in \"B\") Vector < bool > setAMembership ( N ); for ( size_t i = 0 ; i < N ; i ++ ) { if ( /* element i is boundary */ ) { setAMembership ( i ) = true ; } else { setAMembership ( i ) = false ; } } // Construct the decomposition BlockDecompositionResult < double > decomp = blockDecomposeSquare ( mat , setAMembership , true ); // The four sub-blocks of the matrix are now in // decomp.AA, decomp.AB, decomp.BA, decomp.BB // Split up the rhs vector Vector < double > rhsValsA , rhsValsB ; decomposeVector ( decomp , rhsVals , rhsValsA , rhsValsB ); // Solve problem Vector < double > combinedRHS = rhsValsA - decomp . AB * bcVals ; Vector < double > Aresult = solve ( decomp . AA , combinedRHS ); // Combine the two boundary conditions and interior solution to a full vector Vector < double > result = reassembleVector ( decomp , Aresult , bcVals ); BlockDecompositionResult < T > blockDecomposeSquare ( const SparseMatrix < T >& m , const Vector < bool >& Aset , bool buildBuildBside = true ) Build a block decomposition of a matrix. void decomposeVector ( BlockDecompositionResult < T >& decomp , const Vector < T >& vec , Vector < T >& vecAOut , Vector < T >& vecBOut ) Use an existing block decomposition to partition a vector. Vector < T > reassembleVector ( BlockDecompositionResult < T >& decomp , const Vector < T >& vecA , const Vector < T >& vecB ) Use an existing block decomposition to build a vector from partitioned pieces.","title":"Linear Algebra Utilities"},{"location":"numerical/linear_algebra_utilities/#linear-algebra-utilities","text":"","title":"Linear algebra utilities"},{"location":"numerical/linear_algebra_utilities/#construct-and-convert","text":"SparseMatrix < T > identityMatrix ( size_t N ) Construct and N x N identity matrix of the requested type. void shiftDiagonal ( SparseMatrix < T >& m , T shiftAmount = 1e-4 ) Shift the diagonal of matrix, by adding A + shiftDiagonal * identityMatrix () . SparseMatrix < T > verticalStack ( const std :: vector < SparseMatrix < T >>& mats ) Vertically stack sparse matrices like A,B,C \\to \\begin{bmatrix} A \\\\ B \\\\ C \\end{bmatrix} A,B,C \\to \\begin{bmatrix} A \\\\ B \\\\ C \\end{bmatrix} all matrices must have the same number of columns. Example: SparseMatrix < double > matA = /* 35 x N */ SparseMatrix < double > matB = /* 10 x N */ SparseMatrix < double > matC = /* 2 x N */ SparseMatrix < double > stacked = verticalStack < double > ({ matA , matB , matC }); SparseMatrix < T > horizontalStack ( const std :: vector < SparseMatrix < T >>& mats ) Vertically stack sparse matrices like A,B,C \\to \\begin{bmatrix} A & B & C \\end{bmatrix} A,B,C \\to \\begin{bmatrix} A & B & C \\end{bmatrix} all matrices must have the same number of rows.. Example: SparseMatrix < double > matA = /* N x 35 */ SparseMatrix < double > matB = /* N x 10 */ SparseMatrix < double > matC = /* N x 2 */ SparseMatrix < double > stacked = horizontalStack < double > ({ matA , matB , matC }); SparseMatrix < double > complexToReal ( const SparseMatrix < std :: complex < double >>& m ) Convert an N x M complex matrix to a 2 N x 2 M real matrix, expanding each complex component in to a 2 x 2 block to evaluate the complex product. Vector < double > complexToReal ( const Vector < std :: complex < double >>& v ) Convert an length N complex vector to a length 2 N real vector, expanding each complex component in to consecutive real and imaginary components.","title":"Construct and convert"},{"location":"numerical/linear_algebra_utilities/#validate-matrix-properties","text":"void checkFinite ( const Eigen :: Matrix <>& m ) Verify that all entries in an matrix are finite, throwing if not. Defined for all Eigen matrix, vector, and sparse matrix types. void checkSymmetric ( const Eigen :: SparseMatrix <>& m , double absoluteEPS =- 1. ) Verify that a matrix is symmetric, throwing if not. Defined for all Eigen sparse matrix types. absoluteEPS is an epsilon to use for the element-wise comparison test. If the default value of - 1 is given, a reasonable epsilon is automatically computed from the matrix entries. void checkHermitian ( const Eigen :: SparseMatrix <>& m , double absoluteEPS =- 1. ) Verify that a matrix is Hermitian, throwing if not. Defined for all Eigen sparse matrix types. For real matrices, identical to check symmetric. absoluteEPS is an epsilon to use for the element-wise comparison test. If the default value of - 1 is given, a reasonable epsilon is automatically computed from the matrix entries.","title":"Validate matrix properties"},{"location":"numerical/linear_algebra_utilities/#block-decomposition","text":"These routines assist with decomposing a square matrix in to interleaved submatrix blocks, where the blocks might not necessarily be contiguous. One common usage is extracting boundary components of a finite element matrix to apply boundary conditions, as in the example below. Example usage: // Hypothetical input data SparseMatrix < double > mat = /* your square matrix */ ; size_t N = mat . rows (); size_t NBoundary = /* ... */ ; Vector < double > rhsVals = Vector < double >:: Zero ( N ); // rhs for the system Vector < double > bcVals = Vector < double >:: Ones ( NBoundary ); // boundary values at // some nodes // Build the membership vector, which indicates which entries should be separated // in to set \"A\" (others are in \"B\") Vector < bool > setAMembership ( N ); for ( size_t i = 0 ; i < N ; i ++ ) { if ( /* element i is boundary */ ) { setAMembership ( i ) = true ; } else { setAMembership ( i ) = false ; } } // Construct the decomposition BlockDecompositionResult < double > decomp = blockDecomposeSquare ( mat , setAMembership , true ); // The four sub-blocks of the matrix are now in // decomp.AA, decomp.AB, decomp.BA, decomp.BB // Split up the rhs vector Vector < double > rhsValsA , rhsValsB ; decomposeVector ( decomp , rhsVals , rhsValsA , rhsValsB ); // Solve problem Vector < double > combinedRHS = rhsValsA - decomp . AB * bcVals ; Vector < double > Aresult = solve ( decomp . AA , combinedRHS ); // Combine the two boundary conditions and interior solution to a full vector Vector < double > result = reassembleVector ( decomp , Aresult , bcVals ); BlockDecompositionResult < T > blockDecomposeSquare ( const SparseMatrix < T >& m , const Vector < bool >& Aset , bool buildBuildBside = true ) Build a block decomposition of a matrix. void decomposeVector ( BlockDecompositionResult < T >& decomp , const Vector < T >& vec , Vector < T >& vecAOut , Vector < T >& vecBOut ) Use an existing block decomposition to partition a vector. Vector < T > reassembleVector ( BlockDecompositionResult < T >& decomp , const Vector < T >& vecA , const Vector < T >& vecB ) Use an existing block decomposition to build a vector from partitioned pieces.","title":"Block decomposition"},{"location":"numerical/linear_solvers/","text":"This section covers the solvers available in geometry central for sparse linear algebra problems. All solvers support real and complex matrices, and can be templated on a float , double , or std :: complex < double > . #include \"geometrycentral/numerical/linear_solvers.h\" Direct solvers These solvers provide a simple interface for solving sparse linear Ax = b Ax = b . A key feature is that these solvers abstract over the underlying numerical library. In their most basic form, Eigen\u2019s sparse solvers will be used, and are always available. However, if present, the more-powerful Suitesprase solvers will be used intead. See the dependencies section for instruction to build with Suitesparse support. As always, be sure to compile with optimizations for meaningful performance. In particular, Eigen\u2019s built-in solvers will be very slow in debug mode (though the Eigen QR solver is always slow). Quick solves These are one-off routines for quick solves. Vector < T > solve ( SparseMatrix < T >& matrix , const Vector < T >& rhs ) Solve a system with a general matrix. Uses a QR decomposition interally. Warning: The Eigen built-in sparse QR solver is very inefficient for many problems. Also, it doesn\u2019t work well for underdetermined systems. Vector < T > solveSquare ( SparseMatrix < T >& matrix , const Vector < T >& rhs ) Solve a system with a square matrix. Uses an LU decomposition interally. Vector < T > solvePositiveDefinite ( SparseMatrix < T >& matrix , const Vector < T >& rhs ) Solve a system with a symmetric positive (semi-)definite matrix. Uses an LDLT decomposition interally. Retain factorizations When solving many linear systems Ax=b Ax=b with the same matrix A A but different b b , it is dramatically more efficient to retain and reuse the factorization of A A . The following solver classes are stateful, storing the factorization to be re-used for may solves. SparseMatrix < double > A = /* ... some matrix ... */ ; // Build the solver Solver < double > solver ( A ); // Solve a problem Vector < double > rhs1 = /* ... */ ; Vector < double > sol = solver . solve ( rhs1 ); // Solve another problem Vector < double > rhs2 = /* ... */ ; Vector < double > sol2 = solver . solve ( rhs2 ); // Can place solution in existing vector Vector < double > rhs3 = /* ... */ ; solver . solve ( sol , rhs3 ); // Some solvers have extra powers. // Solver<> can compute matrix rank, since it uses QR under the hood. std :: cout << \"matrix rank is \" << solver . rank () << std :: endl ; template < typename < T >> class Solver Solve a system with a general matrix. Uses a QR decomposition interally. Supports methods: Sovler :: Solver ( SparseMatrix < T >& mat ) construct from a matrix Vector < T > Sovler :: solve ( const Vector < T >& rhs ) solve and return result in new vector void Sovler :: solve ( Vector < T >& result , const Vector < T >& rhs ) solve and place result in existing vector size_t Sovler :: rank () report the rank of the matrix. Some solvers may give only an approximate rank. Warning: The Eigen built-in sparse QR solver is very inefficient for many problems. Also, it doesn\u2019t work well for underdetermined systems. template < typename < T >> class SquareSolver Solve a system with a square matrix. Uses an LU decomposition interally. Supports methods: SquareSovler :: Solver ( SparseMatrix < T >& mat ) construct from a matrix Vector < T > SquareSovler :: solve ( const Vector < T >& rhs ) solve and return result in new vector void SquareSovler :: solve ( Vector < T >& result , const Vector < T >& rhs ) solve and place result in existing vector template < typename < T >> class PositiveDefiniteSolver Supports methods: PositiveDefiniteSolver :: Solver ( SparseMatrix < T >& mat ) construct from a matrix Vector < T > PositiveDefiniteSolver :: solve ( const Vector < T >& rhs ) solve and return result in new vector void PositiveDefiniteSolver :: solve ( Vector < T >& result , const Vector < T >& rhs ) solve and place result in existing vector Solve a system with a symmetric positive (semi-)definite matrix. Uses an LDLT decomposition interally. Eigenproblem solvers These routines build on top of the direct solvers to solve eigenvalue problems using power methods. Vector < T > smallestEigenvectorPositiveDefinite ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the smallest-eigenvalue\u2019d nontrivial eigenvector x x of a positive definite sparse matrix A A . std :: vector < Vector < T >> smallestKEigenvectorsPositiveDefinite ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t kEigenvalues , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the first k k smallest-eigenvalue\u2019d nontrivial eigenvectors x x of a positive definite sparse matrix A A . Vector < T > smallestEigenvectorSquare ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the smallest-eigenvalue\u2019d nontrivial eigenvector x x of a square matrix A A . Vector < T > largestEigenvector ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the largest-eigenvalue\u2019d nontrivial eigenvector x x of a square matrix A A . Utilities double residual ( const SparseMatrix < T >& matrix , const Vector < T >& lhs , const Vector < T >& rhs ) Measure the L2 residual of a linear system as ||Ax - b||_2 ||Ax - b||_2 .","title":"Linear Solvers"},{"location":"numerical/linear_solvers/#direct-solvers","text":"These solvers provide a simple interface for solving sparse linear Ax = b Ax = b . A key feature is that these solvers abstract over the underlying numerical library. In their most basic form, Eigen\u2019s sparse solvers will be used, and are always available. However, if present, the more-powerful Suitesprase solvers will be used intead. See the dependencies section for instruction to build with Suitesparse support. As always, be sure to compile with optimizations for meaningful performance. In particular, Eigen\u2019s built-in solvers will be very slow in debug mode (though the Eigen QR solver is always slow).","title":"Direct solvers"},{"location":"numerical/linear_solvers/#quick-solves","text":"These are one-off routines for quick solves. Vector < T > solve ( SparseMatrix < T >& matrix , const Vector < T >& rhs ) Solve a system with a general matrix. Uses a QR decomposition interally. Warning: The Eigen built-in sparse QR solver is very inefficient for many problems. Also, it doesn\u2019t work well for underdetermined systems. Vector < T > solveSquare ( SparseMatrix < T >& matrix , const Vector < T >& rhs ) Solve a system with a square matrix. Uses an LU decomposition interally. Vector < T > solvePositiveDefinite ( SparseMatrix < T >& matrix , const Vector < T >& rhs ) Solve a system with a symmetric positive (semi-)definite matrix. Uses an LDLT decomposition interally.","title":"Quick solves"},{"location":"numerical/linear_solvers/#retain-factorizations","text":"When solving many linear systems Ax=b Ax=b with the same matrix A A but different b b , it is dramatically more efficient to retain and reuse the factorization of A A . The following solver classes are stateful, storing the factorization to be re-used for may solves. SparseMatrix < double > A = /* ... some matrix ... */ ; // Build the solver Solver < double > solver ( A ); // Solve a problem Vector < double > rhs1 = /* ... */ ; Vector < double > sol = solver . solve ( rhs1 ); // Solve another problem Vector < double > rhs2 = /* ... */ ; Vector < double > sol2 = solver . solve ( rhs2 ); // Can place solution in existing vector Vector < double > rhs3 = /* ... */ ; solver . solve ( sol , rhs3 ); // Some solvers have extra powers. // Solver<> can compute matrix rank, since it uses QR under the hood. std :: cout << \"matrix rank is \" << solver . rank () << std :: endl ; template < typename < T >> class Solver Solve a system with a general matrix. Uses a QR decomposition interally. Supports methods: Sovler :: Solver ( SparseMatrix < T >& mat ) construct from a matrix Vector < T > Sovler :: solve ( const Vector < T >& rhs ) solve and return result in new vector void Sovler :: solve ( Vector < T >& result , const Vector < T >& rhs ) solve and place result in existing vector size_t Sovler :: rank () report the rank of the matrix. Some solvers may give only an approximate rank. Warning: The Eigen built-in sparse QR solver is very inefficient for many problems. Also, it doesn\u2019t work well for underdetermined systems. template < typename < T >> class SquareSolver Solve a system with a square matrix. Uses an LU decomposition interally. Supports methods: SquareSovler :: Solver ( SparseMatrix < T >& mat ) construct from a matrix Vector < T > SquareSovler :: solve ( const Vector < T >& rhs ) solve and return result in new vector void SquareSovler :: solve ( Vector < T >& result , const Vector < T >& rhs ) solve and place result in existing vector template < typename < T >> class PositiveDefiniteSolver Supports methods: PositiveDefiniteSolver :: Solver ( SparseMatrix < T >& mat ) construct from a matrix Vector < T > PositiveDefiniteSolver :: solve ( const Vector < T >& rhs ) solve and return result in new vector void PositiveDefiniteSolver :: solve ( Vector < T >& result , const Vector < T >& rhs ) solve and place result in existing vector Solve a system with a symmetric positive (semi-)definite matrix. Uses an LDLT decomposition interally.","title":"Retain factorizations"},{"location":"numerical/linear_solvers/#eigenproblem-solvers","text":"These routines build on top of the direct solvers to solve eigenvalue problems using power methods. Vector < T > smallestEigenvectorPositiveDefinite ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the smallest-eigenvalue\u2019d nontrivial eigenvector x x of a positive definite sparse matrix A A . std :: vector < Vector < T >> smallestKEigenvectorsPositiveDefinite ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t kEigenvalues , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the first k k smallest-eigenvalue\u2019d nontrivial eigenvectors x x of a positive definite sparse matrix A A . Vector < T > smallestEigenvectorSquare ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the smallest-eigenvalue\u2019d nontrivial eigenvector x x of a square matrix A A . Vector < T > largestEigenvector ( SparseMatrix < T >& energyMatrix , SparseMatrix < T >& massMatrix , size_t nIterations = 50 ) Solves the eigenvector problem A x = \\lambda M x A x = \\lambda M x for the largest-eigenvalue\u2019d nontrivial eigenvector x x of a square matrix A A .","title":"Eigenproblem solvers"},{"location":"numerical/linear_solvers/#utilities","text":"double residual ( const SparseMatrix < T >& matrix , const Vector < T >& lhs , const Vector < T >& rhs ) Measure the L2 residual of a linear system as ||Ax - b||_2 ||Ax - b||_2 .","title":"Utilities"},{"location":"numerical/matrix_types/","text":"Eigen Generally, geometry central uses Eigen for all matrix types. Though we build additional solvers and utilities on top of Eigen. See the Eigen section of dependencies for instructions about getting Eigen and integrating with existing build systems. Note that the Vector2 and Vector3 low-dimensional scalar types are entirely separate from these high-dimensional linear algebra types; Vector2 and Vector3 do not use Eigen, and they cannot participate in arithmetic expressions with Eigen types. Two typedefs are used extensively throughout geometry central to make the default Eigen types slightly less verbose. Both are defined in linear_algebra_utilities . h . #include \"geometrycentral/numerical/linear_algebra_utilities.h\" Vector < T > A templated vector typedef, to Eigen\u2019s vector type. template < typename T > using Vector = Eigen :: Matrix < T , Eigen :: Dynamic , 1 > ; Use like Vector < double > or Vector < bool > . SparseMatrix < T > A templated sparse matrix typedef, to Eigen\u2019s sparse matrix type. template < typename T > using SparseMatrix = Eigen :: SparseMatrix < T > ; Use like SparseMatrix < double > or SparseMatrix < int > . Gotchas Be wary, Eigen\u2019s alignment rules make it efficient, but also impose requirements which can lead to hard-to-debug memory errors. A few particularly common pitfalls are: Avoid intermingling different versions of Eigen in the same program. Suppose some part of you codebase uses one version of Eigen, and a dependency uses a different version. Linking a function which returns an Eigen vector between these versions can lead to segfaults, because different alignment policies were used. Similar to the previous, linking Eigen programs compiled with different preprocessor directives and optimization flags can yield binary incompatibility. Be sure that all parts of your codebase using Eigen receive the same build options. Fixed-sized Eigen types (like Eigen :: Vector4d , but not our Vector < T > or SparseMatrix < T > ) may not be passed by value to functions. The same applies transitively to classes which have Eigen types as members. See this (opinionated) note .","title":"Matrix Types"},{"location":"numerical/matrix_types/#eigen","text":"Generally, geometry central uses Eigen for all matrix types. Though we build additional solvers and utilities on top of Eigen. See the Eigen section of dependencies for instructions about getting Eigen and integrating with existing build systems. Note that the Vector2 and Vector3 low-dimensional scalar types are entirely separate from these high-dimensional linear algebra types; Vector2 and Vector3 do not use Eigen, and they cannot participate in arithmetic expressions with Eigen types. Two typedefs are used extensively throughout geometry central to make the default Eigen types slightly less verbose. Both are defined in linear_algebra_utilities . h . #include \"geometrycentral/numerical/linear_algebra_utilities.h\" Vector < T > A templated vector typedef, to Eigen\u2019s vector type. template < typename T > using Vector = Eigen :: Matrix < T , Eigen :: Dynamic , 1 > ; Use like Vector < double > or Vector < bool > . SparseMatrix < T > A templated sparse matrix typedef, to Eigen\u2019s sparse matrix type. template < typename T > using SparseMatrix = Eigen :: SparseMatrix < T > ; Use like SparseMatrix < double > or SparseMatrix < int > .","title":"Eigen"},{"location":"numerical/matrix_types/#gotchas","text":"Be wary, Eigen\u2019s alignment rules make it efficient, but also impose requirements which can lead to hard-to-debug memory errors. A few particularly common pitfalls are: Avoid intermingling different versions of Eigen in the same program. Suppose some part of you codebase uses one version of Eigen, and a dependency uses a different version. Linking a function which returns an Eigen vector between these versions can lead to segfaults, because different alignment policies were used. Similar to the previous, linking Eigen programs compiled with different preprocessor directives and optimization flags can yield binary incompatibility. Be sure that all parts of your codebase using Eigen receive the same build options. Fixed-sized Eigen types (like Eigen :: Vector4d , but not our Vector < T > or SparseMatrix < T > ) may not be passed by value to functions. The same applies transitively to classes which have Eigen types as members. See this (opinionated) note .","title":"Gotchas"},{"location":"surface/algorithms/direction_fields/","text":"","title":"Direction Fields"},{"location":"surface/algorithms/geodesic_distance/","text":"This section describes algorithms for computing distance along a surface, or geodesic distance. Note that distance depends on the intrinsic geometry of a surface (via the IntrinsicGeometryInterface ). Therefore, these routines can be run on abstract geometric domains as well as traditional surfaces in 3D. Polyhedral Distance TODO document Heat Method for Distance These routines implement the Heat Method for Geodesic Distance . This algorithm uses short time heat flow to compute distance on surfaces. Because the main burden is simply solving linear systems of equations, it tends to be faster than polyhedral schemes, especially when computing distance multiple times on the same surface. In the computational geometry sense, this method is an approximation, as the result is not precisely equal to the polyhedral distance on the surface; nonetheless it is fast and well-suited for many applications. # include \" geometrycentral/surface/heat_method_distance.h \" Single Solves A one-off utility function is provided which computes the distance from a source vertex using the heat method. Repeated solves or more general source data should use the stateful version below. Example #include \"geometrycentral/surface/heat_method_distance.h\" #include \"geometrycentral/surface/meshio.h\" // Load a mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Pick a vertex Vertex sourceVert = /* some vertex */ // Compute distance VertexData < double > distToSource = heatMethodDistance ( * geometry , sourceVert ); /* do something useful */ VertexData < double > heatMethodDistance ( IntrinsicGeometryInterface & geom , Vertex v ) Compute the distance from the source using the heat method. Repeated Solves The stateful class HeatMethodDistanceSolver does precomputation when constructed, then allows many distance solves from different source locations to be performed efficiently. The computeDistance () method in HeatMethodDistanceSolver can also take SurfacePoint (s) as the source location(s). A SurfacePoint (see here ) is a location on a surface, which may be a vertex, a point along an edge, or a point inside a face. Example: #include \"geometrycentral/surface/heat_method_distance.h\" #include \"geometrycentral/surface/meshio.h\" // Load a mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Create the Heat Method solver HeatMethodDistanceSolver heatSolver ( geometry ); // Some vertices as source set std :: vector < Vertex > sourceVerts = /* some interesting vertices */ for ( Vertex v : sourceVerts ) { VertexData < double > distToSource = heatSolver . computeDistance ( v ); /* do something useful */ } // A point in a face as a source set Face sourceF = /* some face */ ; Vector3 sourceFBary = /* some barycentric coords in face */ ; SurfacePoint targetP ( sourceF , sourceFBary ); VertexData < double > distToSource = heatSolver . computeDistance ( targetP ); /* do something useful */ HeatMethodDistanceSolver :: HeatMethodDistanceSolver ( IntrinsicGeometryInterface & geom , double tCoef = 1.0 ) Create a new solver to compute geodesic distance using the heat method. All precomputation work is performed immediately at construction time. geom is the geometry (and hence mesh) on which to compute. Note that nearly any geometry object ( VertexPositionGeometry , etc) can be passed here. tCoef is the time to use for short time heat flow, as a factor m * h ^ 2 , where h is the mean edge length. The default value of 1 . 0 is almost always sufficient. Algorithm options (like tCoef ) cannot be changed after construction; create a new solver object with the new settings. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( Vertex v ) Compute the distance from a single source vertex. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( std :: vector < Vertex > verts ) Compute the distance from a set of source vertices. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( SurfacePoint p ) Compute the distance from a single source point. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( std :: vector < SurfacePoint > points ) Compute the distance from a set of source points.","title":"Geodesic Distance"},{"location":"surface/algorithms/geodesic_distance/#polyhedral-distance","text":"TODO document","title":"Polyhedral Distance"},{"location":"surface/algorithms/geodesic_distance/#heat-method-for-distance","text":"These routines implement the Heat Method for Geodesic Distance . This algorithm uses short time heat flow to compute distance on surfaces. Because the main burden is simply solving linear systems of equations, it tends to be faster than polyhedral schemes, especially when computing distance multiple times on the same surface. In the computational geometry sense, this method is an approximation, as the result is not precisely equal to the polyhedral distance on the surface; nonetheless it is fast and well-suited for many applications. # include \" geometrycentral/surface/heat_method_distance.h \"","title":"Heat Method for Distance"},{"location":"surface/algorithms/geodesic_distance/#single-solves","text":"A one-off utility function is provided which computes the distance from a source vertex using the heat method. Repeated solves or more general source data should use the stateful version below. Example #include \"geometrycentral/surface/heat_method_distance.h\" #include \"geometrycentral/surface/meshio.h\" // Load a mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Pick a vertex Vertex sourceVert = /* some vertex */ // Compute distance VertexData < double > distToSource = heatMethodDistance ( * geometry , sourceVert ); /* do something useful */ VertexData < double > heatMethodDistance ( IntrinsicGeometryInterface & geom , Vertex v ) Compute the distance from the source using the heat method.","title":"Single Solves"},{"location":"surface/algorithms/geodesic_distance/#repeated-solves","text":"The stateful class HeatMethodDistanceSolver does precomputation when constructed, then allows many distance solves from different source locations to be performed efficiently. The computeDistance () method in HeatMethodDistanceSolver can also take SurfacePoint (s) as the source location(s). A SurfacePoint (see here ) is a location on a surface, which may be a vertex, a point along an edge, or a point inside a face. Example: #include \"geometrycentral/surface/heat_method_distance.h\" #include \"geometrycentral/surface/meshio.h\" // Load a mesh std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( filename ); // Create the Heat Method solver HeatMethodDistanceSolver heatSolver ( geometry ); // Some vertices as source set std :: vector < Vertex > sourceVerts = /* some interesting vertices */ for ( Vertex v : sourceVerts ) { VertexData < double > distToSource = heatSolver . computeDistance ( v ); /* do something useful */ } // A point in a face as a source set Face sourceF = /* some face */ ; Vector3 sourceFBary = /* some barycentric coords in face */ ; SurfacePoint targetP ( sourceF , sourceFBary ); VertexData < double > distToSource = heatSolver . computeDistance ( targetP ); /* do something useful */ HeatMethodDistanceSolver :: HeatMethodDistanceSolver ( IntrinsicGeometryInterface & geom , double tCoef = 1.0 ) Create a new solver to compute geodesic distance using the heat method. All precomputation work is performed immediately at construction time. geom is the geometry (and hence mesh) on which to compute. Note that nearly any geometry object ( VertexPositionGeometry , etc) can be passed here. tCoef is the time to use for short time heat flow, as a factor m * h ^ 2 , where h is the mean edge length. The default value of 1 . 0 is almost always sufficient. Algorithm options (like tCoef ) cannot be changed after construction; create a new solver object with the new settings. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( Vertex v ) Compute the distance from a single source vertex. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( std :: vector < Vertex > verts ) Compute the distance from a set of source vertices. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( SurfacePoint p ) Compute the distance from a single source point. VertexData < double > HeatMethodDistanceSolver :: computeDistance ( std :: vector < SurfacePoint > points ) Compute the distance from a set of source points.","title":"Repeated Solves"},{"location":"surface/algorithms/mesh_graph_algorithms/","text":"","title":"Mesh Graph Algorithms"},{"location":"surface/algorithms/surface_centers/","text":"These routines compute geometric centers of point sets and distrubtions on surfaces. A \u201ccenter\u201d c c is a point on the surface which is a local minimum of the energy: $$ c = \\underset{m}{\\textrm{argmin}}\\sum_{y \\in \\mathcal{Y}} d(m,y)^p $$ where \\mathcal{Y} \\mathcal{Y} is a set of sites to take the average of and d(\\cdot, \\cdot) d(\\cdot, \\cdot) denotes the geodesic distance. Centers on surfaces with p=2 p=2 (\u201cmeans\u201d) are known as Karcher Means or Frechet Means . Centers on surfaces with p=1 p=1 (\u201cmedians\u201d) are known as geometric medians . Centers are not unique! In general, there will not be a single unqiue \u201ccenter\u201d of a point set or distribution on a surface. For nearby sites there may be a single center, but in general this may not be the case. The routines in this section use random initialization to report a center . As such, the results may be different under repeated runs of the procedure. # include \" geometrycentral/surface/surface_centers.h \" Centers of points SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , const std :: vector < Vertex >& vertexPts , int p = 2 ) Find a center of a collection of points at vertices. p must be either 1 1 or 2 2 . SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , VectorHeatMethodSolver & solver , const std :: vector < Vertex >& vertexPts , int p = 2 ) Like the above method, but uses an existing solver object, which saves precomputation. Centers of distributions SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , const VertexData < double >& distribution , int p = 2 ) Find a center of a distribution at vertices. Note that the input distribution is treated as integrated values at vertices. If your distribution is \u201cper-unit-area\u201d, you should multiply times vertex area before passing it in. p must be either 1 1 or 2 2 . SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , VectorHeatMethodSolver & solver , const VertexData < double >& distribution , int p = 2 ) Like the above method, but uses an existing solver object, which saves precomputation. Citation These algorithms are described in The Vector Heat Method , the appropriate citation is: @article { sharp2019vector , title = {The Vector Heat Method} , author = {Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan} , journal = {ACM Transactions on Graphics (TOG)} , volume = {38} , number = {3} , pages = {24} , year = {2019} , publisher = {ACM} }","title":"Surface Centers"},{"location":"surface/algorithms/surface_centers/#centers-of-points","text":"SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , const std :: vector < Vertex >& vertexPts , int p = 2 ) Find a center of a collection of points at vertices. p must be either 1 1 or 2 2 . SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , VectorHeatMethodSolver & solver , const std :: vector < Vertex >& vertexPts , int p = 2 ) Like the above method, but uses an existing solver object, which saves precomputation.","title":"Centers of points"},{"location":"surface/algorithms/surface_centers/#centers-of-distributions","text":"SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , const VertexData < double >& distribution , int p = 2 ) Find a center of a distribution at vertices. Note that the input distribution is treated as integrated values at vertices. If your distribution is \u201cper-unit-area\u201d, you should multiply times vertex area before passing it in. p must be either 1 1 or 2 2 . SurfacePoint findCenter ( IntrinsicGeometryInterface & geom , VectorHeatMethodSolver & solver , const VertexData < double >& distribution , int p = 2 ) Like the above method, but uses an existing solver object, which saves precomputation.","title":"Centers of distributions"},{"location":"surface/algorithms/surface_centers/#citation","text":"These algorithms are described in The Vector Heat Method , the appropriate citation is: @article { sharp2019vector , title = {The Vector Heat Method} , author = {Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan} , journal = {ACM Transactions on Graphics (TOG)} , volume = {38} , number = {3} , pages = {24} , year = {2019} , publisher = {ACM} }","title":"Citation"},{"location":"surface/algorithms/vector_heat_method/","text":"This section describes the Vector Heat Method in geometry-central, which computes parallel transport of vectors using heat flow, and applications that follow from it. Note that these quantities all depend on the intrinsic geometry of a surface (via the IntrinsicGeometryInterface ). Therefore, these routines can be run on abstract geometric domains as well as traditional surfaces in 3D. These algorithms are described in The Vector Heat Method . # include \" geometrycentral/surface/vector_heat_method.h \" Vector Heat Solver The stateful class VectorHeatSolver shares precomputation for all of the routines below. VectorHeatSolver :: VectorHeatSolver ( IntrinsicGeometryInterface & geom , double tCoef = 1.0 ) Create a new solver for the Vector Heat Method. Precomputation is perfrmed lazily as needed. geom is the geometry (and hence mesh) on which to compute. Note that nearly any geometry object ( VertexPositionGeometry , etc) can be passed here. tCoef is the time to use for short time heat flow, as a factor m * h ^ 2 , where h is the mean edge length. The default value of 1 . 0 is almost always sufficient. Algorithm options (like tCoef ) cannot be changed after construction; create a new solver object with the new settings. Scalar Extension Given scalar data defined at isolated source locations on a surface, extend it to the entire domain. Each point on the domain will take the value of the nearest source point. Example: // your mesh and geometry VertexPositionGeometry geometry ; HalfedgeMesh mesh ; // construct a solver VectorHeatSolver vhmSolver ( geometry ); // some interesting source values std :: vector < std :: tuple < Vertex , double >> points ; for ( /* ... some inputs ... */ ) { Vertex sourceVert = /* something */ ; double sourceVal = /* something */ ; points . emplace_back ( sourceVert , sourceVal ); } // solve! VertexData < double > scalarExtension = vhmSolver -> extendScalar ( points ); VertexData < double > VectorHeatSolver :: extendScalar ( const std :: vector < std :: tuple < Vertex , double >>& sources ) Compute the nearest-neighbor extension of scalar data defined at isolated vertices to the entire domain. The input is a list of vertices and their corresponding values. VertexData < double > VectorHeatSolver :: extendScalar ( const std :: vector < std :: tuple < SurfacePoint , double >>& sources ) Compute the nearest-neighbor extension of scalar data defined at isolated points to the entire domain. The input is a list of surface points and their corresponding values. Vector Extension Given tangent vectors defined at one or more isolated source locations on a surface, extend transport the vectors across the entire domain according to parallel transport. Each point on the domain will take the value of the nearest source point. VertexData < Vector2 > VectorHeatSolver :: transportTangentVectors ( Vertex sourceVert , Vector2 sourceVec ) Compute the parallel transport of a vector defined at a single vertex to the entire domain. The input is defined in the tangent space of the source vertex. VertexData < Vector2 > VectorHeatSolver :: transportTangentVectors ( const std :: vector < std :: tuple < Vertex , Vector2 >>& sources ) Compute the parallel transport of vectors defined at a collection of vertices to the entire domain. The input is defined in the tangent space of each the source vertex. VertexData < Vector2 > VectorHeatSolver :: transportTangentVectors ( const std :: vector < std :: tuple < SurfacePoint , Vector2 >>& sources ) Compute the parallel transport of vectors defined at a collection of surface points to the entire domain. The input is defined in the tangent space of each the vertex, face, or edge respectively. Logarithmic Map The logarithmic map is a very special 2D local parameterization of a surface about a point, where for each point on the surface the magnitude of the log map gives the geodesic distance from the source, and the polar coordinate of the log map gives the direction at which a geodesic must leave the source to arrive at the point. These routines compute the logarithmic map using the vector heat method. VertexData < Vector2 > VectorHeatSolver :: computeLogMap ( const Vertex & sourceVert ) Compute the logarithmic map with respect to the given source vertex. The angular coordinate of the log map will be respect to the tangent space of the source vertex. VertexData < Vector2 > VectorHeatSolver :: computeLogMap ( const SurfacePoint & sourceP ) Compute the logarithmic map with respect to the given source point, which is a general surface point . The angular coordinate of the log map will be respect to the tangent space of the source vertex, edge, or face. Citation If these algorithms contribute to academic work, please cite the following paper: @article { sharp2019vector , title = {The Vector Heat Method} , author = {Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan} , journal = {ACM Transactions on Graphics (TOG)} , volume = {38} , number = {3} , pages = {24} , year = {2019} , publisher = {ACM} }","title":"Vector Heat Method"},{"location":"surface/algorithms/vector_heat_method/#vector-heat-solver","text":"The stateful class VectorHeatSolver shares precomputation for all of the routines below. VectorHeatSolver :: VectorHeatSolver ( IntrinsicGeometryInterface & geom , double tCoef = 1.0 ) Create a new solver for the Vector Heat Method. Precomputation is perfrmed lazily as needed. geom is the geometry (and hence mesh) on which to compute. Note that nearly any geometry object ( VertexPositionGeometry , etc) can be passed here. tCoef is the time to use for short time heat flow, as a factor m * h ^ 2 , where h is the mean edge length. The default value of 1 . 0 is almost always sufficient. Algorithm options (like tCoef ) cannot be changed after construction; create a new solver object with the new settings.","title":"Vector Heat Solver"},{"location":"surface/algorithms/vector_heat_method/#scalar-extension","text":"Given scalar data defined at isolated source locations on a surface, extend it to the entire domain. Each point on the domain will take the value of the nearest source point. Example: // your mesh and geometry VertexPositionGeometry geometry ; HalfedgeMesh mesh ; // construct a solver VectorHeatSolver vhmSolver ( geometry ); // some interesting source values std :: vector < std :: tuple < Vertex , double >> points ; for ( /* ... some inputs ... */ ) { Vertex sourceVert = /* something */ ; double sourceVal = /* something */ ; points . emplace_back ( sourceVert , sourceVal ); } // solve! VertexData < double > scalarExtension = vhmSolver -> extendScalar ( points ); VertexData < double > VectorHeatSolver :: extendScalar ( const std :: vector < std :: tuple < Vertex , double >>& sources ) Compute the nearest-neighbor extension of scalar data defined at isolated vertices to the entire domain. The input is a list of vertices and their corresponding values. VertexData < double > VectorHeatSolver :: extendScalar ( const std :: vector < std :: tuple < SurfacePoint , double >>& sources ) Compute the nearest-neighbor extension of scalar data defined at isolated points to the entire domain. The input is a list of surface points and their corresponding values.","title":"Scalar Extension"},{"location":"surface/algorithms/vector_heat_method/#vector-extension","text":"Given tangent vectors defined at one or more isolated source locations on a surface, extend transport the vectors across the entire domain according to parallel transport. Each point on the domain will take the value of the nearest source point. VertexData < Vector2 > VectorHeatSolver :: transportTangentVectors ( Vertex sourceVert , Vector2 sourceVec ) Compute the parallel transport of a vector defined at a single vertex to the entire domain. The input is defined in the tangent space of the source vertex. VertexData < Vector2 > VectorHeatSolver :: transportTangentVectors ( const std :: vector < std :: tuple < Vertex , Vector2 >>& sources ) Compute the parallel transport of vectors defined at a collection of vertices to the entire domain. The input is defined in the tangent space of each the source vertex. VertexData < Vector2 > VectorHeatSolver :: transportTangentVectors ( const std :: vector < std :: tuple < SurfacePoint , Vector2 >>& sources ) Compute the parallel transport of vectors defined at a collection of surface points to the entire domain. The input is defined in the tangent space of each the vertex, face, or edge respectively.","title":"Vector Extension"},{"location":"surface/algorithms/vector_heat_method/#logarithmic-map","text":"The logarithmic map is a very special 2D local parameterization of a surface about a point, where for each point on the surface the magnitude of the log map gives the geodesic distance from the source, and the polar coordinate of the log map gives the direction at which a geodesic must leave the source to arrive at the point. These routines compute the logarithmic map using the vector heat method. VertexData < Vector2 > VectorHeatSolver :: computeLogMap ( const Vertex & sourceVert ) Compute the logarithmic map with respect to the given source vertex. The angular coordinate of the log map will be respect to the tangent space of the source vertex. VertexData < Vector2 > VectorHeatSolver :: computeLogMap ( const SurfacePoint & sourceP ) Compute the logarithmic map with respect to the given source point, which is a general surface point . The angular coordinate of the log map will be respect to the tangent space of the source vertex, edge, or face.","title":"Logarithmic Map"},{"location":"surface/algorithms/vector_heat_method/#citation","text":"If these algorithms contribute to academic work, please cite the following paper: @article { sharp2019vector , title = {The Vector Heat Method} , author = {Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan} , journal = {ACM Transactions on Graphics (TOG)} , volume = {38} , number = {3} , pages = {24} , year = {2019} , publisher = {ACM} }","title":"Citation"},{"location":"surface/geometry/geometry/","text":"While the halfedge mesh encodes the connectivity of a surface, this section covers the classes which sit atop a halfedge mesh to define its geometry . The first section below explains the class structure used to expose geometric logic, and the second section explains the system of automatically-cached quantities. Geometry hierarchy TL;DR Construct a VertexPositionGeometry object using vertex positions; it offers all the geometric routines you would expect, and can be passed to any method that demands geometry. Many algorithms can actually operate on weaker data than vertex positions. Read on to learn more. Geometry central is intentionally designed to allow flexibility in defining the geometry of a surface. Traditional code might assume a 3D position for every vertex, but many algorithms actually need only the intrinsic geometry of a surface, aka the edge lengths. More generally, specifying algorithms to only use the geometric data they really need allows us to seamlessly leverage powerful techniques. We (sparingly) make use of polymorphism via inheritance in C++ to encode a hierarchy of geometric quantities that one might compute for a surface. Interfaces define which quantities can be computed from the geometry; for instance, an EmbeddedGeometryInterface can compute face normals, and it can also compute face areas because it extends the more basic IntrinsicGeometryInterface . Interfaces are abstract, and cannot be instantiated by themselves. Realizations are concrete classes that allow the user instantiate a geometry object from data; for instance, a VertexPositionGeometry can be constructed from vertex positions, and implements the EmbeddedGeometryInterface giving access to a wide range of intrinsic and extrinsic geometric quantities. The following diagram outlines the interfaces and realizations currently available. Quantity management Immediate computation In the most basic usage, realizations can compute simple quantities for a given element directly from input data. For instance, double VertexPositionGeometry :: faceArea ( Face f ) will compute the area of a face. However, this is not the typical intended method for working with geometric quantities in geometry central. Managed quantities A common pattern in geometry code is to maintain precomputed arrays of values that are used repeatedly (e.g. vertex normals). However, naive use of this pattern requires the programmer to coordinate these arrays throughout their codebase, or risk computing and storing the same array many times in distant subroutines. Geometry central embraces this pattern, and provides automatic support for proper use of it. All geometry objects automatically maintain of system of caches for geometric quantities; the user can simply call (for instance) geometry . requireFaceAreas () at the beginning of a subroutine to ensure that the face area buffer is populated, then access geometry . faceAreas [ f ] in any subsequent code. This strategy keep storage and computation to a minimum by sharing repeated values across any use of the geometry object. The following example demonstrates immediate computation vs cached quantities. VertexPositionGeometry & geometry = /* ... */ ; // bad: immediate computation everywhere for ( Face f : mesh -> faces ()) { Vector3 normal = geometry . faceNormal ( f ); } // good: automatic caching and storage geometry . requireFaceNormals (); for ( Face f : mesh -> faces ()) { Vector3 normal = geometry . faceNormals [ f ]; } In fact, the inheritance in this design allows geometry central to leverage alternate ways of computing a quantity depending on the underlying data available. For instance, face areas are computed for an EdgeLengthGeometry using Heron\u2019s rule, but for a VertexPositionGeometry a faster and more stable edge cross-product is used. Of course, this is all happening under the hood\u2013 the user just needs to call myGeometry . requireFaceAreas () . Dependencies In addition, dependencies between these quantities are managed internally; for instance, if vertex normals are requested, face normals will be internally populated and used to compute vertex normals. However, these dependencies are internal and subject to change; the programmer should always explicitly call geometry . requireFaceNormals () if they intend to access face normals. Updating If the underlying geometric data changes (e.g., vertices are moved or the mesh is mutated), invoking geometry . refreshQuantities () will recompute all required values. Minimizing storage usage To minimize memory usage, invoke geometry . unrequireFaceNormals () at the conclusion of a subroutine to indicate that the quantity is no longer needed, decrementing an internal counter. The quantity is not instantly deleted after being un-required, but invoking geometry . purgeQuantities () will delete any quantities that are not currently required, reducing memory usage. Most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object. Quantity API # include \" geometrycentral/surface/geometry.h \" to get all geometry interfaces. All quantities offer methods and storage following the same naming pattern. For a quantity named YYYs (e.g. faceAreas ), which is defined in an interface GeometryInterface (e.g. IntrinsicGeometry ) the pattern is given below. An exauhstive list is given in quantities . MeshData <> GeometryInterface :: YYYs The member variable array for quantity YYY. Initially empty, but can be populated with requireYYYs () below. For instance, for the quantity face areas, there is a member FaceData < double > IntrinsicGeometry :: faceAreas . void GeometryInterface :: requireYYYs () Request that the buffer for quantity YYYs be populated. If it is already populated the method will return right away, otherwise the quantity will be computed. For instance, for the quantity face areas, one would call IntrinsicGeometry :: requireFaceAreas () . void GeometryInterface :: unrequireYYYs () Indicate that the buffer for quantity YYYs no longer needs to be populated. Internally decrements a counter; once there is a unrequireYYYs () for every requireYYYs () call, the quantity can be purged by GeometryInterface :: purgeQuantities () . For instance, for the quantity face areas, one would call IntrinsicGeometry :: unrequireFaceAreas () . Note: most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object. This functionality can be used only if reducing memory usage is very important. T GeometryRealization :: computeYYY ( Element e ) Immediate computation: rather than using the caching system described above, directly compute the value from the input data. Only available for quantities which can be easily computed in O(1) from inputs (e.g. face normals), but not for quantities with significant dependencies (e.g. vertex normals, which depend on all incident face normals). For instance, face areas can be immediately computed with double VertexPositionGeometry :: faceArea ( Face f ) . Note: immediate computation is generally discouraged, prefer using managed quantities instead. In addition, the caching system provides two methods. void GeometryInterface :: refreshQuantities () Recompute all required quantities from the input geometric data. Should be called, for instance if vertices are moved or the underlying mesh is mutated. void GeometryInterface :: purgeQuantities () Delete all cached quantities which are not currently require () \u2018d, reducing memory usage. Note: most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object. This functionality can be used only if reducing memory usage is very important. Interfaces Interfaces are abstract classes which define which quantities are available for a given geometry, and compute/manage caches of these quantities. For the full list of the managed quantities that can be computed by these interfaces, see the quantities section . Base Geometry Base Geometry This is a simple base class which is serves as a parent of all geometry interfaces. It does not actually correspond to any geometric data, and the only quantities it manages are convenience element indices. #include \"geometrycentral/surface/base_geometry_interface.h\" blah? Intrinsic Geometry Intrinsic Geometry Extends BaseGeometryInterface . These quantites depend only on the notion of lengths and angles on the surface, but not how it might sit in space. #include \"geometrycentral/surface/intrinsic_geometry_interface.h\" An intrinsic geometry can be instantiated via any of the realizations which inherit from it: EdgeLengthGeometry VertexPositionGeometry (additionally inherits from the child EmbeddedGeometryInterface ) Extrinsic Geometry Extrinsic Geometry Extends IntrinsicTangentGeometry . These quantites depend on extrinsic angles (like dihedral angles at edges), but are rotation-invariant. #include \"geometrycentral/surface/extrinsic_geometry_interface.h\" An extrinsic geometry can be instantiated via any of the realizations which inherit from it: VertexPositionGeometry (additionally inherits from the child EmbeddedGeometryInterface ) Note that there is not currently any realization which instantiates an ExtrinsicGeometryInterface which is not also an EmbeddedGeometryInterface , but such a realization might one day exist. Embedded Geometry Embedded Geometry Extends ExtrinsicTangentGeometry . These quantites depend explicitly on how the surface sits in 3D space. #include \"geometrycentral/surface/embedded_geometry_interface.h\" An embedded geometry can be instantiated via any of the realizations which inherit from it: VertexPositionGeometry Realizations Realizations construct a geometry object from input data. There are two widely used realizations in geometry central: VertexPositionGeometry and EdgeLengthGeometry . Other realizations of geometry can arise in various contexts, such as the IntrinsicTangentGeometry , which includes both edge lengths and a choice of tangent spaces. In addition to the quantities listed in their own section , the realizations each offer a few immediate computations and some utility functions. Vertex Position Geometry The usual notion of geometry for a mesh, with a position in 3D for each vertex. These positions are stored in the member VertexPositionGeometry :: inputVertexPositions . This class inherits from all of the geometry interfaces mentioned above, so all quantities will be available. #include \"geometrycentral/surface/vertex_position_geometry.h\" void VertexPositionGeometry :: VertexPositionGeometry ( VertexData < Vector3 > positions ) Construct a new geometry from vertex positions. The positions input is copied, and stored in the member VertexPositionGeometry :: inputVertexPositions . void VertexPositionGeometry :: VertexPositionGeometry ( HalfedgeMesh & mesh ) Construct a new geometry for the mesh, with all positions set to the origin Vector3 { 0 ., 0 ., 0 ., } . void VertexPositionGeometry :: VertexPositionGeometry ( HalfedgeMesh & mesh , VertexData < Vector3 > positions ) Construct a new geometry for a mesh from known vertex positions. The positions input is copied, and stored in the member VertexPositionGeometry :: inputVertexPositions . std :: unique_ptr < VertexPositionGeometry > VertexPositionGeometry :: copy () Copy the geometry, creating a new identical geometry on the same mesh. Any require () counts or already-computed quantities are not transferred, the new geometry is a blank slate. std :: unique_ptr < VertexPositionGeometry > VertexPositionGeometry :: reinterpretTo ( HalfedgeMesh & targetMesh ) Copy the geometry, creating a new identical geometry on targetMesh . The target mesh must be in vertex-correspondence with the input mesh, in the sense that both meshes have the same number of vertices and iterating through the vertex sets yields matching vertices. Any require () counts or already-computed quantities are not transferred, the new geometry is a blank slate. Immediate computations . These routines directly compute geometry quantities from the input data, without touching the caching system. For the full list of available managed quantities, see the quantities section . double VertexPositionGeometry :: edgeLength ( Edge e ) Compute the length of a single edge. double VertexPositionGeometry :: faceArea ( Face f ) Compute the area of a single face. double VertexPositionGeometry :: cornerAngle ( Corner c ) Compute the angle (in radians) formed by the two edges incident on a corner. double VertexPositionGeometry :: halfedgeCotanWeight ( Halfedge he ) Compute the cotangent weight of a hafedge. double VertexPositionGeometry :: edgeCotanWeight ( Edge e ) Compute the cotangent weight of an edge. Vector3 VertexPositionGeometry :: faceNormal ( Face f ) Compute the normal of a face. Edge Length Geometry A weaker notion of geometry where one knows only edge lengths. This data turns out to be sufficient to implement many algorithms in geometry processing, and offers valuable flexibility in defining the geometry. This class inherits from the IntrinsicGeometryInterface , so only intrinsic quantities will be available. #include \"geometrycentral/surface/edge_length_geometry.h\" void EdgeLengthGeometry :: EdgeLengthGeometry ( HalfedgeMesh & mesh , EdgeData < double > edgeLengths ) Construct a new geometry for a mesh from known edge lengths. The edgeLengths input is copied, and stored in the member EdgeLengthGeometry :: inputEdgeLengths . std :: unique_ptr < EdgeLengthGeometry > EdgeLengthGeometry :: copy () Copy the geometry, creating a new identical geometry on the same mesh. Any require () counts or already-computed quantities are not transferred, the new geometry is a blank slate. std :: unique_ptr < EdgeLengthGeometry > reinterpretTo ( HalfedgeMesh & targetMesh ) Copy the geometry, creating a new identical geometry on targetMesh . The target mesh must be in edge-correspondence with the input mesh, in the sense that both meshes have the same number of edges and iterating through the edge sets yields matching edges. Any require () counts or already-computed quantities are not transferred, the new geometry is a blank slate. Immediate computations . These routines directly compute geometry quantities from the input data, without touching the caching system. For the full list of available managed quantities, see the quantities section . double EdgeLengthGeometry :: faceArea ( Face f ) Compute the area of a single face. double EdgeLengthGeometry :: cornerAngle ( Corner c ) Compute the angle (in radians) formed by the two edges incident on a corner. double EdgeLengthGeometry :: halfedgeCotanWeight ( Halfedge he ) Compute the cotangent weight of a hafedge. double EdgeLengthGeometry :: edgeCotanWeight ( Edge e ) Compute the cotangent weight of an edge.","title":"Overview"},{"location":"surface/geometry/geometry/#geometry-hierarchy","text":"TL;DR Construct a VertexPositionGeometry object using vertex positions; it offers all the geometric routines you would expect, and can be passed to any method that demands geometry. Many algorithms can actually operate on weaker data than vertex positions. Read on to learn more. Geometry central is intentionally designed to allow flexibility in defining the geometry of a surface. Traditional code might assume a 3D position for every vertex, but many algorithms actually need only the intrinsic geometry of a surface, aka the edge lengths. More generally, specifying algorithms to only use the geometric data they really need allows us to seamlessly leverage powerful techniques. We (sparingly) make use of polymorphism via inheritance in C++ to encode a hierarchy of geometric quantities that one might compute for a surface. Interfaces define which quantities can be computed from the geometry; for instance, an EmbeddedGeometryInterface can compute face normals, and it can also compute face areas because it extends the more basic IntrinsicGeometryInterface . Interfaces are abstract, and cannot be instantiated by themselves. Realizations are concrete classes that allow the user instantiate a geometry object from data; for instance, a VertexPositionGeometry can be constructed from vertex positions, and implements the EmbeddedGeometryInterface giving access to a wide range of intrinsic and extrinsic geometric quantities. The following diagram outlines the interfaces and realizations currently available.","title":"Geometry hierarchy"},{"location":"surface/geometry/geometry/#quantity-management","text":"","title":"Quantity management"},{"location":"surface/geometry/geometry/#immediate-computation","text":"In the most basic usage, realizations can compute simple quantities for a given element directly from input data. For instance, double VertexPositionGeometry :: faceArea ( Face f ) will compute the area of a face. However, this is not the typical intended method for working with geometric quantities in geometry central.","title":"Immediate computation"},{"location":"surface/geometry/geometry/#managed-quantities","text":"A common pattern in geometry code is to maintain precomputed arrays of values that are used repeatedly (e.g. vertex normals). However, naive use of this pattern requires the programmer to coordinate these arrays throughout their codebase, or risk computing and storing the same array many times in distant subroutines. Geometry central embraces this pattern, and provides automatic support for proper use of it. All geometry objects automatically maintain of system of caches for geometric quantities; the user can simply call (for instance) geometry . requireFaceAreas () at the beginning of a subroutine to ensure that the face area buffer is populated, then access geometry . faceAreas [ f ] in any subsequent code. This strategy keep storage and computation to a minimum by sharing repeated values across any use of the geometry object. The following example demonstrates immediate computation vs cached quantities. VertexPositionGeometry & geometry = /* ... */ ; // bad: immediate computation everywhere for ( Face f : mesh -> faces ()) { Vector3 normal = geometry . faceNormal ( f ); } // good: automatic caching and storage geometry . requireFaceNormals (); for ( Face f : mesh -> faces ()) { Vector3 normal = geometry . faceNormals [ f ]; } In fact, the inheritance in this design allows geometry central to leverage alternate ways of computing a quantity depending on the underlying data available. For instance, face areas are computed for an EdgeLengthGeometry using Heron\u2019s rule, but for a VertexPositionGeometry a faster and more stable edge cross-product is used. Of course, this is all happening under the hood\u2013 the user just needs to call myGeometry . requireFaceAreas () .","title":"Managed quantities"},{"location":"surface/geometry/geometry/#dependencies","text":"In addition, dependencies between these quantities are managed internally; for instance, if vertex normals are requested, face normals will be internally populated and used to compute vertex normals. However, these dependencies are internal and subject to change; the programmer should always explicitly call geometry . requireFaceNormals () if they intend to access face normals.","title":"Dependencies"},{"location":"surface/geometry/geometry/#updating","text":"If the underlying geometric data changes (e.g., vertices are moved or the mesh is mutated), invoking geometry . refreshQuantities () will recompute all required values.","title":"Updating"},{"location":"surface/geometry/geometry/#minimizing-storage-usage","text":"To minimize memory usage, invoke geometry . unrequireFaceNormals () at the conclusion of a subroutine to indicate that the quantity is no longer needed, decrementing an internal counter. The quantity is not instantly deleted after being un-required, but invoking geometry . purgeQuantities () will delete any quantities that are not currently required, reducing memory usage. Most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object.","title":"Minimizing storage usage"},{"location":"surface/geometry/geometry/#quantity-api","text":"# include \" geometrycentral/surface/geometry.h \" to get all geometry interfaces. All quantities offer methods and storage following the same naming pattern. For a quantity named YYYs (e.g. faceAreas ), which is defined in an interface GeometryInterface (e.g. IntrinsicGeometry ) the pattern is given below. An exauhstive list is given in quantities . MeshData <> GeometryInterface :: YYYs The member variable array for quantity YYY. Initially empty, but can be populated with requireYYYs () below. For instance, for the quantity face areas, there is a member FaceData < double > IntrinsicGeometry :: faceAreas . void GeometryInterface :: requireYYYs () Request that the buffer for quantity YYYs be populated. If it is already populated the method will return right away, otherwise the quantity will be computed. For instance, for the quantity face areas, one would call IntrinsicGeometry :: requireFaceAreas () . void GeometryInterface :: unrequireYYYs () Indicate that the buffer for quantity YYYs no longer needs to be populated. Internally decrements a counter; once there is a unrequireYYYs () for every requireYYYs () call, the quantity can be purged by GeometryInterface :: purgeQuantities () . For instance, for the quantity face areas, one would call IntrinsicGeometry :: unrequireFaceAreas () . Note: most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object. This functionality can be used only if reducing memory usage is very important. T GeometryRealization :: computeYYY ( Element e ) Immediate computation: rather than using the caching system described above, directly compute the value from the input data. Only available for quantities which can be easily computed in O(1) from inputs (e.g. face normals), but not for quantities with significant dependencies (e.g. vertex normals, which depend on all incident face normals). For instance, face areas can be immediately computed with double VertexPositionGeometry :: faceArea ( Face f ) . Note: immediate computation is generally discouraged, prefer using managed quantities instead. In addition, the caching system provides two methods. void GeometryInterface :: refreshQuantities () Recompute all required quantities from the input geometric data. Should be called, for instance if vertices are moved or the underlying mesh is mutated. void GeometryInterface :: purgeQuantities () Delete all cached quantities which are not currently require () \u2018d, reducing memory usage. Note: most users find that un-requiring and purging quantities is not necessary, and one can simply allow them to accumulate and eventually be deleted with the geometry object. This functionality can be used only if reducing memory usage is very important.","title":"Quantity API"},{"location":"surface/geometry/geometry/#interfaces","text":"Interfaces are abstract classes which define which quantities are available for a given geometry, and compute/manage caches of these quantities. For the full list of the managed quantities that can be computed by these interfaces, see the quantities section . Base Geometry","title":"Interfaces"},{"location":"surface/geometry/geometry/#base-geometry","text":"This is a simple base class which is serves as a parent of all geometry interfaces. It does not actually correspond to any geometric data, and the only quantities it manages are convenience element indices. #include \"geometrycentral/surface/base_geometry_interface.h\" blah? Intrinsic Geometry","title":"Base Geometry"},{"location":"surface/geometry/geometry/#intrinsic-geometry","text":"Extends BaseGeometryInterface . These quantites depend only on the notion of lengths and angles on the surface, but not how it might sit in space. #include \"geometrycentral/surface/intrinsic_geometry_interface.h\" An intrinsic geometry can be instantiated via any of the realizations which inherit from it: EdgeLengthGeometry VertexPositionGeometry (additionally inherits from the child EmbeddedGeometryInterface ) Extrinsic Geometry","title":"Intrinsic Geometry"},{"location":"surface/geometry/geometry/#extrinsic-geometry","text":"Extends IntrinsicTangentGeometry . These quantites depend on extrinsic angles (like dihedral angles at edges), but are rotation-invariant. #include \"geometrycentral/surface/extrinsic_geometry_interface.h\" An extrinsic geometry can be instantiated via any of the realizations which inherit from it: VertexPositionGeometry (additionally inherits from the child EmbeddedGeometryInterface ) Note that there is not currently any realization which instantiates an ExtrinsicGeometryInterface which is not also an EmbeddedGeometryInterface , but such a realization might one day exist. Embedded Geometry","title":"Extrinsic Geometry"},{"location":"surface/geometry/geometry/#embedded-geometry","text":"Extends ExtrinsicTangentGeometry . These quantites depend explicitly on how the surface sits in 3D space. #include \"geometrycentral/surface/embedded_geometry_interface.h\" An embedded geometry can be instantiated via any of the realizations which inherit from it: VertexPositionGeometry","title":"Embedded Geometry"},{"location":"surface/geometry/geometry/#realizations","text":"Realizations construct a geometry object from input data. There are two widely used realizations in geometry central: VertexPositionGeometry and EdgeLengthGeometry . Other realizations of geometry can arise in various contexts, such as the IntrinsicTangentGeometry , which includes both edge lengths and a choice of tangent spaces. In addition to the quantities listed in their own section , the realizations each offer a few immediate computations and some utility functions.","title":"Realizations"},{"location":"surface/geometry/geometry/#vertex-position-geometry","text":"The usual notion of geometry for a mesh, with a position in 3D for each vertex. These positions are stored in the member VertexPositionGeometry :: inputVertexPositions . This class inherits from all of the geometry interfaces mentioned above, so all quantities will be available. #include \"geometrycentral/surface/vertex_position_geometry.h\" void VertexPositionGeometry :: VertexPositionGeometry ( VertexData < Vector3 > positions ) Construct a new geometry from vertex positions. The positions input is copied, and stored in the member VertexPositionGeometry :: inputVertexPositions . void VertexPositionGeometry :: VertexPositionGeometry ( HalfedgeMesh & mesh ) Construct a new geometry for the mesh, with all positions set to the origin Vector3 { 0 ., 0 ., 0 ., } . void VertexPositionGeometry :: VertexPositionGeometry ( HalfedgeMesh & mesh , VertexData < Vector3 > positions ) Construct a new geometry for a mesh from known vertex positions. The positions input is copied, and stored in the member VertexPositionGeometry :: inputVertexPositions . std :: unique_ptr < VertexPositionGeometry > VertexPositionGeometry :: copy () Copy the geometry, creating a new identical geometry on the same mesh. Any require () counts or already-computed quantities are not transferred, the new geometry is a blank slate. std :: unique_ptr < VertexPositionGeometry > VertexPositionGeometry :: reinterpretTo ( HalfedgeMesh & targetMesh ) Copy the geometry, creating a new identical geometry on targetMesh . The target mesh must be in vertex-correspondence with the input mesh, in the sense that both meshes have the same number of vertices and iterating through the vertex sets yields matching vertices. Any require () counts or already-computed quantities are not transferred, the new geometry is a blank slate. Immediate computations . These routines directly compute geometry quantities from the input data, without touching the caching system. For the full list of available managed quantities, see the quantities section . double VertexPositionGeometry :: edgeLength ( Edge e ) Compute the length of a single edge. double VertexPositionGeometry :: faceArea ( Face f ) Compute the area of a single face. double VertexPositionGeometry :: cornerAngle ( Corner c ) Compute the angle (in radians) formed by the two edges incident on a corner. double VertexPositionGeometry :: halfedgeCotanWeight ( Halfedge he ) Compute the cotangent weight of a hafedge. double VertexPositionGeometry :: edgeCotanWeight ( Edge e ) Compute the cotangent weight of an edge. Vector3 VertexPositionGeometry :: faceNormal ( Face f ) Compute the normal of a face.","title":"Vertex Position Geometry"},{"location":"surface/geometry/geometry/#edge-length-geometry","text":"A weaker notion of geometry where one knows only edge lengths. This data turns out to be sufficient to implement many algorithms in geometry processing, and offers valuable flexibility in defining the geometry. This class inherits from the IntrinsicGeometryInterface , so only intrinsic quantities will be available. #include \"geometrycentral/surface/edge_length_geometry.h\" void EdgeLengthGeometry :: EdgeLengthGeometry ( HalfedgeMesh & mesh , EdgeData < double > edgeLengths ) Construct a new geometry for a mesh from known edge lengths. The edgeLengths input is copied, and stored in the member EdgeLengthGeometry :: inputEdgeLengths . std :: unique_ptr < EdgeLengthGeometry > EdgeLengthGeometry :: copy () Copy the geometry, creating a new identical geometry on the same mesh. Any require () counts or already-computed quantities are not transferred, the new geometry is a blank slate. std :: unique_ptr < EdgeLengthGeometry > reinterpretTo ( HalfedgeMesh & targetMesh ) Copy the geometry, creating a new identical geometry on targetMesh . The target mesh must be in edge-correspondence with the input mesh, in the sense that both meshes have the same number of edges and iterating through the edge sets yields matching edges. Any require () counts or already-computed quantities are not transferred, the new geometry is a blank slate. Immediate computations . These routines directly compute geometry quantities from the input data, without touching the caching system. For the full list of available managed quantities, see the quantities section . double EdgeLengthGeometry :: faceArea ( Face f ) Compute the area of a single face. double EdgeLengthGeometry :: cornerAngle ( Corner c ) Compute the angle (in radians) formed by the two edges incident on a corner. double EdgeLengthGeometry :: halfedgeCotanWeight ( Halfedge he ) Compute the cotangent weight of a hafedge. double EdgeLengthGeometry :: edgeCotanWeight ( Edge e ) Compute the cotangent weight of an edge.","title":"Edge Length Geometry"},{"location":"surface/geometry/quantities/","text":"This page enumerates the surface geometry quantities available in geometry central. Recall that these quantities are each associated with a geometry interface specifying what can be computed from the given input data. Instantiating a geometry from data, classes like VertexPositionGeometry extend these interfaces and give access to all of the quantities therein. Quantities should usually be accessed via the managed caches , as in the example below. #include \"geometrycentral/surface/geometry.h\" #include \"geometrycentral/surface/meshio.h\" using namespace geometrycentral :: surface ; // Load a mesh and geometry from file std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > positionGeometry ; std :: tie < mesh , positionGeometry > = loadMesh ( \"spot.obj\" ); // For the sake of the example, use an interface type that offers // only the quantities which we will actually use below. IntrinsicGeometryInterface & geometry = * positionGeometry ; // populate the quantity geometry . requireFaceAreas (); for ( Face f : mesh -> faces ()) { // Managed array holding quantity double area = geometry . faceAreas [ f ]; // Immediate computation, computes directly from // input data without touching caches. // Generally discouraged but occasionally useful. area = positionGeometry -> faceArea ( f ); } Indices These quantities are defined for the base BaseGeometryInterface , and will always be available. They are not actually geometric data, but it is convenient to cache the canonical arrays alongside geometric quantities, as they are often used in concert. vertex indices vertex indices A dense 0-based enumeration of vertices. Equivalent to the result of HalfedgeMesh :: getVertexIndices () . member: VertexData < size_t > BaseGeometryInterface :: vertexIndices require: void BaseGeometryInterface :: requireVertexIndices () halfedge indices halfedge indices A dense 0-based enumeration of halfedges. Equivalent to the result of HalfedgeMesh :: getHalfedgeIndices () . member: HalfedgeData < size_t > BaseGeometryInterface :: halfedgeIndices require: void BaseGeometryInterface :: requireHalfedgeIndices () corner indices corner indices A dense 0-based enumeration of corners. Equivalent to the result of HalfedgeMesh :: getCornerIndices () . member: CornerData < size_t > BaseGeometryInterface :: cornerIndices require: void BaseGeometryInterface :: requireCornerIndices () edge indices edge indices A dense 0-based enumeration of edges. Equivalent to the result of HalfedgeMesh :: getEdgeIndices () . member: EdgeData < size_t > BaseGeometryInterface :: edgeIndices require: void BaseGeometryInterface :: requireEdgeIndices () face indices face indices A dense 0-based enumeration of faces. Equivalent to the result of HalfedgeMesh :: getFaceIndices () . member: FaceData < size_t > BaseGeometryInterface :: faceIndices require: void BaseGeometryInterface :: requireFaceIndices () boundary loop indices boundary loop indices A dense 0-based enumeration of boundary loops . Equivalent to the result of HalfedgeMesh :: getBoundaryLoopIndices () . member: BoundaryLoopData < size_t > BaseGeometryInterface :: boundaryLoopIndices require: void BaseGeometryInterface :: requireBoundaryLoopIndices () Lengths, areas, and angles These quantities are defined for any IntrinsicGeometryInterface , which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. edge length edge length The length of an edge in the mesh, as a non-negative real number. member: EdgeData < double > IntrinsicGeometryInterface :: edgeLengths require: void IntrinsicGeometryInterface :: requireEdgeLengths () The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double VertexPositionGeometry :: edgeLength ( Edge e ) face area face area The area of a face, as a non-negative real number. May be computed from edge lengths via Heron\u2019s formula, or from embedded vertex positions with a cross product. Only valid on triangular meshes. member: FaceData < double > IntrinsicGeometryInterface :: faceAreas require: void IntrinsicGeometryInterface :: requireFaceAreas () The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry :: faceArea ( Face f ) immediate: double VertexPositionGeometry :: faceArea ( Face f ) vertex dual area vertex dual area An area associated with each vertex, as a non-negative real number. Only valid on triangular meshes. Defined to be 1/3 1/3 the sum of all adjacent face areas. The sum of all vertex dual areas is equal to the usual surface area of the mesh. member: VertexData < double > IntrinsicGeometryInterface :: vertexDualAreas require: void IntrinsicGeometryInterface :: requireVertexDualAreas () corner angles corner angles The angle between incident edges at each corner of a mesh. Only valid on triangular meshes. member: CornerData < double > IntrinsicGeometryInterface :: cornerAngles require: void IntrinsicGeometryInterface :: requireCornerAngles () The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry :: cornerAngle ( Corner c ) immediate: double VertexPositionGeometry :: cornerAngle ( Corner c ) vertex angle sum vertex angle sum The sum of corner angles around a vertex. Only valid on triangular meshes. member: VertexData < double > IntrinsicGeometryInterface :: vertexAngleSums require: void IntrinsicGeometryInterface :: requireVertexAngleSums () corner scaled angles corner scaled angles The angle between incident edges at each corner of a mesh, linearly rescaled such that the angles around every vertex sum to 2 \\pi 2 \\pi . At boundary vertices, no scaling will be performed. Only valid on triangular meshes. member: CornerData < double > IntrinsicGeometryInterface :: cornerScaledAngles require: void IntrinsicGeometryInterface :: requireCornerScaledAngles () vertex Gaussian curvature vertex Gaussian curvature The Gaussian curvature K K at a vertex, defined via the angle defect K_v = 2 \\pi - \\sum \\theta_i K_v = 2 \\pi - \\sum \\theta_i , where \\sum \\theta_i \\sum \\theta_i is the vertexAngleSum as above. Should be interpreted as an integrated Gaussian curvature, giving the total curvature in the neighborhood of the vertex. On a closed surface, the Gauss-Bonnet theorem tells us that the sum of these Gaussian curvatures will be a topological constant given by \\sum_v K_v = 2 \\pi \\chi \\sum_v K_v = 2 \\pi \\chi , where \\chi \\chi is the Euler characteristic of the surface. On surfaces with boundary, the geodesic curvature of the boundary factors in. Only valid on triangular meshes. member: VertexData < double > IntrinsicGeometryInterface :: vertexGaussianCurvatures require: void IntrinsicGeometryInterface :: requireVertexGaussianCurvatures () face Gaussian curvature face Gaussian curvature The Gaussian curvature K K at a face, defined via the rescaled angle defect in the face K_f = \\pi - \\sum \\tilde{\\theta}_i K_f = \\pi - \\sum \\tilde{\\theta}_i , where \\tilde{\\theta}_i \\tilde{\\theta}_i are the rescaled corner angles (as in cornerScaledAngles ) incident on the face. Should be interpreted as an integrated Gaussian curvature, giving the total curvature inside of the face. A corresponding curvature-per-unit-area can be computed by dividing by the area of the face. On a closed surface, the Gauss-Bonnet theorem tells us that the sum of these Gaussian curvatures will be a topological constant given by \\sum_f K_f = 2 \\pi \\chi \\sum_f K_f = 2 \\pi \\chi , where \\chi \\chi is the Euler characteristic of the surface. On surfaces with boundary, the geodesic curvature of the boundary factors in. Only valid on triangular meshes. member: FaceData < double > IntrinsicGeometryInterface :: faceGaussianCurvatures require: void IntrinsicGeometryInterface :: requireFaceGaussianCurvatures () halfedge cotan weight halfedge cotan weight The \u201ccotangent weight\u201d of an interior halfedge, defined as \\frac{1}{2} \\cot(\\theta) \\frac{1}{2} \\cot(\\theta) , where \\theta \\theta is the corner angle opposite the halfedge. Defined to be 0 0 for exterior halfedges. Can be computed directly from edge lengths, or more efficiently in an embedded triangle via \\cot(\\theta) = \\frac{u \\cdot v}{||u \\times v||} \\cot(\\theta) = \\frac{u \\cdot v}{||u \\times v||} , where u u and v v are the edge vectors emanating from the opposite corner. Only valid on triangular meshes. member: HalfedgeData < double > IntrinsicGeometryInterface :: halfedgeCotanWeights require: void IntrinsicGeometryInterface :: requireHalfedgeCotanWeights () The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry :: halfedgeCotanWeight ( Halfedge he ) immediate: double VertexPositionGeometry :: halfedgeCotanWeight ( Halfedge he ) edge cotan weight edge cotan weight The \u201ccotangent weight\u201d of an edge, defined as the sum of halfedge cotan weights for incident interior halfedges. Only valid on triangular meshes. member: EdgeData < double > IntrinsicGeometryInterface :: edgeCotanWeights require: void IntrinsicGeometryInterface :: requireEdgeCotanWeights () The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry :: edgeCotanWeight ( Edge e ) immediate: double VertexPositionGeometry :: edgeCotanWeight ( Edge e ) Tangent vectors and transport These quantities are defined for any IntrinsicGeometryInterface , which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. Tangent vectors and transport are defined in terms of tangent spaces at faces and vertices, as defined below. Recall that our Vector2 types obey the multiplication and division rules of complex arithmetic, and thus can be used to represent rotations. For instance, a 2D vector representing a rotation can be used to rotate another vector like: Vector2 v = /* your vector */ Vector2 r = Vector2 { std :: cos ( PI / 4 ), std :: sin ( PI / 4 )}; // rotation by 45 degrees Vector2 vRot = r * v ; This is fundamentally no different from using 2x2 rotation matrices, but leads to much cleaner code (try using division to compute relative rotations!). Face tangent spaces To represent vectors that sit in flat mesh faces, we define a 2D coordinate frame tangent to each face. By default, this frame is aligned such that face . halfedge () points along the x x -axis (but subclasses might change this convention). All vectors in faces are then expressed via (x,y) (x,y) Vector2D coordinates in this frame. Crucially, this basis is well-defined even if the geometry does not have vertex positions. See face tangent basis to convert these vectors to world coordinates (if your mesh has vertex positions). halfedge vectors in face halfedge vectors in face Vectors for each halfedge in the coordinate frame of the face in which they sit. See the description of face tangent spaces above for a definition. Only valid on triangular meshes. member: HalfedgeData < Vector2 > IntrinsicGeometryInterface :: halfedgeVectorsInFace require: void IntrinsicGeometryInterface :: requireHalfedgeVectorsInFace () transport vector across halfedge transport vector across halfedge Rotations which transport tangent vectors across a halfedge, rotating a vector from the tangent space of halfedge . face () to the tangent space halfedge . twin (). face () . Always a unit vector, which can be multiplied by any other vector to compute the rotation. (recall our Vector2 s multiply like complex numbers) Only valid on triangular meshes. Not defined for halfedges (interior or exterior) incident on boundary edges, these boundary values are set to NaN so errors can be caught quickly. member: HalfedgeData < Vector2 > IntrinsicGeometryInterface :: transportVectorAcrossHalfedge require: void IntrinsicGeometryInterface :: requireTransportVectorAcrossHalfedge () Example usage: geometry . requireTransportVectorAcrossHalfedge (); Face f = /* ... */ ; // a face of interest Vector2 myVec = /* ... */ ; // tangent vector in face f for ( Halfedge he : f . adjacentHalfedges ()) { Vertex neighborFace = he . twin (). face (); Vector2 rot = geometry . transportVectorAcrossHalfedge [ he ]; Vector2 neighVec = rot * myVec ; // now in the basis of neighborFace } Vertex tangent spaces To represent vectors that sit at mesh faces, we consider a polar coordinate frame at each vertex. This frame is defined by measuring angles according to the rescaled corner angles as in cornerScaledAngles . By default, this frame is aligned such that vertex . halfedge () points along the \\phi=0 \\phi=0 x x -axis (but subclasses might change this convention). Of course, rather than using polar coordinates we can equivalently work in the corresponding Cartesian frame\u2014tangent vectors at vertices are then expressed via (x,y) (x,y) Vector2D coordinates in this frame. Crucially, this basis does not require picking a vertex normal, and is well-defined even if the geometry does not have vertex positions. See vertex tangent basis to convert these tangent vectors to world coordinates (if your mesh has vertex positions). halfedge vectors in vertex halfedge vectors in vertex Vectors for each halfedge in the coordinate frame of the vertex from which the emanate (in halfedge . vertex () ). See the description of vertex tangent spaces above for a definition. Only valid on triangular meshes. member: HalfedgeData < Vector2 > IntrinsicGeometryInterface :: halfedgeVectorsInVertex require: void IntrinsicGeometryInterface :: requireHalfedgeVectorsInVertex () transport vector along halfedge transport vector along halfedge Rotations which transport tangent vectors along a halfedge, rotating a vector from the tangent space of halfedge . vertex () to the tangent space halfedge . twin (). vertex () . Always a unit vector, which can be multiplied by any other vector to compute the rotation. (recall our Vector2 s multiply like complex numbers) Only valid on triangular meshes. member: HalfedgeData < Vector2 > IntrinsicGeometryInterface :: transportVectorAlongHalfedge require: void IntrinsicGeometryInterface :: requireTransportVectorAlongHalfedge () Example usage: geometry . requireTransportVectorAlongHalfedge (); Vertex v = /* ... */ ; // a vertex of interest Vector2 myVec = /* ... */ ; // tangent vector in vertex v for ( Halfedge he : v . outgoingHalfedges ()) { Vertex neighborVertex = he . twin (). vertex (); Vector2 rot = geometry . transportVectorAlongHalfedge [ he ]; Vector2 neighVec = rot * myVec ; // now in the basis of neighborVertex } Operators These quantities are defined for any IntrinsicGeometryInterface , which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. A full explanation of these operators is beyond the scope of these docs; see these course notes for one introduction. All operators are indexed over mesh elements according to the natural iteration order of the elements, or equivalently the indices from HalfedgeMesh :: getVertexIndices () (etc). cotangent Laplacian cotangent laplacian The discrete Laplace operator, discretized via cotangent weights. A |V| \\times |V| |V| \\times |V| real matrix. Always symmetric and positive semi-definite. If and only the underlying geometry is Delaunay , the matrix will furthermore have all negative off-diagonal entries, satisfy a maximum principle, and be an M-matrix . This is the weak Laplace operator, if we use it to evalutae \\mathsf{y} \\leftarrow \\mathsf{L} \\mathsf{x} \\mathsf{y} \\leftarrow \\mathsf{L} \\mathsf{x} , \\mathsf{x} \\mathsf{x} should hold pointwise quantities at vertices, and the result \\mathsf{y} \\mathsf{y} will contain integrated values of the result in the neighborhood of each vertex. If used to solve a Poisson problem, a mass matrix (such as the lumped or Galerkin mass matrices below) are likely necessary on the right hand side. Only valid on triangular meshes. member: Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: laplacian require: void IntrinsicGeometryInterface :: requireLaplacian () vertex lumped mass matrix vertex lumped mass matrix A mass matrix at vertices, where vertex area is 1/3 1/3 the incident face areas as in vertexDualAreas . A |V| \\times |V| |V| \\times |V| real diagonal matrix. Generally less-accurate than the Galerkin mass matrix below, but can be easily inverted since it is a diagonal matrix. Only valid on triangular meshes. member: Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: vertexLumpedMassMatrix require: void IntrinsicGeometryInterface :: requireVertexLumpedMassMatrix () vertex Galerkin mass matrix vertex Galerkin mass matrix A mass matrix at vertices, supported at all neighbors of a vertex via integration of piecewise-linear elements. A |V| \\times |V| |V| \\times |V| real matrix. Generally more accurate than the lumped mass matrix above, should be preferred unless the mass matrix needs to be inverted. Only valid on triangular meshes. member: Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: vertexGalerkinMassMatrix require: void IntrinsicGeometryInterface :: requireVertexGalerkinMassMatrix () vertex connection Laplacian vertex connection Laplacian A discrete connection Laplacian operator, which applies to vector fields defined in vertex tangent spaces. Essentially defined as the scalar cotangent Laplacian, augmented with rotations given by the rotations in transportVectorAlongHalfedge ; see The Vector Heat Method, Sec 5.3 for more explanation and definition. A |V| \\times |V| |V| \\times |V| complex matrix. Always Hermitian, but positive semi-definite if and only the underlying geometry is Delaunay . This is a weak Laplace operator, the application of which outputs integrated values in vertex neighborhood. Given a complex vector \\mathsf{x} \\mathsf{x} of tangent vectors at vertices, apply the operator by multiplying \\mathsf{L} * \\mathsf{x} \\mathsf{L} * \\mathsf{x} . Only valid on triangular meshes. member: Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: vertexGalerkinMassMatrix require: void IntrinsicGeometryInterface :: requireVertexGalerkinMassMatrix () DEC operators DEC operators These operators are the basic building blocks for discrete exterior calculus on surfaces. Note: These quantities slightly deviate from the usual naming scheme for quantities. Rather than requireD0 () , requireD1 () , etc, there is a single requireDECOperators () function which manages all 8 of the members listed below. The following members are constructed: Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: hodge0 A |V| \\times |V| |V| \\times |V| diagonal matrix Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: hodge0Inverse A |V| \\times |V| |V| \\times |V| diagonal matrix Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: hodge1 An |E| \\times |E| |E| \\times |E| diagonal matrix Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: hodge1Inverse An |E| \\times |E| |E| \\times |E| diagonal matrix Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: hodge2 An |F| \\times |F| |F| \\times |F| diagonal matrix Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: hodge2Inverse An |F| \\times |F| |F| \\times |F| diagonal matrix Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: d0 An |E| \\times |V| |E| \\times |V| matrix with \\{-1, 0, 1\\} \\{-1, 0, 1\\} entries Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: d1 An |F| \\times |E| |F| \\times |E| matrix with \\{-1, 0, 1\\} \\{-1, 0, 1\\} entries Only valid on triangular meshes. require: void IntrinsicGeometryInterface :: requireDECOperators () Extrinsic angles These quantities depend on extrinsic angles, but are still rotation-invariant, and independent of a particular embeddeding. They are defined for ExtrinsicGeometryInterface and classes that extend it, including the EmbeddedGeometryInterface one usually constructs from vertex positions. Currently there is no realization that constructs an ExtrinsicGeometryInterface from input data which is not also an EmbeddedGeometryInterface , but such a class could be implemented in the future. edge dihedral angle edge dihedral angle The dihedral angle at an edge, in radians. Defined to be the signed angle between the incident triangle normals: 0 0 if the edge is flat, positive at a convex edge, and negative at a nonconvex edge. Only valid on triangular meshes. member: EdgeData < double > ExtrinsicGeometryInterface :: edgeDihedralAngles require: void ExtrinsicGeometryInterface :: requireEdgeDihedralAngles () vertex principal curvature direction vertex principal curvature direction A 2-symmetric tangent vector field at vertices. The direction corresponds to the first principal direction, and the magnitude is proportional to the squared difference of the 1st and 2nd principal curvatures (\\kappa_1 - \\kappa_2)^2 (\\kappa_1 - \\kappa_2)^2 (so for instance, if a surface is flat and \\kappa_1 \\approx \\kappa_2 \\kappa_1 \\approx \\kappa_2 , the magnitude of the field will be near 0 0 ). A formal description appears in section 6.1.2 of Globally Optimal Direction Fields Only valid on triangular meshes. member: VertexData < Vector2 > ExtrinsicGeometryInterface :: vertexPrincipalCurvatureDirections require: void ExtrinsicGeometryInterface :: requireVertexPrincipalCurvatureDirections () Embedded positions and normals These quantities depend explicitly on an embedding in 3D space (better known as vertex positions). They are defined for EmbeddedGeometryInterface (which is usually instantiated as a VertexPositionGeometry ). Don\u2019t forget, EmbeddedGeometryInterface extends the IntrinsicGeometryInterface and ExtrinsicGeometryInterface , so all of the quantities above are also accessible. vertex position vertex position Vertex positions in 3D. Note: this member is distinct from the VertexPositionGeometry :: inputVertexPositions field. In the common case of a VertexPositionGeometry , this member is a copy of the input vertex positions, provided for consistency and generality (one might define embedded surfaces with data other than vertex positions). If you want to update vertex positions on a mesh, you should modify inputVertexPositions , not this quantity. member: VertexData < Vector3 > EmbeddedGeometryInterface :: vertexPositions require: void EmbeddedGeometryInterface :: requireVertexPositions () face normal face normal A normal vector for each face. member: FaceData < Vector3 > EmbeddedGeometryInterface :: faceNormals require: void EmbeddedGeometryInterface :: requireFaceNormals () The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: Vector3 VertexPositionGeometry :: faceNormal ( Face f ) vertex normal vertex normal A normal vector for each vertex. Defined as the corner-angle weighted average of incident face normals. member: VertexData < Vector3 > EmbeddedGeometryInterface :: faceNormals require: void EmbeddedGeometryInterface :: requireFaceNormals () face tangent basis face tangent basis A pair of x x -axis and y y -axis 3D basis vectors in world space, corresponding to the intrinsic tangent space for the face. Always orthogonal to the face normal. Example: HalfedgeMesh & mesh = /* ... */ VertexPositionGeometry & geometry = /* ... */ ; FaceData < Vector2 > myTangentVectorField ; geometry . requireFaceTangentBasis (); for ( Face f : mesh . faces ()) { Vector2 field = myTangentVectorField [ f ]; Vector3 basisX = geometry . faceTangentBasis [ f ]; Vector3 basisY = geometry . faceTangentBasis [ f ]; Vector3 fieldInWorldCoords = basisX * field . x + basisY * field . y ; } member: FaceData < std :: array < Vector3 , 2 >> EmbeddedGeometryInterface :: faceTangentBasis require: void EmbeddedGeometryInterface :: requireFaceTangentBasis () vertex tangent basis vertex tangent basis A pair of x x -axis and y y -axis 3D basis vectors in world space, corresponding to the intrinsic tangent space for the vertex. Always orthogonal to the vertex normal. Example: HalfedgeMesh & mesh = /* ... */ VertexPositionGeometry & geometry = /* ... */ ; VertexData < Vector2 > myTangentVectorField ; geometry . requireFaceTangentBasis (); for ( Vertex v : mesh . vertices ()) { Vector2 field = myTangentVectorField [ v ]; Vector3 basisX = geometry . vertexTangentBasis [ v ]; Vector3 basisY = geometry . vertexTangentBasis [ v ]; Vector3 fieldInWorldCoords = basisX * field . x + basisY * field . y ; } member: VertexData < std :: array < Vector3 , 2 >> EmbeddedGeometryInterface :: vertexTangentBasis require: void EmbeddedGeometryInterface :: requireVertexTangentBasis ()","title":"Quantities"},{"location":"surface/geometry/quantities/#indices","text":"These quantities are defined for the base BaseGeometryInterface , and will always be available. They are not actually geometric data, but it is convenient to cache the canonical arrays alongside geometric quantities, as they are often used in concert. vertex indices","title":"Indices"},{"location":"surface/geometry/quantities/#vertex-indices","text":"A dense 0-based enumeration of vertices. Equivalent to the result of HalfedgeMesh :: getVertexIndices () . member: VertexData < size_t > BaseGeometryInterface :: vertexIndices require: void BaseGeometryInterface :: requireVertexIndices () halfedge indices","title":"vertex indices"},{"location":"surface/geometry/quantities/#halfedge-indices","text":"A dense 0-based enumeration of halfedges. Equivalent to the result of HalfedgeMesh :: getHalfedgeIndices () . member: HalfedgeData < size_t > BaseGeometryInterface :: halfedgeIndices require: void BaseGeometryInterface :: requireHalfedgeIndices () corner indices","title":"halfedge indices"},{"location":"surface/geometry/quantities/#corner-indices","text":"A dense 0-based enumeration of corners. Equivalent to the result of HalfedgeMesh :: getCornerIndices () . member: CornerData < size_t > BaseGeometryInterface :: cornerIndices require: void BaseGeometryInterface :: requireCornerIndices () edge indices","title":"corner indices"},{"location":"surface/geometry/quantities/#edge-indices","text":"A dense 0-based enumeration of edges. Equivalent to the result of HalfedgeMesh :: getEdgeIndices () . member: EdgeData < size_t > BaseGeometryInterface :: edgeIndices require: void BaseGeometryInterface :: requireEdgeIndices () face indices","title":"edge indices"},{"location":"surface/geometry/quantities/#face-indices","text":"A dense 0-based enumeration of faces. Equivalent to the result of HalfedgeMesh :: getFaceIndices () . member: FaceData < size_t > BaseGeometryInterface :: faceIndices require: void BaseGeometryInterface :: requireFaceIndices () boundary loop indices","title":"face indices"},{"location":"surface/geometry/quantities/#boundary-loop-indices","text":"A dense 0-based enumeration of boundary loops . Equivalent to the result of HalfedgeMesh :: getBoundaryLoopIndices () . member: BoundaryLoopData < size_t > BaseGeometryInterface :: boundaryLoopIndices require: void BaseGeometryInterface :: requireBoundaryLoopIndices ()","title":"boundary loop indices"},{"location":"surface/geometry/quantities/#lengths-areas-and-angles","text":"These quantities are defined for any IntrinsicGeometryInterface , which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. edge length","title":"Lengths, areas, and angles"},{"location":"surface/geometry/quantities/#edge-length","text":"The length of an edge in the mesh, as a non-negative real number. member: EdgeData < double > IntrinsicGeometryInterface :: edgeLengths require: void IntrinsicGeometryInterface :: requireEdgeLengths () The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double VertexPositionGeometry :: edgeLength ( Edge e ) face area","title":"edge length"},{"location":"surface/geometry/quantities/#face-area","text":"The area of a face, as a non-negative real number. May be computed from edge lengths via Heron\u2019s formula, or from embedded vertex positions with a cross product. Only valid on triangular meshes. member: FaceData < double > IntrinsicGeometryInterface :: faceAreas require: void IntrinsicGeometryInterface :: requireFaceAreas () The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry :: faceArea ( Face f ) immediate: double VertexPositionGeometry :: faceArea ( Face f ) vertex dual area","title":"face area"},{"location":"surface/geometry/quantities/#vertex-dual-area","text":"An area associated with each vertex, as a non-negative real number. Only valid on triangular meshes. Defined to be 1/3 1/3 the sum of all adjacent face areas. The sum of all vertex dual areas is equal to the usual surface area of the mesh. member: VertexData < double > IntrinsicGeometryInterface :: vertexDualAreas require: void IntrinsicGeometryInterface :: requireVertexDualAreas () corner angles","title":"vertex dual area"},{"location":"surface/geometry/quantities/#corner-angles","text":"The angle between incident edges at each corner of a mesh. Only valid on triangular meshes. member: CornerData < double > IntrinsicGeometryInterface :: cornerAngles require: void IntrinsicGeometryInterface :: requireCornerAngles () The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry :: cornerAngle ( Corner c ) immediate: double VertexPositionGeometry :: cornerAngle ( Corner c ) vertex angle sum","title":"corner angles"},{"location":"surface/geometry/quantities/#vertex-angle-sum","text":"The sum of corner angles around a vertex. Only valid on triangular meshes. member: VertexData < double > IntrinsicGeometryInterface :: vertexAngleSums require: void IntrinsicGeometryInterface :: requireVertexAngleSums () corner scaled angles","title":"vertex angle sum"},{"location":"surface/geometry/quantities/#corner-scaled-angles","text":"The angle between incident edges at each corner of a mesh, linearly rescaled such that the angles around every vertex sum to 2 \\pi 2 \\pi . At boundary vertices, no scaling will be performed. Only valid on triangular meshes. member: CornerData < double > IntrinsicGeometryInterface :: cornerScaledAngles require: void IntrinsicGeometryInterface :: requireCornerScaledAngles () vertex Gaussian curvature","title":"corner scaled angles"},{"location":"surface/geometry/quantities/#vertex-gaussian-curvature","text":"The Gaussian curvature K K at a vertex, defined via the angle defect K_v = 2 \\pi - \\sum \\theta_i K_v = 2 \\pi - \\sum \\theta_i , where \\sum \\theta_i \\sum \\theta_i is the vertexAngleSum as above. Should be interpreted as an integrated Gaussian curvature, giving the total curvature in the neighborhood of the vertex. On a closed surface, the Gauss-Bonnet theorem tells us that the sum of these Gaussian curvatures will be a topological constant given by \\sum_v K_v = 2 \\pi \\chi \\sum_v K_v = 2 \\pi \\chi , where \\chi \\chi is the Euler characteristic of the surface. On surfaces with boundary, the geodesic curvature of the boundary factors in. Only valid on triangular meshes. member: VertexData < double > IntrinsicGeometryInterface :: vertexGaussianCurvatures require: void IntrinsicGeometryInterface :: requireVertexGaussianCurvatures () face Gaussian curvature","title":"vertex Gaussian curvature"},{"location":"surface/geometry/quantities/#face-gaussian-curvature","text":"The Gaussian curvature K K at a face, defined via the rescaled angle defect in the face K_f = \\pi - \\sum \\tilde{\\theta}_i K_f = \\pi - \\sum \\tilde{\\theta}_i , where \\tilde{\\theta}_i \\tilde{\\theta}_i are the rescaled corner angles (as in cornerScaledAngles ) incident on the face. Should be interpreted as an integrated Gaussian curvature, giving the total curvature inside of the face. A corresponding curvature-per-unit-area can be computed by dividing by the area of the face. On a closed surface, the Gauss-Bonnet theorem tells us that the sum of these Gaussian curvatures will be a topological constant given by \\sum_f K_f = 2 \\pi \\chi \\sum_f K_f = 2 \\pi \\chi , where \\chi \\chi is the Euler characteristic of the surface. On surfaces with boundary, the geodesic curvature of the boundary factors in. Only valid on triangular meshes. member: FaceData < double > IntrinsicGeometryInterface :: faceGaussianCurvatures require: void IntrinsicGeometryInterface :: requireFaceGaussianCurvatures () halfedge cotan weight","title":"face Gaussian curvature"},{"location":"surface/geometry/quantities/#halfedge-cotan-weight","text":"The \u201ccotangent weight\u201d of an interior halfedge, defined as \\frac{1}{2} \\cot(\\theta) \\frac{1}{2} \\cot(\\theta) , where \\theta \\theta is the corner angle opposite the halfedge. Defined to be 0 0 for exterior halfedges. Can be computed directly from edge lengths, or more efficiently in an embedded triangle via \\cot(\\theta) = \\frac{u \\cdot v}{||u \\times v||} \\cot(\\theta) = \\frac{u \\cdot v}{||u \\times v||} , where u u and v v are the edge vectors emanating from the opposite corner. Only valid on triangular meshes. member: HalfedgeData < double > IntrinsicGeometryInterface :: halfedgeCotanWeights require: void IntrinsicGeometryInterface :: requireHalfedgeCotanWeights () The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry :: halfedgeCotanWeight ( Halfedge he ) immediate: double VertexPositionGeometry :: halfedgeCotanWeight ( Halfedge he ) edge cotan weight","title":"halfedge cotan weight"},{"location":"surface/geometry/quantities/#edge-cotan-weight","text":"The \u201ccotangent weight\u201d of an edge, defined as the sum of halfedge cotan weights for incident interior halfedges. Only valid on triangular meshes. member: EdgeData < double > IntrinsicGeometryInterface :: edgeCotanWeights require: void IntrinsicGeometryInterface :: requireEdgeCotanWeights () The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: double EdgeLengthGeometry :: edgeCotanWeight ( Edge e ) immediate: double VertexPositionGeometry :: edgeCotanWeight ( Edge e )","title":"edge cotan weight"},{"location":"surface/geometry/quantities/#tangent-vectors-and-transport","text":"These quantities are defined for any IntrinsicGeometryInterface , which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. Tangent vectors and transport are defined in terms of tangent spaces at faces and vertices, as defined below. Recall that our Vector2 types obey the multiplication and division rules of complex arithmetic, and thus can be used to represent rotations. For instance, a 2D vector representing a rotation can be used to rotate another vector like: Vector2 v = /* your vector */ Vector2 r = Vector2 { std :: cos ( PI / 4 ), std :: sin ( PI / 4 )}; // rotation by 45 degrees Vector2 vRot = r * v ; This is fundamentally no different from using 2x2 rotation matrices, but leads to much cleaner code (try using division to compute relative rotations!).","title":"Tangent vectors and transport"},{"location":"surface/geometry/quantities/#face-tangent-spaces","text":"To represent vectors that sit in flat mesh faces, we define a 2D coordinate frame tangent to each face. By default, this frame is aligned such that face . halfedge () points along the x x -axis (but subclasses might change this convention). All vectors in faces are then expressed via (x,y) (x,y) Vector2D coordinates in this frame. Crucially, this basis is well-defined even if the geometry does not have vertex positions. See face tangent basis to convert these vectors to world coordinates (if your mesh has vertex positions). halfedge vectors in face","title":"Face tangent spaces"},{"location":"surface/geometry/quantities/#halfedge-vectors-in-face","text":"Vectors for each halfedge in the coordinate frame of the face in which they sit. See the description of face tangent spaces above for a definition. Only valid on triangular meshes. member: HalfedgeData < Vector2 > IntrinsicGeometryInterface :: halfedgeVectorsInFace require: void IntrinsicGeometryInterface :: requireHalfedgeVectorsInFace () transport vector across halfedge","title":"halfedge vectors in face"},{"location":"surface/geometry/quantities/#transport-vector-across-halfedge","text":"Rotations which transport tangent vectors across a halfedge, rotating a vector from the tangent space of halfedge . face () to the tangent space halfedge . twin (). face () . Always a unit vector, which can be multiplied by any other vector to compute the rotation. (recall our Vector2 s multiply like complex numbers) Only valid on triangular meshes. Not defined for halfedges (interior or exterior) incident on boundary edges, these boundary values are set to NaN so errors can be caught quickly. member: HalfedgeData < Vector2 > IntrinsicGeometryInterface :: transportVectorAcrossHalfedge require: void IntrinsicGeometryInterface :: requireTransportVectorAcrossHalfedge () Example usage: geometry . requireTransportVectorAcrossHalfedge (); Face f = /* ... */ ; // a face of interest Vector2 myVec = /* ... */ ; // tangent vector in face f for ( Halfedge he : f . adjacentHalfedges ()) { Vertex neighborFace = he . twin (). face (); Vector2 rot = geometry . transportVectorAcrossHalfedge [ he ]; Vector2 neighVec = rot * myVec ; // now in the basis of neighborFace }","title":"transport vector across halfedge"},{"location":"surface/geometry/quantities/#vertex-tangent-spaces","text":"To represent vectors that sit at mesh faces, we consider a polar coordinate frame at each vertex. This frame is defined by measuring angles according to the rescaled corner angles as in cornerScaledAngles . By default, this frame is aligned such that vertex . halfedge () points along the \\phi=0 \\phi=0 x x -axis (but subclasses might change this convention). Of course, rather than using polar coordinates we can equivalently work in the corresponding Cartesian frame\u2014tangent vectors at vertices are then expressed via (x,y) (x,y) Vector2D coordinates in this frame. Crucially, this basis does not require picking a vertex normal, and is well-defined even if the geometry does not have vertex positions. See vertex tangent basis to convert these tangent vectors to world coordinates (if your mesh has vertex positions). halfedge vectors in vertex","title":"Vertex tangent spaces"},{"location":"surface/geometry/quantities/#halfedge-vectors-in-vertex","text":"Vectors for each halfedge in the coordinate frame of the vertex from which the emanate (in halfedge . vertex () ). See the description of vertex tangent spaces above for a definition. Only valid on triangular meshes. member: HalfedgeData < Vector2 > IntrinsicGeometryInterface :: halfedgeVectorsInVertex require: void IntrinsicGeometryInterface :: requireHalfedgeVectorsInVertex () transport vector along halfedge","title":"halfedge vectors in vertex"},{"location":"surface/geometry/quantities/#transport-vector-along-halfedge","text":"Rotations which transport tangent vectors along a halfedge, rotating a vector from the tangent space of halfedge . vertex () to the tangent space halfedge . twin (). vertex () . Always a unit vector, which can be multiplied by any other vector to compute the rotation. (recall our Vector2 s multiply like complex numbers) Only valid on triangular meshes. member: HalfedgeData < Vector2 > IntrinsicGeometryInterface :: transportVectorAlongHalfedge require: void IntrinsicGeometryInterface :: requireTransportVectorAlongHalfedge () Example usage: geometry . requireTransportVectorAlongHalfedge (); Vertex v = /* ... */ ; // a vertex of interest Vector2 myVec = /* ... */ ; // tangent vector in vertex v for ( Halfedge he : v . outgoingHalfedges ()) { Vertex neighborVertex = he . twin (). vertex (); Vector2 rot = geometry . transportVectorAlongHalfedge [ he ]; Vector2 neighVec = rot * myVec ; // now in the basis of neighborVertex }","title":"transport vector along halfedge"},{"location":"surface/geometry/quantities/#operators","text":"These quantities are defined for any IntrinsicGeometryInterface , which is the base class of all other geometry objects\u2014they will always be available on any kind of geometry. A full explanation of these operators is beyond the scope of these docs; see these course notes for one introduction. All operators are indexed over mesh elements according to the natural iteration order of the elements, or equivalently the indices from HalfedgeMesh :: getVertexIndices () (etc). cotangent Laplacian","title":"Operators"},{"location":"surface/geometry/quantities/#cotangent-laplacian","text":"The discrete Laplace operator, discretized via cotangent weights. A |V| \\times |V| |V| \\times |V| real matrix. Always symmetric and positive semi-definite. If and only the underlying geometry is Delaunay , the matrix will furthermore have all negative off-diagonal entries, satisfy a maximum principle, and be an M-matrix . This is the weak Laplace operator, if we use it to evalutae \\mathsf{y} \\leftarrow \\mathsf{L} \\mathsf{x} \\mathsf{y} \\leftarrow \\mathsf{L} \\mathsf{x} , \\mathsf{x} \\mathsf{x} should hold pointwise quantities at vertices, and the result \\mathsf{y} \\mathsf{y} will contain integrated values of the result in the neighborhood of each vertex. If used to solve a Poisson problem, a mass matrix (such as the lumped or Galerkin mass matrices below) are likely necessary on the right hand side. Only valid on triangular meshes. member: Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: laplacian require: void IntrinsicGeometryInterface :: requireLaplacian () vertex lumped mass matrix","title":"cotangent laplacian"},{"location":"surface/geometry/quantities/#vertex-lumped-mass-matrix","text":"A mass matrix at vertices, where vertex area is 1/3 1/3 the incident face areas as in vertexDualAreas . A |V| \\times |V| |V| \\times |V| real diagonal matrix. Generally less-accurate than the Galerkin mass matrix below, but can be easily inverted since it is a diagonal matrix. Only valid on triangular meshes. member: Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: vertexLumpedMassMatrix require: void IntrinsicGeometryInterface :: requireVertexLumpedMassMatrix () vertex Galerkin mass matrix","title":"vertex lumped mass matrix"},{"location":"surface/geometry/quantities/#vertex-galerkin-mass-matrix","text":"A mass matrix at vertices, supported at all neighbors of a vertex via integration of piecewise-linear elements. A |V| \\times |V| |V| \\times |V| real matrix. Generally more accurate than the lumped mass matrix above, should be preferred unless the mass matrix needs to be inverted. Only valid on triangular meshes. member: Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: vertexGalerkinMassMatrix require: void IntrinsicGeometryInterface :: requireVertexGalerkinMassMatrix () vertex connection Laplacian","title":"vertex Galerkin mass matrix"},{"location":"surface/geometry/quantities/#vertex-connection-laplacian","text":"A discrete connection Laplacian operator, which applies to vector fields defined in vertex tangent spaces. Essentially defined as the scalar cotangent Laplacian, augmented with rotations given by the rotations in transportVectorAlongHalfedge ; see The Vector Heat Method, Sec 5.3 for more explanation and definition. A |V| \\times |V| |V| \\times |V| complex matrix. Always Hermitian, but positive semi-definite if and only the underlying geometry is Delaunay . This is a weak Laplace operator, the application of which outputs integrated values in vertex neighborhood. Given a complex vector \\mathsf{x} \\mathsf{x} of tangent vectors at vertices, apply the operator by multiplying \\mathsf{L} * \\mathsf{x} \\mathsf{L} * \\mathsf{x} . Only valid on triangular meshes. member: Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: vertexGalerkinMassMatrix require: void IntrinsicGeometryInterface :: requireVertexGalerkinMassMatrix () DEC operators","title":"vertex connection Laplacian"},{"location":"surface/geometry/quantities/#dec-operators","text":"These operators are the basic building blocks for discrete exterior calculus on surfaces. Note: These quantities slightly deviate from the usual naming scheme for quantities. Rather than requireD0 () , requireD1 () , etc, there is a single requireDECOperators () function which manages all 8 of the members listed below. The following members are constructed: Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: hodge0 A |V| \\times |V| |V| \\times |V| diagonal matrix Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: hodge0Inverse A |V| \\times |V| |V| \\times |V| diagonal matrix Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: hodge1 An |E| \\times |E| |E| \\times |E| diagonal matrix Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: hodge1Inverse An |E| \\times |E| |E| \\times |E| diagonal matrix Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: hodge2 An |F| \\times |F| |F| \\times |F| diagonal matrix Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: hodge2Inverse An |F| \\times |F| |F| \\times |F| diagonal matrix Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: d0 An |E| \\times |V| |E| \\times |V| matrix with \\{-1, 0, 1\\} \\{-1, 0, 1\\} entries Eigen :: SparseMatrix < double > IntrinsicGeometryInterface :: d1 An |F| \\times |E| |F| \\times |E| matrix with \\{-1, 0, 1\\} \\{-1, 0, 1\\} entries Only valid on triangular meshes. require: void IntrinsicGeometryInterface :: requireDECOperators ()","title":"DEC operators"},{"location":"surface/geometry/quantities/#extrinsic-angles","text":"These quantities depend on extrinsic angles, but are still rotation-invariant, and independent of a particular embeddeding. They are defined for ExtrinsicGeometryInterface and classes that extend it, including the EmbeddedGeometryInterface one usually constructs from vertex positions. Currently there is no realization that constructs an ExtrinsicGeometryInterface from input data which is not also an EmbeddedGeometryInterface , but such a class could be implemented in the future. edge dihedral angle","title":"Extrinsic angles"},{"location":"surface/geometry/quantities/#edge-dihedral-angle","text":"The dihedral angle at an edge, in radians. Defined to be the signed angle between the incident triangle normals: 0 0 if the edge is flat, positive at a convex edge, and negative at a nonconvex edge. Only valid on triangular meshes. member: EdgeData < double > ExtrinsicGeometryInterface :: edgeDihedralAngles require: void ExtrinsicGeometryInterface :: requireEdgeDihedralAngles () vertex principal curvature direction","title":"edge dihedral angle"},{"location":"surface/geometry/quantities/#vertex-principal-curvature-direction","text":"A 2-symmetric tangent vector field at vertices. The direction corresponds to the first principal direction, and the magnitude is proportional to the squared difference of the 1st and 2nd principal curvatures (\\kappa_1 - \\kappa_2)^2 (\\kappa_1 - \\kappa_2)^2 (so for instance, if a surface is flat and \\kappa_1 \\approx \\kappa_2 \\kappa_1 \\approx \\kappa_2 , the magnitude of the field will be near 0 0 ). A formal description appears in section 6.1.2 of Globally Optimal Direction Fields Only valid on triangular meshes. member: VertexData < Vector2 > ExtrinsicGeometryInterface :: vertexPrincipalCurvatureDirections require: void ExtrinsicGeometryInterface :: requireVertexPrincipalCurvatureDirections ()","title":"vertex principal curvature direction"},{"location":"surface/geometry/quantities/#embedded-positions-and-normals","text":"These quantities depend explicitly on an embedding in 3D space (better known as vertex positions). They are defined for EmbeddedGeometryInterface (which is usually instantiated as a VertexPositionGeometry ). Don\u2019t forget, EmbeddedGeometryInterface extends the IntrinsicGeometryInterface and ExtrinsicGeometryInterface , so all of the quantities above are also accessible. vertex position","title":"Embedded positions and normals"},{"location":"surface/geometry/quantities/#vertex-position","text":"Vertex positions in 3D. Note: this member is distinct from the VertexPositionGeometry :: inputVertexPositions field. In the common case of a VertexPositionGeometry , this member is a copy of the input vertex positions, provided for consistency and generality (one might define embedded surfaces with data other than vertex positions). If you want to update vertex positions on a mesh, you should modify inputVertexPositions , not this quantity. member: VertexData < Vector3 > EmbeddedGeometryInterface :: vertexPositions require: void EmbeddedGeometryInterface :: requireVertexPositions () face normal","title":"vertex position"},{"location":"surface/geometry/quantities/#face-normal","text":"A normal vector for each face. member: FaceData < Vector3 > EmbeddedGeometryInterface :: faceNormals require: void EmbeddedGeometryInterface :: requireFaceNormals () The inline immediate method can alternately be used to compute this value directly from input data for a single element: immediate: Vector3 VertexPositionGeometry :: faceNormal ( Face f ) vertex normal","title":"face normal"},{"location":"surface/geometry/quantities/#vertex-normal","text":"A normal vector for each vertex. Defined as the corner-angle weighted average of incident face normals. member: VertexData < Vector3 > EmbeddedGeometryInterface :: faceNormals require: void EmbeddedGeometryInterface :: requireFaceNormals () face tangent basis","title":"vertex normal"},{"location":"surface/geometry/quantities/#face-tangent-basis","text":"A pair of x x -axis and y y -axis 3D basis vectors in world space, corresponding to the intrinsic tangent space for the face. Always orthogonal to the face normal. Example: HalfedgeMesh & mesh = /* ... */ VertexPositionGeometry & geometry = /* ... */ ; FaceData < Vector2 > myTangentVectorField ; geometry . requireFaceTangentBasis (); for ( Face f : mesh . faces ()) { Vector2 field = myTangentVectorField [ f ]; Vector3 basisX = geometry . faceTangentBasis [ f ]; Vector3 basisY = geometry . faceTangentBasis [ f ]; Vector3 fieldInWorldCoords = basisX * field . x + basisY * field . y ; } member: FaceData < std :: array < Vector3 , 2 >> EmbeddedGeometryInterface :: faceTangentBasis require: void EmbeddedGeometryInterface :: requireFaceTangentBasis () vertex tangent basis","title":"face tangent basis"},{"location":"surface/geometry/quantities/#vertex-tangent-basis","text":"A pair of x x -axis and y y -axis 3D basis vectors in world space, corresponding to the intrinsic tangent space for the vertex. Always orthogonal to the vertex normal. Example: HalfedgeMesh & mesh = /* ... */ VertexPositionGeometry & geometry = /* ... */ ; VertexData < Vector2 > myTangentVectorField ; geometry . requireFaceTangentBasis (); for ( Vertex v : mesh . vertices ()) { Vector2 field = myTangentVectorField [ v ]; Vector3 basisX = geometry . vertexTangentBasis [ v ]; Vector3 basisY = geometry . vertexTangentBasis [ v ]; Vector3 fieldInWorldCoords = basisX * field . x + basisY * field . y ; } member: VertexData < std :: array < Vector3 , 2 >> EmbeddedGeometryInterface :: vertexTangentBasis require: void EmbeddedGeometryInterface :: requireVertexTangentBasis ()","title":"vertex tangent basis"},{"location":"surface/halfedge_mesh/basics/","text":"Halfedge meshes The halfedge mesh is a powerful and flexible data structure for representing oriented, manifold polygonal meshes, and is the core data structure in geometry-central. The halfedge mesh has several key advantages over other data structures, most notably that all adjacent-neighborhood traversals can be implemented in constant time, without the use of any variably-sized neighbor lists. Furthermore, common mutation operations like edge splits and vertex insertions can be performed in constant time. This halfedge mesh implementation furthermore stores all elements in contiguous buffers of memory, which makes it fast (see internals for implementation details). As the name suggests, the primary type in a halfedge mesh is a halfedge , in addition to the usual vertex , edge and face types. A halfedge is a directed edge incident on a face, as shown below. Two halfedges, oriented in opposite directions, make up each edge in the mesh. Each halfedge has relationships with five adjacent elements: Halfedge :: twin () the other halfedge across the incident edge Halfedge :: next () the next halfedge in clockwise order around the incident face Halfedge :: vertex () the vertex at the tail (back) of the halfedge Halfedge :: edge () the incident edge Halfedge :: face () the incident face Each vertex, edge, and face need just one relationship: Vertex :: halfedge () any of the incident halfedges (which point outward from the vertex) Edge :: halfedge () any of the incident halfedges Face :: halfedge () any of the incident halfedges In fact, this fixed set of relationships is sufficient to implement pretty much any local traversal. Geometry central provides a wide range of convience iterators which wrap these relationships to traverse neighborhoods, such as the example below. for ( Edge e : vertex . adjacentEdges ()) { // do science } See navigation for more information on traversals and convenience iterators. Notice that the lightweight Halfedge (etc) types serve simply as logical references, or \u201chandles\u201d to a mesh element. Deleting one of these handles does not delete the underlying element, and one may have multiple handles to the same element Vertex a ; Vertex b ; a == b ; . Manifold, Oriented Surfaces The basic halfedge mesh imposes two requirements: manifoldness and orientability. Manifoldness means that our surface must locally look like a plane in any neighborhood. This disallows structures such as three faces meeting at an edge, or two cones of faces meeting at a single vertex like an hourglass. Furthermore the halfedge mesh implies a combinatorial orientation of the surface, indicated by the clockwise ordering of halfedges around each face (see figure below). Because the halfedge mesh implies an orientation, it cannot represent non-orientable surfaces, like a Klein bottle. These properties are invariants which always hold for any meaningful halfedge mesh; in practice we check them during construction and ensure that all operations preserve them. Note that our halfedge mesh does not require that faces be triangles or quads; arbitrary faces with degree >= 3 are supported, and faces of different degree may be intermingled. However, many operations are only defined for triangle meshes and will throw errors if invoked on other meshes. Basic API Constructors HalfedgeMesh ( const std :: vector < std :: vector < size_t >>& polygons , bool verbose = false ) Constructs a halfedge mesh from a face-index list. polygons a list of faces, each holding the indices of the vertices incident on that face, zero-indexed and in counter-clockwise order. verbose if true, prints some statistics to std :: cout during construction. Element counts size_t HalfedgeMesh :: nVertices () Returns the number of vertices. size_t HalfedgeMesh :: nInteriorVertices () Returns the number of vertices not incident on the boundary. size_t HalfedgeMesh :: nBoundaryVertices () Returns the number of vertices incident on the boundary. size_t HalfedgeMesh :: nEdges () Returns the number of edges. size_t HalfedgeMesh :: nFaces () Returns the number of faces in the mesh. size_t HalfedgeMesh :: nHalfedges () Returns the number of halfedges, including both interior halfedges and any exterior halfedges incident on boundary loops. Always exactly twice the number of edges. size_t HalfedgeMesh :: nInterioHalfedges () Returns the number of interior halfedges, which are incident on faces of the mesh. Always equal to the sum of the number of sides of all faces. size_t HalfedgeMesh :: nExteriorHalfedges () Returns the number of exterior halfedges, which are opposite boundary faces. size_t HalfedgeMesh :: nBoundaryLoops () Returns the number of distinct boundary loops in the mesh, each identified as an fictional face closing a boundary loop in the mesh. Properties bool HalfedgeMesh :: hasBoundary () Returns true if the mesh has boundary, that is if it is not closed . Complexity \\mathcal{O}(1) \\mathcal{O}(1) . int HalfedgeMesh :: eulerCharacteristic () Returns the Euler characteristic of the surface. Computed in O(1) from element counts. Note: always computed by naively applying Euler\u2019s polyhedron formula , which might not do what you want in the case of multiple-connected components. int HalfedgeMesh :: genus () Returns the genus of the surface. Computed in O(1) from element counts. Note: always computed by naively applying Euler\u2019s polyhedron formula , which might not do what you want in the case of multiple connected components. bool HalfedgeMesh :: isTriangular () Returns true if all faces in the mesh have 3 sides. Complexity \\mathcal{O}(n) \\mathcal{O}(n) , do not call in a tight loop. size_t HalfedgeMesh :: nConnectedComponents () Returns the number of distinct connected components of the mesh. Complexity \\mathcal{O}(n) \\mathcal{O}(n) , do not call in a tight loop. Utility functions std :: unique_ptr < Halfedgemesh > copy () Constructs a copy of the mesh.","title":"Basics"},{"location":"surface/halfedge_mesh/basics/#halfedge-meshes","text":"The halfedge mesh is a powerful and flexible data structure for representing oriented, manifold polygonal meshes, and is the core data structure in geometry-central. The halfedge mesh has several key advantages over other data structures, most notably that all adjacent-neighborhood traversals can be implemented in constant time, without the use of any variably-sized neighbor lists. Furthermore, common mutation operations like edge splits and vertex insertions can be performed in constant time. This halfedge mesh implementation furthermore stores all elements in contiguous buffers of memory, which makes it fast (see internals for implementation details). As the name suggests, the primary type in a halfedge mesh is a halfedge , in addition to the usual vertex , edge and face types. A halfedge is a directed edge incident on a face, as shown below. Two halfedges, oriented in opposite directions, make up each edge in the mesh. Each halfedge has relationships with five adjacent elements: Halfedge :: twin () the other halfedge across the incident edge Halfedge :: next () the next halfedge in clockwise order around the incident face Halfedge :: vertex () the vertex at the tail (back) of the halfedge Halfedge :: edge () the incident edge Halfedge :: face () the incident face Each vertex, edge, and face need just one relationship: Vertex :: halfedge () any of the incident halfedges (which point outward from the vertex) Edge :: halfedge () any of the incident halfedges Face :: halfedge () any of the incident halfedges In fact, this fixed set of relationships is sufficient to implement pretty much any local traversal. Geometry central provides a wide range of convience iterators which wrap these relationships to traverse neighborhoods, such as the example below. for ( Edge e : vertex . adjacentEdges ()) { // do science } See navigation for more information on traversals and convenience iterators. Notice that the lightweight Halfedge (etc) types serve simply as logical references, or \u201chandles\u201d to a mesh element. Deleting one of these handles does not delete the underlying element, and one may have multiple handles to the same element Vertex a ; Vertex b ; a == b ; .","title":"Halfedge meshes"},{"location":"surface/halfedge_mesh/basics/#manifold-oriented-surfaces","text":"The basic halfedge mesh imposes two requirements: manifoldness and orientability. Manifoldness means that our surface must locally look like a plane in any neighborhood. This disallows structures such as three faces meeting at an edge, or two cones of faces meeting at a single vertex like an hourglass. Furthermore the halfedge mesh implies a combinatorial orientation of the surface, indicated by the clockwise ordering of halfedges around each face (see figure below). Because the halfedge mesh implies an orientation, it cannot represent non-orientable surfaces, like a Klein bottle. These properties are invariants which always hold for any meaningful halfedge mesh; in practice we check them during construction and ensure that all operations preserve them. Note that our halfedge mesh does not require that faces be triangles or quads; arbitrary faces with degree >= 3 are supported, and faces of different degree may be intermingled. However, many operations are only defined for triangle meshes and will throw errors if invoked on other meshes.","title":"Manifold, Oriented Surfaces"},{"location":"surface/halfedge_mesh/basics/#basic-api","text":"","title":"Basic API"},{"location":"surface/halfedge_mesh/basics/#constructors","text":"HalfedgeMesh ( const std :: vector < std :: vector < size_t >>& polygons , bool verbose = false ) Constructs a halfedge mesh from a face-index list. polygons a list of faces, each holding the indices of the vertices incident on that face, zero-indexed and in counter-clockwise order. verbose if true, prints some statistics to std :: cout during construction.","title":"Constructors"},{"location":"surface/halfedge_mesh/basics/#element-counts","text":"size_t HalfedgeMesh :: nVertices () Returns the number of vertices. size_t HalfedgeMesh :: nInteriorVertices () Returns the number of vertices not incident on the boundary. size_t HalfedgeMesh :: nBoundaryVertices () Returns the number of vertices incident on the boundary. size_t HalfedgeMesh :: nEdges () Returns the number of edges. size_t HalfedgeMesh :: nFaces () Returns the number of faces in the mesh. size_t HalfedgeMesh :: nHalfedges () Returns the number of halfedges, including both interior halfedges and any exterior halfedges incident on boundary loops. Always exactly twice the number of edges. size_t HalfedgeMesh :: nInterioHalfedges () Returns the number of interior halfedges, which are incident on faces of the mesh. Always equal to the sum of the number of sides of all faces. size_t HalfedgeMesh :: nExteriorHalfedges () Returns the number of exterior halfedges, which are opposite boundary faces. size_t HalfedgeMesh :: nBoundaryLoops () Returns the number of distinct boundary loops in the mesh, each identified as an fictional face closing a boundary loop in the mesh.","title":"Element counts"},{"location":"surface/halfedge_mesh/basics/#properties","text":"bool HalfedgeMesh :: hasBoundary () Returns true if the mesh has boundary, that is if it is not closed . Complexity \\mathcal{O}(1) \\mathcal{O}(1) . int HalfedgeMesh :: eulerCharacteristic () Returns the Euler characteristic of the surface. Computed in O(1) from element counts. Note: always computed by naively applying Euler\u2019s polyhedron formula , which might not do what you want in the case of multiple-connected components. int HalfedgeMesh :: genus () Returns the genus of the surface. Computed in O(1) from element counts. Note: always computed by naively applying Euler\u2019s polyhedron formula , which might not do what you want in the case of multiple connected components. bool HalfedgeMesh :: isTriangular () Returns true if all faces in the mesh have 3 sides. Complexity \\mathcal{O}(n) \\mathcal{O}(n) , do not call in a tight loop. size_t HalfedgeMesh :: nConnectedComponents () Returns the number of distinct connected components of the mesh. Complexity \\mathcal{O}(n) \\mathcal{O}(n) , do not call in a tight loop.","title":"Properties"},{"location":"surface/halfedge_mesh/basics/#utility-functions","text":"std :: unique_ptr < Halfedgemesh > copy () Constructs a copy of the mesh.","title":"Utility functions"},{"location":"surface/halfedge_mesh/boundaries/","text":"Mesh boundaries in halfedge meshes are modelled by logically treating each boundary loop as if it were a face with an associated set of halfedges. These halfedges incident on boundary loops are referred to as exterior halfedges , while the usual halfedges incident on faces actually present in the mesh are interior halfedges . Any boundary edge of the mesh will have one interior and one exterior halfedge incident upon it. Exterior halfedges Nearly all routines involving halfedges include both interior and exterior halfedges, as this is most often what is needed in algorithms. HalfedgeData <> containers can hold data on exterior halfedges, and iterators (like Vertex :: outgoingHalfedges ) will iterate over both interior and exterior halfedges. A few routines explicitly indicate whether they process interior halfedges, exterior halfedges, or both, such as HalfedgeMesh :: nInteriorHalfedges () . bool Halfedge :: isInterior () Return: true if the halfedge is an interior halfedge, and false if it is an exterior halfedge. Faces and boundary loops The separate type BoundaryLoop is used to represent boundary loops, and offers all functionality of other element types. For instance, the BoundaryLoopData <> container can be used to associate data with boundary loops, and BoundaryLoop :: adjacentVertices () can be used to iterate over the vertices along a boundary component. Since boundary loops act like faces in the mesh connectivity, traversing the mesh might yield a \u201cface\u201d referring to what is really a boundary loop. In particular, calling Halfedge :: face () on an exterior halfedge will yield the \u201cface\u201d which is its boundary loop. However, this \u201cface\u201d is a lie, we have not really added a face to the mesh: HalfedgeMesh :: nFaces () will still report the actual number of faces, etc. The only valid thing to do with a Face which actually a boundary loop is to immediately convert it to a BoundaryLoop , See the example below. Halfedge myHe = /* some exterior halfedge */ ; assert ( myHe . isInterior () == false ); // this is an exterior halfedge // Traverse to \"face\" Face bFace = myExteriorHalfedge . face () // bFace is really a boundary loop, doing any face things // with it would be invalid assert ( bFace . isBoundaryLoop () == true ) // Convert the \"face\" to its true boundary loop form BoundaryLoop bLoop = bFace . asBoundaryLoop (); // Now we can do all kinds of things with it for ( Edge e : bLoop . adjacentEdges ()) { /* do science */ } bool Face :: isBoundaryLoop () Returns true if the face is really a boundary loop. BoundaryLoop Face :: asBoundaryLoop () Convert a face to the equivalent boundary loop. Only valid to call on a face for which Face :: isBoundaryLoop () == true . Face BoundaryLoop :: asFace () Convert a boundary loop back to its equivalent face. The inverse of Face :: asBoundaryLoop () . Rarely used. Element boundary properties The previous sections describe elements which make up the boundary of a mesh. The methods here identify elements which merely lie along the mesh boundary. bool Vertex :: isBoundary () Returns true if the vertex is on the boundary. A vertex is on the boundary if any of its incident edges are boundary edges. O(1) O(1) . bool Edge :: isBoundary () Returns true if the edge is on the boundary. An edge is on the boundary if either of its incident halfedges are exterior halfedges. O(1) O(1) . Note that only edges which lie entirely along a boundary are considered boundary edges. Edges which \u201cpoint at\u201d the boundary and touch the boundary only at one endpoint are not considered boundary edges by this function.","title":"Boundaries"},{"location":"surface/halfedge_mesh/boundaries/#exterior-halfedges","text":"Nearly all routines involving halfedges include both interior and exterior halfedges, as this is most often what is needed in algorithms. HalfedgeData <> containers can hold data on exterior halfedges, and iterators (like Vertex :: outgoingHalfedges ) will iterate over both interior and exterior halfedges. A few routines explicitly indicate whether they process interior halfedges, exterior halfedges, or both, such as HalfedgeMesh :: nInteriorHalfedges () . bool Halfedge :: isInterior () Return: true if the halfedge is an interior halfedge, and false if it is an exterior halfedge.","title":"Exterior halfedges"},{"location":"surface/halfedge_mesh/boundaries/#faces-and-boundary-loops","text":"The separate type BoundaryLoop is used to represent boundary loops, and offers all functionality of other element types. For instance, the BoundaryLoopData <> container can be used to associate data with boundary loops, and BoundaryLoop :: adjacentVertices () can be used to iterate over the vertices along a boundary component. Since boundary loops act like faces in the mesh connectivity, traversing the mesh might yield a \u201cface\u201d referring to what is really a boundary loop. In particular, calling Halfedge :: face () on an exterior halfedge will yield the \u201cface\u201d which is its boundary loop. However, this \u201cface\u201d is a lie, we have not really added a face to the mesh: HalfedgeMesh :: nFaces () will still report the actual number of faces, etc. The only valid thing to do with a Face which actually a boundary loop is to immediately convert it to a BoundaryLoop , See the example below. Halfedge myHe = /* some exterior halfedge */ ; assert ( myHe . isInterior () == false ); // this is an exterior halfedge // Traverse to \"face\" Face bFace = myExteriorHalfedge . face () // bFace is really a boundary loop, doing any face things // with it would be invalid assert ( bFace . isBoundaryLoop () == true ) // Convert the \"face\" to its true boundary loop form BoundaryLoop bLoop = bFace . asBoundaryLoop (); // Now we can do all kinds of things with it for ( Edge e : bLoop . adjacentEdges ()) { /* do science */ } bool Face :: isBoundaryLoop () Returns true if the face is really a boundary loop. BoundaryLoop Face :: asBoundaryLoop () Convert a face to the equivalent boundary loop. Only valid to call on a face for which Face :: isBoundaryLoop () == true . Face BoundaryLoop :: asFace () Convert a boundary loop back to its equivalent face. The inverse of Face :: asBoundaryLoop () . Rarely used.","title":"Faces and boundary loops"},{"location":"surface/halfedge_mesh/boundaries/#element-boundary-properties","text":"The previous sections describe elements which make up the boundary of a mesh. The methods here identify elements which merely lie along the mesh boundary. bool Vertex :: isBoundary () Returns true if the vertex is on the boundary. A vertex is on the boundary if any of its incident edges are boundary edges. O(1) O(1) . bool Edge :: isBoundary () Returns true if the edge is on the boundary. An edge is on the boundary if either of its incident halfedges are exterior halfedges. O(1) O(1) . Note that only edges which lie entirely along a boundary are considered boundary edges. Edges which \u201cpoint at\u201d the boundary and touch the boundary only at one endpoint are not considered boundary edges by this function.","title":"Element boundary properties"},{"location":"surface/halfedge_mesh/containers/","text":"The halfedge mesh class is equipped with a system of containers for associating data with mesh vertices, halfedges, edges, and faces. For instance, to represent a scalar value at vertices, or a vector value at faces, one can use // on vertices VertexData < double > myVertexScalar ( mesh ); Vertex v = /* some vertex */ ; myVertexScalar [ v ] = 42. ; // on faces FaceData < Vector3 > myFaceVector ( mesh ); Face f = /* some face */ ; myFaceVector [ f ] = Vector3 { 1. , 2. , 3. }; and so on. A key feature of the MeshData <> containers is that they automatically adapt to mutation of the underlying mesh . All existing MeshData <> containers will remain valid during any sequence of mesh element insertions and deletions, adaptively and efficiently resizing themselves as needed. These containers can also be automatically written to file . Mesh data types The mesh data types are all templated on a common base class: MeshData < E , T > , where E is an element pointer type (such as Vertex ) and T is a scalar type (such as double ). The first template argument should usually be omitted in user code; the various element containers are all typedef\u2019d with concise names as follows: VertexData < T > data at vertices HalfedgeData < T > data at (interior and exterior) halfedges CornerData < T > data at corners EdgeData < T > data at edges FaceData < T > data at faces BoundaryLoopData < T > data at boundary loops Most functionality is identical between all of these classes, so the sections below are written in terms of the generic MeshData <> class. Construction MeshData < E , T >:: MeshData < E , T > ( HalfedgeMesh & mesh ) Construct a new container over a mesh. Elements will be default-initialized with T () . MeshData < E , T >:: MeshData < E , T > ( HalfedgeMesh & mesh , T initVal ) Construct a new container over a mesh. Elements will be initialized with initVal , and any newly-created mesh elements will have their default values set to initVal . Additionally, see the vector-based initializers in vector interoperability . Accessors T & MeshData < E , T >:: operator []( E ptr ) Access data stored in the container with a reference to a mesh element. A const version also exists; expect semantics like std :: vector <> . For example: // on vertices VertexData < double > myVertexScalar ( mesh ); Vertex v = /* some vertex */ ; myVertexScalar [ v ] = 42. ; double val = myVertexScalar [ v ]; T & MeshData < E , T >:: operator []( size_t ind ) Access data stored in the container by the index of a mesh element. A const version also exists; expect semantics like std :: vector <> . Only valid when the underlying mesh is compressed . Must have 0 <= ind < N , where N is the number of elements of that type. For example: // on vertices VertexData < double > myVertexScalar ( mesh ); myVertexScalar [ 11 ] = 42. ; double val = myVertexScalar [ 11 ]; // equivalent to: double val = myVertexScalar [ mesh -> vertex ( 11 )]; void MeshData < E , T >:: fill ( T fillVal ) Fill all entries in the container with fillVal . size_t MeshData < E , T >:: size () The size of the container (equal to the number of elements of type E , e.g. HalfedgeMesh :: nVertices () ). Vector interoperability To support easy common-case linear algebra operations, MeshData <> containers support conversion to and from Eigen vector types. The corresponding vectors are indexed according to the indices of the underlying mesh elements, or by a user-supplied index map which maps each elements to a dense set of zero-based indices. Construct from a vector: MeshData < E , T >:: MeshData < E , T > ( HalfedgeMesh & mesh Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec ) Construct a new container over a mesh, with the contents of vec . MeshData < E , T >:: MeshData < E , T > ( HalfedgeMesh & mesh Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec , MeshData < E , size_t >& indexer ) Construct a new container over a mesh, with the contents of vec , indexed according to indexer . Fill from a vector: void MeshData < E , T >:: fromVector ( Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec ) Fill this container with the contents of vec . void MeshData < E , T >:: fromVector ( Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec , MeshData < E , size_t >& indexer ) Fill this container with the contents of vec , indexed according to indexer . Convert to a vector: Eigen :: Matrix < T , Eigen :: Dynamic , 1 > MeshData < E , T >:: toVector () Return a new vector which holds the contents of this container. Eigen :: Matrix < T , Eigen :: Dynamic , 1 > MeshData < E , T >:: toVector ( MeshData < E , size_t >& indexer ) Return a new vector which holds the contents of this container, indexed according to indexer . Transferring data MeshData <> containers are defined with respect to a particular mesh object. Sometimes one may need to transfer data defined on one mesh to another, for instance after making a copy of a mesh, or when reading data from file. MeshData < E , T > MeshData < E , T >:: reinterpretTo ( HalfedgeMesh & target ) Map data defined on one halfedge mesh to another. The meshes must have the same number of elements, and data will be naively transferred between elements with the same index. Requires that both meshes be compressed . Example usage: HalfedgeMesh meshA = /* something */ ; HalfedgeMesh meshB = meshA . copy (); FaceData < Vector3 > myDataOnA ( meshA ); /* fill myDataOnA with interesting values */ FaceData < Vector3 > myDataOnB = myDataOnA . reinterpretTo ( meshB ); Advanced features Underlying storage Under the hood, all MeshData <> types use a std :: vector < T > to store their values. This has at least two significant consquences: For the scalar type bool , these containers are essentially broken, because std :: vector < bool > is a weird, broken special case . Using char instead is usually a fine substitute: you can construct VertexData < char > flags and set flags [ vert ] = true as you would expect. A special allocator is needed for aligned objects, in particular fixed-size Eigen types (see gotchas ). These MeshData <> containers all internally use the aligned allocator std :: vector < T , Eigen :: aligned_allocator < T >> , so they can safely store fixed-sized Eigen types . Oriented edge data Scalar values on edges often carry meaning with respect to some oriented direction along the edge\u2014 common examples include differences between values at vertices, the integral of a vector field along an edge, or more generally any 1-form in discrete differential geometry. In such settings, a scalar value is concisely stored along edges, but its sign should flip when accessed \u201calong\u201d the opposite direction. EdgeData < T > containers offer a pair of special additional accessors for oriented data, which handle the sign flips automatically. Note that they cannot be instantiated unless the scalar type T supports a unary - operator. T EdgeData < T >:: getOriented ( Halfedge he ) Access edge-valued data with sign determined by canonical halfedge orientation. Returns edgeData [ he . edge ()] if he == he . edge (). halfedge () , or - edgeData [ he . edge ()] otherwise. void EdgeData < T >:: setOriented ( Halfedge he , T val ) Access edge-valued data with sign determined by canonical halfedge orientation. Sets edgeData [ he . edge ()] = val if he == he . edge (). halfedge () , or edgeData [ he . edge ()] = - val otherwise.","title":"Containers"},{"location":"surface/halfedge_mesh/containers/#mesh-data-types","text":"The mesh data types are all templated on a common base class: MeshData < E , T > , where E is an element pointer type (such as Vertex ) and T is a scalar type (such as double ). The first template argument should usually be omitted in user code; the various element containers are all typedef\u2019d with concise names as follows: VertexData < T > data at vertices HalfedgeData < T > data at (interior and exterior) halfedges CornerData < T > data at corners EdgeData < T > data at edges FaceData < T > data at faces BoundaryLoopData < T > data at boundary loops Most functionality is identical between all of these classes, so the sections below are written in terms of the generic MeshData <> class.","title":"Mesh data types"},{"location":"surface/halfedge_mesh/containers/#construction","text":"MeshData < E , T >:: MeshData < E , T > ( HalfedgeMesh & mesh ) Construct a new container over a mesh. Elements will be default-initialized with T () . MeshData < E , T >:: MeshData < E , T > ( HalfedgeMesh & mesh , T initVal ) Construct a new container over a mesh. Elements will be initialized with initVal , and any newly-created mesh elements will have their default values set to initVal . Additionally, see the vector-based initializers in vector interoperability .","title":"Construction"},{"location":"surface/halfedge_mesh/containers/#accessors","text":"T & MeshData < E , T >:: operator []( E ptr ) Access data stored in the container with a reference to a mesh element. A const version also exists; expect semantics like std :: vector <> . For example: // on vertices VertexData < double > myVertexScalar ( mesh ); Vertex v = /* some vertex */ ; myVertexScalar [ v ] = 42. ; double val = myVertexScalar [ v ]; T & MeshData < E , T >:: operator []( size_t ind ) Access data stored in the container by the index of a mesh element. A const version also exists; expect semantics like std :: vector <> . Only valid when the underlying mesh is compressed . Must have 0 <= ind < N , where N is the number of elements of that type. For example: // on vertices VertexData < double > myVertexScalar ( mesh ); myVertexScalar [ 11 ] = 42. ; double val = myVertexScalar [ 11 ]; // equivalent to: double val = myVertexScalar [ mesh -> vertex ( 11 )]; void MeshData < E , T >:: fill ( T fillVal ) Fill all entries in the container with fillVal . size_t MeshData < E , T >:: size () The size of the container (equal to the number of elements of type E , e.g. HalfedgeMesh :: nVertices () ).","title":"Accessors"},{"location":"surface/halfedge_mesh/containers/#vector-interoperability","text":"To support easy common-case linear algebra operations, MeshData <> containers support conversion to and from Eigen vector types. The corresponding vectors are indexed according to the indices of the underlying mesh elements, or by a user-supplied index map which maps each elements to a dense set of zero-based indices. Construct from a vector: MeshData < E , T >:: MeshData < E , T > ( HalfedgeMesh & mesh Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec ) Construct a new container over a mesh, with the contents of vec . MeshData < E , T >:: MeshData < E , T > ( HalfedgeMesh & mesh Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec , MeshData < E , size_t >& indexer ) Construct a new container over a mesh, with the contents of vec , indexed according to indexer . Fill from a vector: void MeshData < E , T >:: fromVector ( Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec ) Fill this container with the contents of vec . void MeshData < E , T >:: fromVector ( Eigen :: Matrix < T , Eigen :: Dynamic , 1 > vec , MeshData < E , size_t >& indexer ) Fill this container with the contents of vec , indexed according to indexer . Convert to a vector: Eigen :: Matrix < T , Eigen :: Dynamic , 1 > MeshData < E , T >:: toVector () Return a new vector which holds the contents of this container. Eigen :: Matrix < T , Eigen :: Dynamic , 1 > MeshData < E , T >:: toVector ( MeshData < E , size_t >& indexer ) Return a new vector which holds the contents of this container, indexed according to indexer .","title":"Vector interoperability"},{"location":"surface/halfedge_mesh/containers/#transferring-data","text":"MeshData <> containers are defined with respect to a particular mesh object. Sometimes one may need to transfer data defined on one mesh to another, for instance after making a copy of a mesh, or when reading data from file. MeshData < E , T > MeshData < E , T >:: reinterpretTo ( HalfedgeMesh & target ) Map data defined on one halfedge mesh to another. The meshes must have the same number of elements, and data will be naively transferred between elements with the same index. Requires that both meshes be compressed . Example usage: HalfedgeMesh meshA = /* something */ ; HalfedgeMesh meshB = meshA . copy (); FaceData < Vector3 > myDataOnA ( meshA ); /* fill myDataOnA with interesting values */ FaceData < Vector3 > myDataOnB = myDataOnA . reinterpretTo ( meshB );","title":"Transferring data"},{"location":"surface/halfedge_mesh/containers/#advanced-features","text":"","title":"Advanced features"},{"location":"surface/halfedge_mesh/containers/#underlying-storage","text":"Under the hood, all MeshData <> types use a std :: vector < T > to store their values. This has at least two significant consquences: For the scalar type bool , these containers are essentially broken, because std :: vector < bool > is a weird, broken special case . Using char instead is usually a fine substitute: you can construct VertexData < char > flags and set flags [ vert ] = true as you would expect. A special allocator is needed for aligned objects, in particular fixed-size Eigen types (see gotchas ). These MeshData <> containers all internally use the aligned allocator std :: vector < T , Eigen :: aligned_allocator < T >> , so they can safely store fixed-sized Eigen types .","title":"Underlying storage"},{"location":"surface/halfedge_mesh/containers/#oriented-edge-data","text":"Scalar values on edges often carry meaning with respect to some oriented direction along the edge\u2014 common examples include differences between values at vertices, the integral of a vector field along an edge, or more generally any 1-form in discrete differential geometry. In such settings, a scalar value is concisely stored along edges, but its sign should flip when accessed \u201calong\u201d the opposite direction. EdgeData < T > containers offer a pair of special additional accessors for oriented data, which handle the sign flips automatically. Note that they cannot be instantiated unless the scalar type T supports a unary - operator. T EdgeData < T >:: getOriented ( Halfedge he ) Access edge-valued data with sign determined by canonical halfedge orientation. Returns edgeData [ he . edge ()] if he == he . edge (). halfedge () , or - edgeData [ he . edge ()] otherwise. void EdgeData < T >:: setOriented ( Halfedge he , T val ) Access edge-valued data with sign determined by canonical halfedge orientation. Sets edgeData [ he . edge ()] = val if he == he . edge (). halfedge () , or edgeData [ he . edge ()] = - val otherwise.","title":"Oriented edge data"},{"location":"surface/halfedge_mesh/delta_complex/","text":"TL;DR This section clarifies some formal mathematical ideas that may arise in advanced usage of the halfedge mesh class. If you are simply loading up a triangle mesh and running an ordinary geometry processing algorithm, you need not worry about these details\u2014everything will behave as expected . If you are implementing intrinsic triangulation algorithms, doing an unreasonable number of edge flips, or are simply curious: read on! Introduction Halfedge meshes are often used to represent simplicial complexes . When you\u2019re thinking about a triangle mesh, you probably imagine a simplicial complex: each face has three distinct vertices and three distinct edges, each edge connects two distinct vertices, and there can be at most one edge between any pair of vertices. In fact, halfedge meshes (unlike many other mesh representations) can actually represent more general structures than just simplicial complexes. Halfedges meshes can represent any (oriented, manifold) \\Delta \\Delta -complex 1 . Intuitively, the \\Delta \\Delta -complex relaxes the restriction that incident elements be unique: a face may be incident on the same vertex multiple times an edge may connect a vertex to itself there may be multiple edges between a pair of vertices However, the \\Delta \\Delta -complex still requires that every faces has 3 sides, and the manifold restriction still means that the complex looks like a surface in any local neighborhood. Recall that we are only concerned with the connectivity of these surfaces, not how they sit in space: these general \\Delta \\Delta -complexes might be impossible to embed with straight edges between vertex positions in \\mathbb{R}^3 \\mathbb{R}^3 , but that does not bother us right now. The following surfaces are \\Delta \\Delta -complexes but not simplicial complexes: That sounds complicated, why would you do that? Don\u2019t forget, \\Delta \\Delta -complexes are a superset of simplicial complexes, so everything that works on general \\Delta \\Delta -complexes will work on a plain old triangle mesh too. Buy why go to the extra trouble to support general \\Delta \\Delta -complexes in geometry central? General \\Delta \\Delta -complexes allow extremely powerful algorithms for intrinsic geometry processing. Most famously, the intrinsic Delaunay formulation 2 builds a Laplace operator for an input triangle mesh which has fantastic numerical and computational properties, and the algorithm requires representing a \\Delta \\Delta -complex as an intermediate step. More generally, intrinsic triangulations 3 enable computational geometry algorithms like Delaunay refinement on triangle meshes, so long as long as one can represent \\Delta \\Delta -complexes which arise in intermediate steps. In both of these examples, features like self-edges are rare, and do not occur on most inputs. However, supporting them is necessary for the robustness and correctness of the algorithm. Fortunately, working in a software library which already supports the nuances of \\Delta \\Delta -complexes means these powerful algorithms can be implemented with little additional work. Software support The halfedge mesh class in geometry central is explicitly designed to ensure support for \\Delta \\Delta -complexes, rather than just simplicial complexes. Mostly, this is a natural consequence of the halfedge mesh formulation, but special care is needed for a few operations like mutations and serialization . Wherever relevant, the API will note its special properties with respect to \\Delta \\Delta -complexes. see Section 2.1 of Algebraic Topology by Allen Hatcher \u21a9 Bobenko, Alexander I., and Boris A. Springborn. A discrete Laplace\u2013Beltrami operator for simplicial surfaces. Discrete & Computational Geometry (2007) \u21a9 Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan. Navigating Intrinsic Triangulations . ACM Trans. Graph. (2019) \u21a9","title":"Delta Complexes"},{"location":"surface/halfedge_mesh/delta_complex/#introduction","text":"Halfedge meshes are often used to represent simplicial complexes . When you\u2019re thinking about a triangle mesh, you probably imagine a simplicial complex: each face has three distinct vertices and three distinct edges, each edge connects two distinct vertices, and there can be at most one edge between any pair of vertices. In fact, halfedge meshes (unlike many other mesh representations) can actually represent more general structures than just simplicial complexes. Halfedges meshes can represent any (oriented, manifold) \\Delta \\Delta -complex 1 . Intuitively, the \\Delta \\Delta -complex relaxes the restriction that incident elements be unique: a face may be incident on the same vertex multiple times an edge may connect a vertex to itself there may be multiple edges between a pair of vertices However, the \\Delta \\Delta -complex still requires that every faces has 3 sides, and the manifold restriction still means that the complex looks like a surface in any local neighborhood. Recall that we are only concerned with the connectivity of these surfaces, not how they sit in space: these general \\Delta \\Delta -complexes might be impossible to embed with straight edges between vertex positions in \\mathbb{R}^3 \\mathbb{R}^3 , but that does not bother us right now. The following surfaces are \\Delta \\Delta -complexes but not simplicial complexes:","title":"Introduction"},{"location":"surface/halfedge_mesh/delta_complex/#that-sounds-complicated-why-would-you-do-that","text":"Don\u2019t forget, \\Delta \\Delta -complexes are a superset of simplicial complexes, so everything that works on general \\Delta \\Delta -complexes will work on a plain old triangle mesh too. Buy why go to the extra trouble to support general \\Delta \\Delta -complexes in geometry central? General \\Delta \\Delta -complexes allow extremely powerful algorithms for intrinsic geometry processing. Most famously, the intrinsic Delaunay formulation 2 builds a Laplace operator for an input triangle mesh which has fantastic numerical and computational properties, and the algorithm requires representing a \\Delta \\Delta -complex as an intermediate step. More generally, intrinsic triangulations 3 enable computational geometry algorithms like Delaunay refinement on triangle meshes, so long as long as one can represent \\Delta \\Delta -complexes which arise in intermediate steps. In both of these examples, features like self-edges are rare, and do not occur on most inputs. However, supporting them is necessary for the robustness and correctness of the algorithm. Fortunately, working in a software library which already supports the nuances of \\Delta \\Delta -complexes means these powerful algorithms can be implemented with little additional work.","title":"That sounds complicated, why would you do that?"},{"location":"surface/halfedge_mesh/delta_complex/#software-support","text":"The halfedge mesh class in geometry central is explicitly designed to ensure support for \\Delta \\Delta -complexes, rather than just simplicial complexes. Mostly, this is a natural consequence of the halfedge mesh formulation, but special care is needed for a few operations like mutations and serialization . Wherever relevant, the API will note its special properties with respect to \\Delta \\Delta -complexes. see Section 2.1 of Algebraic Topology by Allen Hatcher \u21a9 Bobenko, Alexander I., and Boris A. Springborn. A discrete Laplace\u2013Beltrami operator for simplicial surfaces. Discrete & Computational Geometry (2007) \u21a9 Sharp, Nicholas and Soliman, Yousuf and Crane, Keenan. Navigating Intrinsic Triangulations . ACM Trans. Graph. (2019) \u21a9","title":"Software support"},{"location":"surface/halfedge_mesh/elements/","text":"Introduction This section covers the elements types for our halfedge mesh, as well as the traversal and utility functions that they offer. #include \"geometrycentral/surface/halfedge_mesh.h\" Note In the most proper sense, these element types are really \u201chandles\u201d to the underlying element. They refer to a particular element, but the Vertex variable in memory is not really the mesh element itself, just a temporary reference to it. For instance, it is possible (and common) to have multiple Vertex variables which actually refer to the same vertex, and allowing a Vertex variable to go out of scope certainly does not delete the vertex in the mesh. However, the semantics are very natural, so for the sake of brevity we call the type simply Vertex , rather than VertexHandle (etc). Additionally, see navigation for iterators to travese adjacent elements, like for ( Vertex v : face . adjacentVertices ()) . Construction Element types do not have constructors which should be called by the user. Instead, the element will always be created for you, via one of several methods, including: Iterating through the mesh for ( Vertex v : mesh . vertices ()) Traversing from a neighbor element Face f = halfedge . face () Iterating around an element for ( Halfedge he : vertex . outgoingHalfedges ()) Adding a new element to a mesh is covered in the mutation section . Comparison & Hashing All mesh elements support: equality checks ( == , != ) comparions ( < , > , <= , >= , according to the iteration order of the elements) hashing (so they can be used in a std :: unordered_map ) Vertex A vertex is a 0-dimensional point which serves as a node in the mesh. Traversal: Halfedge Vertex :: halfedge () Returns one of the halfedges whose tail is incident on this vertex. If the vertex is a boundary vertex, then it is guaranteed that the returned halfedge will be the unique interior halfedge along the boundary. That is the unique halfedge such that vertex . halfedge (). twin (). isInterior () == false . Corner Vertex :: corner () Returns one of the corners incident on the vertex. Utility: bool Vertex :: isBoundary () Returns true if the vertex is along the boundary of the mesh. See boundaries for more information. size_t Vertex :: degree () The degree of the vertex, i.e. the number of edges incident on the vertex. size_t Vertex :: faceDegree () The face-degree of the vertex, i.e. the number of faces incident on the vertex. On the interior of a mesh, this will be equal to Vertex :: degree () , at the boundary it will be smaller by one. Halfedge A halfedge is a the basic building block of a halfedge mesh. As its name suggests, the halfedge is half of an edge , connecting two vertices and sitting on on side of an edge in some face. The halfedge is directed, from its tail , to its tip . Our halfedges have a counter-clockwise orientation: the halfedges with in a face will always point in the counter-clockwise direction, and a halfedge and its twin (the neighbor across an edge) will point in opposite directions. Traversal: Halfedge Halfedge :: twin () Returns the halfedge\u2019s twin , its neighbor across an edge, which points in the opposite direction. Calling twin twice will always return to the initial halfedge: halfedge . twin (). twin () == halfedge . Halfedge Halfedge :: next () Returns the next halfedge in the same face as this halfedge, according to the counter-clockwise ordering. Vertex Halfedge :: vertex () Returns the vertex at the tail of this halfedge. Edge Halfedge :: edge () Returns the edge that this halfedge sits along. Face Halfedge :: face () Returns the face that this halfedge sits inside. Note that in the case of a mesh with boundary, if the halfedge is exterior the result of this function will really be a boundary loop. See boundaries for more information. Corner Halfedge :: corner () Returns the corner at the tail of this halfedge. Fancy Traversal: Halfedge Halfedge :: prevOrbitFace () Returns the previous halfedge, that is the halfedge such that he . next () == * this . This result is found by orbiting around the shared face. Because our halfedge mesh is singly-connected, this is not a simple O(1) O(1) lookup, but must be computed by orbiting around the face. Be careful: calling he . prevOrbitFace () on each exterior halfedge can easily lead to O(N^2) O(N^2) algorithm complexity, as each call walks all the way around a a boundary loop. Generally this operation can (and should) be avoided with proper code structure. Halfedge Halfedge :: prevOrbitVertex () Returns the previous halfedge, that is the halfedge such that he . next () == * this . This result is found by orbiting around the shared vertex. Because our halfedge mesh is singly-connected, this is not a simple O(1) O(1) lookup, but must be computed by orbiting around the vertex. Be careful: calling he . prevOrbitVertex () in a loop around a very high-degree vertex can easily lead to O(N^2) O(N^2) algorithm complexity, as each call walks all the way around the vertex. Generally this operation can (and should) be avoided with proper code structure. Utility: bool Halfedge :: isInterior () Returns true if the edge is interior , and false if it is exterior (i.e., incident on a boundary loop). See boundaries for more information. Edge An edge is a 1-dimensional element that connects two vertices in the mesh. Traversal: Halfedge Edge :: halfedge () Returns one of the two halfedges incident on this edge. If the edge is a boundary edge, it is guaranteed that the returned edge will be the interior one. Utility: bool Edge :: isBoundary () Returns true if the edge is along the boundary of the mesh. Note that edges which merely touch the boundary at one endpoint are not considered to be boundary edges. See boundaries for more information. Face A face is a 2-dimensional element formed by a loop of 3 or more edges. In general, our faces can be polygonal with d \\ge 3 d \\ge 3 edges, though many of the routines in geometry central are only valid on triangular meshes. Traversal: Halfedge Face :: halfedge () Returns any one of the halfedges inside of this face. BoundaryLoop Face :: asBoundaryLoop () Reinterprets this element as a boundary loop. Only valid if the face is, in fact, a boundary loop. See boundaries for more information. Utility: bool Face :: isBoundaryLoop () Returns true if the face is really a boundary loop. See boundaries for more information. bool Face :: isTriangle () Returns true if the face has three sides. size_t Face :: degree () Returns the number of sides in the face. Complexity O(d) O(d) , where d d is the resulting degree. Boundary Loop A boundary loop is a special face-like element used to represent holes in the mesh due to surface boundary. See boundaries for more information. Traversal: Halfedge BoundaryLoop :: halfedge () Returns any one of the halfedges inside of the boundary loop. Utility: size_t BoundaryLoop :: degree () Returns the number of sides in the boundary loop. Complexity O(d) O(d) , where d d is the resulting degree. Corner A corner is a convenience type referring to a corner inside of a face. Tracking corners as a separate type is useful, because one often logically represents data defined at corners. Traversal: Halfedge Corner :: halfedge () Returns the halfedge whose tail touches this corner. That is to say, corner . halfedge (). vertex () == corner . vertex () . Vertex Corner :: vertex () Returns the vertex which this corner is incident on. Face Corner :: face () Returns the face that this corner sits inside of.","title":"Elements"},{"location":"surface/halfedge_mesh/elements/#introduction","text":"This section covers the elements types for our halfedge mesh, as well as the traversal and utility functions that they offer. #include \"geometrycentral/surface/halfedge_mesh.h\" Note In the most proper sense, these element types are really \u201chandles\u201d to the underlying element. They refer to a particular element, but the Vertex variable in memory is not really the mesh element itself, just a temporary reference to it. For instance, it is possible (and common) to have multiple Vertex variables which actually refer to the same vertex, and allowing a Vertex variable to go out of scope certainly does not delete the vertex in the mesh. However, the semantics are very natural, so for the sake of brevity we call the type simply Vertex , rather than VertexHandle (etc). Additionally, see navigation for iterators to travese adjacent elements, like for ( Vertex v : face . adjacentVertices ()) .","title":"Introduction"},{"location":"surface/halfedge_mesh/elements/#construction","text":"Element types do not have constructors which should be called by the user. Instead, the element will always be created for you, via one of several methods, including: Iterating through the mesh for ( Vertex v : mesh . vertices ()) Traversing from a neighbor element Face f = halfedge . face () Iterating around an element for ( Halfedge he : vertex . outgoingHalfedges ()) Adding a new element to a mesh is covered in the mutation section .","title":"Construction"},{"location":"surface/halfedge_mesh/elements/#comparison-hashing","text":"All mesh elements support: equality checks ( == , != ) comparions ( < , > , <= , >= , according to the iteration order of the elements) hashing (so they can be used in a std :: unordered_map )","title":"Comparison &amp; Hashing"},{"location":"surface/halfedge_mesh/elements/#vertex","text":"A vertex is a 0-dimensional point which serves as a node in the mesh. Traversal: Halfedge Vertex :: halfedge () Returns one of the halfedges whose tail is incident on this vertex. If the vertex is a boundary vertex, then it is guaranteed that the returned halfedge will be the unique interior halfedge along the boundary. That is the unique halfedge such that vertex . halfedge (). twin (). isInterior () == false . Corner Vertex :: corner () Returns one of the corners incident on the vertex. Utility: bool Vertex :: isBoundary () Returns true if the vertex is along the boundary of the mesh. See boundaries for more information. size_t Vertex :: degree () The degree of the vertex, i.e. the number of edges incident on the vertex. size_t Vertex :: faceDegree () The face-degree of the vertex, i.e. the number of faces incident on the vertex. On the interior of a mesh, this will be equal to Vertex :: degree () , at the boundary it will be smaller by one.","title":"Vertex"},{"location":"surface/halfedge_mesh/elements/#halfedge","text":"A halfedge is a the basic building block of a halfedge mesh. As its name suggests, the halfedge is half of an edge , connecting two vertices and sitting on on side of an edge in some face. The halfedge is directed, from its tail , to its tip . Our halfedges have a counter-clockwise orientation: the halfedges with in a face will always point in the counter-clockwise direction, and a halfedge and its twin (the neighbor across an edge) will point in opposite directions. Traversal: Halfedge Halfedge :: twin () Returns the halfedge\u2019s twin , its neighbor across an edge, which points in the opposite direction. Calling twin twice will always return to the initial halfedge: halfedge . twin (). twin () == halfedge . Halfedge Halfedge :: next () Returns the next halfedge in the same face as this halfedge, according to the counter-clockwise ordering. Vertex Halfedge :: vertex () Returns the vertex at the tail of this halfedge. Edge Halfedge :: edge () Returns the edge that this halfedge sits along. Face Halfedge :: face () Returns the face that this halfedge sits inside. Note that in the case of a mesh with boundary, if the halfedge is exterior the result of this function will really be a boundary loop. See boundaries for more information. Corner Halfedge :: corner () Returns the corner at the tail of this halfedge. Fancy Traversal: Halfedge Halfedge :: prevOrbitFace () Returns the previous halfedge, that is the halfedge such that he . next () == * this . This result is found by orbiting around the shared face. Because our halfedge mesh is singly-connected, this is not a simple O(1) O(1) lookup, but must be computed by orbiting around the face. Be careful: calling he . prevOrbitFace () on each exterior halfedge can easily lead to O(N^2) O(N^2) algorithm complexity, as each call walks all the way around a a boundary loop. Generally this operation can (and should) be avoided with proper code structure. Halfedge Halfedge :: prevOrbitVertex () Returns the previous halfedge, that is the halfedge such that he . next () == * this . This result is found by orbiting around the shared vertex. Because our halfedge mesh is singly-connected, this is not a simple O(1) O(1) lookup, but must be computed by orbiting around the vertex. Be careful: calling he . prevOrbitVertex () in a loop around a very high-degree vertex can easily lead to O(N^2) O(N^2) algorithm complexity, as each call walks all the way around the vertex. Generally this operation can (and should) be avoided with proper code structure. Utility: bool Halfedge :: isInterior () Returns true if the edge is interior , and false if it is exterior (i.e., incident on a boundary loop). See boundaries for more information.","title":"Halfedge"},{"location":"surface/halfedge_mesh/elements/#edge","text":"An edge is a 1-dimensional element that connects two vertices in the mesh. Traversal: Halfedge Edge :: halfedge () Returns one of the two halfedges incident on this edge. If the edge is a boundary edge, it is guaranteed that the returned edge will be the interior one. Utility: bool Edge :: isBoundary () Returns true if the edge is along the boundary of the mesh. Note that edges which merely touch the boundary at one endpoint are not considered to be boundary edges. See boundaries for more information.","title":"Edge"},{"location":"surface/halfedge_mesh/elements/#face","text":"A face is a 2-dimensional element formed by a loop of 3 or more edges. In general, our faces can be polygonal with d \\ge 3 d \\ge 3 edges, though many of the routines in geometry central are only valid on triangular meshes. Traversal: Halfedge Face :: halfedge () Returns any one of the halfedges inside of this face. BoundaryLoop Face :: asBoundaryLoop () Reinterprets this element as a boundary loop. Only valid if the face is, in fact, a boundary loop. See boundaries for more information. Utility: bool Face :: isBoundaryLoop () Returns true if the face is really a boundary loop. See boundaries for more information. bool Face :: isTriangle () Returns true if the face has three sides. size_t Face :: degree () Returns the number of sides in the face. Complexity O(d) O(d) , where d d is the resulting degree.","title":"Face"},{"location":"surface/halfedge_mesh/elements/#boundary-loop","text":"A boundary loop is a special face-like element used to represent holes in the mesh due to surface boundary. See boundaries for more information. Traversal: Halfedge BoundaryLoop :: halfedge () Returns any one of the halfedges inside of the boundary loop. Utility: size_t BoundaryLoop :: degree () Returns the number of sides in the boundary loop. Complexity O(d) O(d) , where d d is the resulting degree.","title":"Boundary Loop"},{"location":"surface/halfedge_mesh/elements/#corner","text":"A corner is a convenience type referring to a corner inside of a face. Tracking corners as a separate type is useful, because one often logically represents data defined at corners. Traversal: Halfedge Corner :: halfedge () Returns the halfedge whose tail touches this corner. That is to say, corner . halfedge (). vertex () == corner . vertex () . Vertex Corner :: vertex () Returns the vertex which this corner is incident on. Face Corner :: face () Returns the face that this corner sits inside of.","title":"Corner"},{"location":"surface/halfedge_mesh/internals/","text":"Halfedge mesh internals This section contains details about the internal implementation of the halfedge mesh data structure. Typical users should not need to care about these details, but they may be useful for extension and debugging. The halfedge mesh structure is designed to simultaneously satisfy two core principles: contiguous storage: elements and mesh data are stored in flat buffers of memory. This makes traversing and storing data on the mesh fast. O(1) updates: dynamic operations that add and remove new elements must be supported in (amortized) constant time. This makes modifying the mesh fast. The solution to these two requirements is a dynamically-resizing, array-based mesh. Like a std :: vector , elements are stored in contiguous buffers of memory, which are transparently expanded and copied sporadically. Of course, this expansion is largely hidden from the user. Philosophically, our halfedge mesh aims to be as-implicit-as-possible : whenever we can, we represent connectivity and properties implicitly by indices. Although this strategy runs the risk of being \u201coverly clever\u201d programming, it has proven effective for two reasons. First, anything tracked explicitly and stored an array is a liability if that array is not updated properly\u2014conversely implicit relationships can be abstracted away behind helper functions, and need not be carefully maintained. Second, implicit relationships tend to lead fast implementations out of the box, avoiding performance hacking which runs a huge risk of breaking correctness. Permutation halfedge mesh Here\u2019s a neat fact: a halfedge mesh can be represented by a single permutation of length nHalfedges . How? First, consider an enumeration of the halfedges. We can implicitly encode the twin () relationship by storing twinned halfedges adjacent to one another\u2013 that is, the twin of an even-numbered halfedge numbered he is he + 1 , and the twin of and odd-numbered halfedge is he - 1 . We then use the permutation to encode the next () relationships. The faces are the orbits of the next () operation, enumerated in the order they are encountered. The edges are the orbits of the twin () operation, which can be enumerated implicitly from the index. The vertices are the orbits of the twin () . next () operation, again enumerated in the order they are encountered. This idea of a permutation is essentially the representation used for our halfedge mesh data structure: a single permutation array encodes the next () map, while the twin () , edge () , and edge . halfedge () maps are implicitly defined. However, although vertices and faces could be represented implicitly by an enumeration of orbits, doing so is inconvenient and expensive to update. Instead, we include additional arrays storing the he . vertex () , he . face () , v . halfedge () and f . halfedge () maps which are explicitly maintained. Basic structures Our halfedge mesh is index-based. Each {halfedge,edge,vertex,face} is identified by a 0-based index. The HalfedgeMesh class then holds the following explicit arrays encoding the connectivity between these indexed elements (the remaining relationships are implicitly defined). class HalfedgeMesh { ... private : std :: vector < size_t > heNext ; // for he.next() std :: vector < size_t > heVertex ; // for he.vertex() std :: vector < size_t > heFace ; // for he.face() std :: vector < size_t > vHalfedge ; // for v.halfedge() std :: vector < size_t > fHalfedge ; // for f.face() ... } ; The Halfedge , Vertex , etc. classes serve as typed wrappers referring to a mesh element. These wrappers store the index of the underlying element, as well as pointer to the mesh object itself. Traversal operations like he . next () are either implemented implicitly via index arithmetic, or by lookup in to the appropriate array. class Halfedge { ... size_t ind ; HalfedgeMesh * mesh ; Halfedge next () { return Halfedge { mesh -> heNext [ ind ], mesh } ; } // explicit Halfedge twin () { return Halfedge { ind ^ 1 , mesh } ; } // implicit ... } ; Why not pointers? One potential drawback to the index-based design is that each element must store its index as well as a pointer to the underlying mesh data structure. For instance, the smallest possible data layout of Halfedge would look something like struct Halfedge { size_t ind ; HalfedgeMesh * mesh ; } ; , because the ind is useless unless we know what arrays to index in to (e.g., to implement next () ). This extra storage could be avoided by replacing size_t ind with a pointer directly to memory encoding data about the halfedge. This design would reduce the sizeof ( Halfedge ) from 16 bytes to 8, as well as potentially avoiding some offset index instructions. So why don\u2019t we do that instead? In fact, the first implementation of this library used exactly that pointer-based design. However, it turned out to have two main downsides: semantics of pointer invalidation: In C++, doing nearly anything with an invalid pointer incurs undefined behavior, and expanding our buffers invalidates pointers. This meant that an \u201cunder the hood\u201d resize event would invalidate all of the user\u2019s Halfedge objects, necessitating frequent expensive use of DynamicHalfedge , rather than just around compress () as in the current design. implementation complexity: Working with raw pointers makes a lot of easy things hard. Significant pointer gymnastics were needed to internally implement resize operations without running afoul of invalid pointer rules. Simple operations like copying meshes and mesh data required pointer translation. Indexing in to a container essentially required a dense index from the element, so the codebase ended up littered with operations to construct indices from pointer offsets. The cumulative effect was quite error-prone. Ultimately, the index-based design seems preferrable. Invariants In addition to the basic properties of the twin () and next () maps, the halfedge mesh data structure offers a few useful invariants about its indexing scheme which must be maintained by all operations. on a boundary edge, e . halfedge () is the interior halfedge on a boundary vertex, v . halfedge () is the unique real interior halfedge along the boundary (so v . halfedge (). twin () is necessarily exterior, and traversing in CCW order walks the wedge) The validateConnectivity () function is extremely useful for checking invariants while developing the data structure. void HalfedgeMesh :: validateConnectivity () Perform a lot of sanity checks about the halfedge mesh. Throws if any fail. Resizing and deleting To enable (amortized) \\mathcal{O}(1) \\mathcal{O}(1) mutation, the buffers containing mesh data are lazily reallocated like a std :: vector when needed. As such the actual buffers like mesh . heNext might be larger than the current number of elements in the mesh; we separately track the count of real, valid elements to avoid accessing the extra regions of the array. The special index value INVALID_IND (which happens to be std :: numeric_limits < size_t > :: max () ) is used to fill index values that have no meaning. A similar issue arises with deletion. When a mesh element is deleted, it would be too expensive to shift the indices of all subsequent elements. Instead, we simply mark the element as deleted, leaving a hole in our index space. Deleted halfedges and their edges are implicitly encoded by heNext [ he ] == INVALID_IND , while deleted edges and vertices are encoded by vHalfedge [ v ] == INVALID_IND and fHalfedge [ f ] == INVALID_IND . Thus at any point in time, some indices may be invalid elements, left from previous deletions, and other array entries might correspond to extra elements allocated during the last resizing, waiting to be used. In all iterators and counts, explicit logic ensures that invalid elements are skipped. Traversal functions do not need any such logic, as it should be impossible to traverse from a valid element to an invalid element. The HalfedgeMesh :: compress () function is provided to re-index all mesh elements, and ensure a dense packing with no deleted elements. The following diagram lays out what this index space might look like. Exterior boundary elements One complexity in our implementation is the existence of exterior boundary elements. Recall that boundaries of our mesh are represented by filling each hole with a single, many-sided boundary loop; the halfedges incident on this face are \u201cexterior\u201d. This definition is convenient because it saves us from constantly special-casing elements on the boundary, but introduces some complexity because the user probably doesn\u2019t want to think about these boundary loops as faces most of the time. Exterior halfedges are enumerated alongside their interior counterparts, and generally are treated just like normal interior halfedges; most routines do not distinguish between the two. In contrast, although boundary loops are just faces internally, the API provides the illusion that they are a distinct type from the faces of the mesh. To enable this treatment, boundary loops are always stored at the back of the face index space. In general, the layout of the allocated index space will consist of first actual mesh faces, then any extra not-yet-used space, and finally boundary loops. Resize callbacks As the halfedge mesh is mutated, all MeshData <> containers automatically resize to stay in sync. This is implemented under the hood with a system of callback functions registered with the mesh itself. Whenever the mesh resizes or compresses one of its index spaces, it invokes a callback for each associated MeshData <> to do the same. DynamicHalfedge and friends also register themselves with the callback system, to stay valid as the mesh resizes. However, this results in a callback per dynamic element, which is why the dynamic elements are more expensive. Fortunately, dynamic elements can be used sparingly.","title":"Internals"},{"location":"surface/halfedge_mesh/internals/#halfedge-mesh-internals","text":"This section contains details about the internal implementation of the halfedge mesh data structure. Typical users should not need to care about these details, but they may be useful for extension and debugging. The halfedge mesh structure is designed to simultaneously satisfy two core principles: contiguous storage: elements and mesh data are stored in flat buffers of memory. This makes traversing and storing data on the mesh fast. O(1) updates: dynamic operations that add and remove new elements must be supported in (amortized) constant time. This makes modifying the mesh fast. The solution to these two requirements is a dynamically-resizing, array-based mesh. Like a std :: vector , elements are stored in contiguous buffers of memory, which are transparently expanded and copied sporadically. Of course, this expansion is largely hidden from the user. Philosophically, our halfedge mesh aims to be as-implicit-as-possible : whenever we can, we represent connectivity and properties implicitly by indices. Although this strategy runs the risk of being \u201coverly clever\u201d programming, it has proven effective for two reasons. First, anything tracked explicitly and stored an array is a liability if that array is not updated properly\u2014conversely implicit relationships can be abstracted away behind helper functions, and need not be carefully maintained. Second, implicit relationships tend to lead fast implementations out of the box, avoiding performance hacking which runs a huge risk of breaking correctness.","title":"Halfedge mesh internals"},{"location":"surface/halfedge_mesh/internals/#permutation-halfedge-mesh","text":"Here\u2019s a neat fact: a halfedge mesh can be represented by a single permutation of length nHalfedges . How? First, consider an enumeration of the halfedges. We can implicitly encode the twin () relationship by storing twinned halfedges adjacent to one another\u2013 that is, the twin of an even-numbered halfedge numbered he is he + 1 , and the twin of and odd-numbered halfedge is he - 1 . We then use the permutation to encode the next () relationships. The faces are the orbits of the next () operation, enumerated in the order they are encountered. The edges are the orbits of the twin () operation, which can be enumerated implicitly from the index. The vertices are the orbits of the twin () . next () operation, again enumerated in the order they are encountered. This idea of a permutation is essentially the representation used for our halfedge mesh data structure: a single permutation array encodes the next () map, while the twin () , edge () , and edge . halfedge () maps are implicitly defined. However, although vertices and faces could be represented implicitly by an enumeration of orbits, doing so is inconvenient and expensive to update. Instead, we include additional arrays storing the he . vertex () , he . face () , v . halfedge () and f . halfedge () maps which are explicitly maintained.","title":"Permutation halfedge mesh"},{"location":"surface/halfedge_mesh/internals/#basic-structures","text":"Our halfedge mesh is index-based. Each {halfedge,edge,vertex,face} is identified by a 0-based index. The HalfedgeMesh class then holds the following explicit arrays encoding the connectivity between these indexed elements (the remaining relationships are implicitly defined). class HalfedgeMesh { ... private : std :: vector < size_t > heNext ; // for he.next() std :: vector < size_t > heVertex ; // for he.vertex() std :: vector < size_t > heFace ; // for he.face() std :: vector < size_t > vHalfedge ; // for v.halfedge() std :: vector < size_t > fHalfedge ; // for f.face() ... } ; The Halfedge , Vertex , etc. classes serve as typed wrappers referring to a mesh element. These wrappers store the index of the underlying element, as well as pointer to the mesh object itself. Traversal operations like he . next () are either implemented implicitly via index arithmetic, or by lookup in to the appropriate array. class Halfedge { ... size_t ind ; HalfedgeMesh * mesh ; Halfedge next () { return Halfedge { mesh -> heNext [ ind ], mesh } ; } // explicit Halfedge twin () { return Halfedge { ind ^ 1 , mesh } ; } // implicit ... } ; Why not pointers? One potential drawback to the index-based design is that each element must store its index as well as a pointer to the underlying mesh data structure. For instance, the smallest possible data layout of Halfedge would look something like struct Halfedge { size_t ind ; HalfedgeMesh * mesh ; } ; , because the ind is useless unless we know what arrays to index in to (e.g., to implement next () ). This extra storage could be avoided by replacing size_t ind with a pointer directly to memory encoding data about the halfedge. This design would reduce the sizeof ( Halfedge ) from 16 bytes to 8, as well as potentially avoiding some offset index instructions. So why don\u2019t we do that instead? In fact, the first implementation of this library used exactly that pointer-based design. However, it turned out to have two main downsides: semantics of pointer invalidation: In C++, doing nearly anything with an invalid pointer incurs undefined behavior, and expanding our buffers invalidates pointers. This meant that an \u201cunder the hood\u201d resize event would invalidate all of the user\u2019s Halfedge objects, necessitating frequent expensive use of DynamicHalfedge , rather than just around compress () as in the current design. implementation complexity: Working with raw pointers makes a lot of easy things hard. Significant pointer gymnastics were needed to internally implement resize operations without running afoul of invalid pointer rules. Simple operations like copying meshes and mesh data required pointer translation. Indexing in to a container essentially required a dense index from the element, so the codebase ended up littered with operations to construct indices from pointer offsets. The cumulative effect was quite error-prone. Ultimately, the index-based design seems preferrable.","title":"Basic structures"},{"location":"surface/halfedge_mesh/internals/#invariants","text":"In addition to the basic properties of the twin () and next () maps, the halfedge mesh data structure offers a few useful invariants about its indexing scheme which must be maintained by all operations. on a boundary edge, e . halfedge () is the interior halfedge on a boundary vertex, v . halfedge () is the unique real interior halfedge along the boundary (so v . halfedge (). twin () is necessarily exterior, and traversing in CCW order walks the wedge) The validateConnectivity () function is extremely useful for checking invariants while developing the data structure. void HalfedgeMesh :: validateConnectivity () Perform a lot of sanity checks about the halfedge mesh. Throws if any fail.","title":"Invariants"},{"location":"surface/halfedge_mesh/internals/#resizing-and-deleting","text":"To enable (amortized) \\mathcal{O}(1) \\mathcal{O}(1) mutation, the buffers containing mesh data are lazily reallocated like a std :: vector when needed. As such the actual buffers like mesh . heNext might be larger than the current number of elements in the mesh; we separately track the count of real, valid elements to avoid accessing the extra regions of the array. The special index value INVALID_IND (which happens to be std :: numeric_limits < size_t > :: max () ) is used to fill index values that have no meaning. A similar issue arises with deletion. When a mesh element is deleted, it would be too expensive to shift the indices of all subsequent elements. Instead, we simply mark the element as deleted, leaving a hole in our index space. Deleted halfedges and their edges are implicitly encoded by heNext [ he ] == INVALID_IND , while deleted edges and vertices are encoded by vHalfedge [ v ] == INVALID_IND and fHalfedge [ f ] == INVALID_IND . Thus at any point in time, some indices may be invalid elements, left from previous deletions, and other array entries might correspond to extra elements allocated during the last resizing, waiting to be used. In all iterators and counts, explicit logic ensures that invalid elements are skipped. Traversal functions do not need any such logic, as it should be impossible to traverse from a valid element to an invalid element. The HalfedgeMesh :: compress () function is provided to re-index all mesh elements, and ensure a dense packing with no deleted elements. The following diagram lays out what this index space might look like.","title":"Resizing and deleting"},{"location":"surface/halfedge_mesh/internals/#exterior-boundary-elements","text":"One complexity in our implementation is the existence of exterior boundary elements. Recall that boundaries of our mesh are represented by filling each hole with a single, many-sided boundary loop; the halfedges incident on this face are \u201cexterior\u201d. This definition is convenient because it saves us from constantly special-casing elements on the boundary, but introduces some complexity because the user probably doesn\u2019t want to think about these boundary loops as faces most of the time. Exterior halfedges are enumerated alongside their interior counterparts, and generally are treated just like normal interior halfedges; most routines do not distinguish between the two. In contrast, although boundary loops are just faces internally, the API provides the illusion that they are a distinct type from the faces of the mesh. To enable this treatment, boundary loops are always stored at the back of the face index space. In general, the layout of the allocated index space will consist of first actual mesh faces, then any extra not-yet-used space, and finally boundary loops.","title":"Exterior boundary elements"},{"location":"surface/halfedge_mesh/internals/#resize-callbacks","text":"As the halfedge mesh is mutated, all MeshData <> containers automatically resize to stay in sync. This is implemented under the hood with a system of callback functions registered with the mesh itself. Whenever the mesh resizes or compresses one of its index spaces, it invokes a callback for each associated MeshData <> to do the same. DynamicHalfedge and friends also register themselves with the callback system, to stay valid as the mesh resizes. However, this results in a callback per dynamic element, which is why the dynamic elements are more expensive. Fortunately, dynamic elements can be used sparingly.","title":"Resize callbacks"},{"location":"surface/halfedge_mesh/mutation/","text":"These routines allow modification of the mesh connectivity and insertion/deletion of elements. Geometry-central is designed from the ground up to have good support for mesh mutation. The underlying HalfedgMesh data structure is index-based, with lazy expansion and deletion, so all operations run in (amortized) constant time with respect to the number of mesh elements, and usually do not incur any memory allocations. Containers automatically update after mesh operations. As much as possible, these routines will check for validity before executing and throw an exception if something isn\u2019t right. The NGC_SAFETY_CHECKS define disables this behavior for a modest increase in performance, but checks are enabled by default even in release builds. Note that aggressive use of these routines may reduce a mesh from a simplicial complex to a \\Delta \\Delta -complex . For instance, flipping enough edges in a mesh might create self-edges, which connect a vertex to itself. See the \\Delta \\Delta -complex section for details, and an explanation of why these complexes are important. In-place modifications bool HalfedgeMesh :: flip ( Edge e ) Flip an edge by rotating counter-clockwise. An edge cannot be combinatorially flipped if it is: a boundary edge incident on a degree-1 vertex. Return: true if the edge was actually flipped Insertions These routines modify a mesh by inserting new elements. Element references remain valid, and containers will automatically resize themselves to accommodate the new elements. Note that some operations my re-use existing elements to create their output. For instance, splitEdge () turns a single edge in to two; the input edge will be re-used as one of the two output edges, and data along that edge will be unchanged in any containers. Boundary loop invalidation There is one tiny exceptional invalidation behavior related to insertion. Face handles which actually point to boundary loops are invalidated after any operation which adds faces to the mesh. This is a consequence of the way we index boundary loops separate from faces, even though they are essentially faces in practice (see Boundaries and Internals ) for details. Halfedge HalfedgeMesh :: insertVertexAlongEdge ( Edge e ) Adds a degree 2 vertex along an edge. Unlike splitEdge () , this does not triangulate the adjacent faces; the degree of adjacent faces will be increased by 1. Works as expected on boundary edges. Returns a halfedge he along the newly created edge, which points in the same direction as e . halfedge () , and such that he . vertex () is the newly inserted vertex. Preserves canonical direction of edge.halfedge() for both halves of new edge. The original edge is repurposed as one of the two new edges (same for original halfedges). Halfedge HalfedgeMesh :: splitEdge ( Edge e ) Inserts a vertex along an edge, and triangulates the adjacent faces. On a triangle mesh, the newly inserted vertex will be a degree 4 vertex. Works as expected on boundary edges. Returns a halfedge he along the newly created edge, which points in the same direction as e . halfedge () , and such that he . vertex () is the newly inserted vertex. Preserves canonical direction of edge.halfedge() for both halves of new edge. The original edge is repurposed as one of the new edges (same for original halfedges). Vertex HalfedgeMesh :: insertVertex ( Face f ) TODO // Add vertex inside face and triangulate. Returns new vertex. Vertex insertVertex(Face f); Halfedge connectVertices ( Halfedge heA , Halfedge heB ) Call to add an edge to a face, splitting it to two faces. Creates a new edge connecting heA . vertex () to heB . vertex () . The initial shared face will be repurposed as one of the two resulting faces. heA and heB must be distinct halfedges in the same face, and their vertices must not already be adjacent in that face. Returns new halfedge with heA . vertex () at tail, and he . twin (). face () is the new face. std :: vector < Face > HalfedgeMesh :: triangulate ( Face face ) Triangulate a face in the mesh, returning all of the resulting faces. One of the returned faces will be the input face, repurposed as a face in the triangulation. Trimming storage To amortize the cost of allocation, mesh buffers are resized sporadically in large increments; these resized buffers might significantly increase (e.g., double) the storage size of a mesh and the associated containers. Calling trimStorage () frees up any unused storage space to reduce memory usage. void HalfedgeMesh :: trimStorage () Free any additional storage associated with the mesh. Does not invalidate elements. Trimming storage does not put the mesh in compressed mode , though compressing the mesh does trim storage. This function costs O(n) O(n) and should not be called in a tight loop. Deletions These routines delete mesh elements. Elements (like Vertex ) and containers (like VertexData <> ) will remain valid through deletions. However, performing any deletion will cause the mesh to no longer be compressed . Vertex HalfedgeMesh :: collapseEdge ( Edge e ) // Collapse an edge. Returns the vertex adjacent to that edge which still exists. Returns Vertex() if not // collapsible. Vertex collapseEdge(Edge e); bool HalfedgeMesh :: removeFaceAlongBoundary ( Face f ) // Remove a face which is adjacent to the boundary of the mesh (along with its edge on the boundary). // Face must have exactly one boundary edge. // Returns true if could remove bool removeFaceAlongBoundary(Face f); Compressed mode Internally, the halfedge mesh is represented by dense arrays of indices which are lazily expanded (see interals for details). To support fast deletion operations, we simply mark elements as deleted, without re-packing the index space. We say that the mesh is compressed if the index space is dense and there are no such marked elements. When a mesh is not compressed, the index of a mesh element no longer serves as a proper enumeration from [ 0 , N ) , but merely as a unique ID. There are two consequences to being non-compressed: Some operations cannot be implemented efficiently/correctly (e.g., random access of the i\u2019th vertex) Storage space is wasted by deleted elements All meshes are compressed after construction, and only become non-compressed if the user performs a deletion operation. The makeCompressed () function can be called to re-index the elements of the mesh as a proper enumeration from [ 0 , N ) . The makeCompressed () function invalidates pointers, and incurs an update of existing containers. As such, it is recommended to be called sporadically, after a sequence of operations is completed. bool HalfedgeMesh :: isCompressed () Returns true if the mesh is compressed. void HalfedgeMesh :: makeCompressed () Re-index the elements of the mesh to yield a dense enumeration. Invalidates all Vertex (etc) objects. Does nothing if the mesh is already compressed. Dynamic pointer types A few of the operations listed below invalidate outstanding element references (like Halfedge ) by re-indexing the elements of the mesh. Containers automatically update after re-indexing, and often code can be structured such that no element references need to be maintained across an invalidation. However, if it is necessary to keep a reference to an element through a re-indexing, the DynamicHalfedge can be used. These types behave like a Halfedge , with the exception that they automatically update to remain valid when a mesh is re-indexed. These types should only be used when necessary, because they are expensive to maintain.","title":"Mutation"},{"location":"surface/halfedge_mesh/mutation/#in-place-modifications","text":"bool HalfedgeMesh :: flip ( Edge e ) Flip an edge by rotating counter-clockwise. An edge cannot be combinatorially flipped if it is: a boundary edge incident on a degree-1 vertex. Return: true if the edge was actually flipped","title":"In-place modifications"},{"location":"surface/halfedge_mesh/mutation/#insertions","text":"These routines modify a mesh by inserting new elements. Element references remain valid, and containers will automatically resize themselves to accommodate the new elements. Note that some operations my re-use existing elements to create their output. For instance, splitEdge () turns a single edge in to two; the input edge will be re-used as one of the two output edges, and data along that edge will be unchanged in any containers. Boundary loop invalidation There is one tiny exceptional invalidation behavior related to insertion. Face handles which actually point to boundary loops are invalidated after any operation which adds faces to the mesh. This is a consequence of the way we index boundary loops separate from faces, even though they are essentially faces in practice (see Boundaries and Internals ) for details. Halfedge HalfedgeMesh :: insertVertexAlongEdge ( Edge e ) Adds a degree 2 vertex along an edge. Unlike splitEdge () , this does not triangulate the adjacent faces; the degree of adjacent faces will be increased by 1. Works as expected on boundary edges. Returns a halfedge he along the newly created edge, which points in the same direction as e . halfedge () , and such that he . vertex () is the newly inserted vertex. Preserves canonical direction of edge.halfedge() for both halves of new edge. The original edge is repurposed as one of the two new edges (same for original halfedges). Halfedge HalfedgeMesh :: splitEdge ( Edge e ) Inserts a vertex along an edge, and triangulates the adjacent faces. On a triangle mesh, the newly inserted vertex will be a degree 4 vertex. Works as expected on boundary edges. Returns a halfedge he along the newly created edge, which points in the same direction as e . halfedge () , and such that he . vertex () is the newly inserted vertex. Preserves canonical direction of edge.halfedge() for both halves of new edge. The original edge is repurposed as one of the new edges (same for original halfedges). Vertex HalfedgeMesh :: insertVertex ( Face f ) TODO // Add vertex inside face and triangulate. Returns new vertex. Vertex insertVertex(Face f); Halfedge connectVertices ( Halfedge heA , Halfedge heB ) Call to add an edge to a face, splitting it to two faces. Creates a new edge connecting heA . vertex () to heB . vertex () . The initial shared face will be repurposed as one of the two resulting faces. heA and heB must be distinct halfedges in the same face, and their vertices must not already be adjacent in that face. Returns new halfedge with heA . vertex () at tail, and he . twin (). face () is the new face. std :: vector < Face > HalfedgeMesh :: triangulate ( Face face ) Triangulate a face in the mesh, returning all of the resulting faces. One of the returned faces will be the input face, repurposed as a face in the triangulation.","title":"Insertions"},{"location":"surface/halfedge_mesh/mutation/#trimming-storage","text":"To amortize the cost of allocation, mesh buffers are resized sporadically in large increments; these resized buffers might significantly increase (e.g., double) the storage size of a mesh and the associated containers. Calling trimStorage () frees up any unused storage space to reduce memory usage. void HalfedgeMesh :: trimStorage () Free any additional storage associated with the mesh. Does not invalidate elements. Trimming storage does not put the mesh in compressed mode , though compressing the mesh does trim storage. This function costs O(n) O(n) and should not be called in a tight loop.","title":"Trimming storage"},{"location":"surface/halfedge_mesh/mutation/#deletions","text":"These routines delete mesh elements. Elements (like Vertex ) and containers (like VertexData <> ) will remain valid through deletions. However, performing any deletion will cause the mesh to no longer be compressed . Vertex HalfedgeMesh :: collapseEdge ( Edge e ) // Collapse an edge. Returns the vertex adjacent to that edge which still exists. Returns Vertex() if not // collapsible. Vertex collapseEdge(Edge e); bool HalfedgeMesh :: removeFaceAlongBoundary ( Face f ) // Remove a face which is adjacent to the boundary of the mesh (along with its edge on the boundary). // Face must have exactly one boundary edge. // Returns true if could remove bool removeFaceAlongBoundary(Face f);","title":"Deletions"},{"location":"surface/halfedge_mesh/mutation/#compressed-mode","text":"Internally, the halfedge mesh is represented by dense arrays of indices which are lazily expanded (see interals for details). To support fast deletion operations, we simply mark elements as deleted, without re-packing the index space. We say that the mesh is compressed if the index space is dense and there are no such marked elements. When a mesh is not compressed, the index of a mesh element no longer serves as a proper enumeration from [ 0 , N ) , but merely as a unique ID. There are two consequences to being non-compressed: Some operations cannot be implemented efficiently/correctly (e.g., random access of the i\u2019th vertex) Storage space is wasted by deleted elements All meshes are compressed after construction, and only become non-compressed if the user performs a deletion operation. The makeCompressed () function can be called to re-index the elements of the mesh as a proper enumeration from [ 0 , N ) . The makeCompressed () function invalidates pointers, and incurs an update of existing containers. As such, it is recommended to be called sporadically, after a sequence of operations is completed. bool HalfedgeMesh :: isCompressed () Returns true if the mesh is compressed. void HalfedgeMesh :: makeCompressed () Re-index the elements of the mesh to yield a dense enumeration. Invalidates all Vertex (etc) objects. Does nothing if the mesh is already compressed.","title":"Compressed mode"},{"location":"surface/halfedge_mesh/mutation/#dynamic-pointer-types","text":"A few of the operations listed below invalidate outstanding element references (like Halfedge ) by re-indexing the elements of the mesh. Containers automatically update after re-indexing, and often code can be structured such that no element references need to be maintained across an invalidation. However, if it is necessary to keep a reference to an element through a re-indexing, the DynamicHalfedge can be used. These types behave like a Halfedge , with the exception that they automatically update to remain valid when a mesh is re-indexed. These types should only be used when necessary, because they are expensive to maintain.","title":"Dynamic pointer types"},{"location":"surface/halfedge_mesh/navigation/","text":"Collection Iterators Use these routines to iterate over all of the elements in the mesh. Note: Generally, modifying the mesh in the midst of iteration is not supported. HalfedgeMesh :: vertices () Iterate over the vertices in a mesh. for ( Vertex v : mesh . vertices ()) { // do science here } HalfedgeMesh :: halfedges () Iterate over all of the halfedges in a mesh (both real and imaginary, if the mesh has boundary). for ( Halfedge he : mesh . halfedges ()) { // do science here } HalfedgeMesh :: realHalfedges () Iterate over the real halfedges in a mesh. for ( Halfedge he : mesh . realHalfedges ()) { // do science here } Note that on a boundary edge between vertices i < --> j , this set will only include a halfedge from i --> j , but not from j --> i (or vice versa). HalfedgeMesh :: imaginaryHalfedges () Iterate over the imaginary halfedges in a mesh. for ( Halfedge he : mesh . imaginaryHalfedges ()) { // do science here } Note that on a boundary edge between vertices i < --> j , this set will only include a halfedge from i --> j , but not from j --> i (or vice versa). HalfedgeMesh :: edges () Iterate over the edges in a mesh. for ( Edge e : mesh . edges ()) { // do science here } HalfedgeMesh :: faces () Iterate over the faces in a mesh. for ( Face f : mesh . faces ()) { // do science here } Neighborhood Iterators Use these routines to iterate over the neighbors of a mesh element. Note: neighborhoods on \\Delta \\Delta -complexes The iterators in this section may have unexpected behavior in the advanced case of a \\Delta \\Delta -complex, when there are (e.g.) self-edges, or multiple edges between a pair of vertices. Essentially, these iterators always naively traverse the local neighborhood, even if that neighborhood might include duplicate elements. For instance, if a \\Delta \\Delta -complex has multiple edges connecting vertex va to vertex vb , then iterating va . adjacentVertices () will return vb multiple times. Of course, for ordinary triangle mesh they will behave as expected. See the Delta complex section for more information. Around a vertex Vertex :: outgoingHalfedges () Iterate over the halfedges which point outward from a vertex. for ( Halfedge he : vert . outgoingHalfedges ()) { assert ( he . vertex () == vert ); // true // do science here } Vertex :: incomingHalfedges () Iterate over the halfedges which point inward at a vertex. for ( Halfedge he : vert . incomingHalfedges ()) { assert ( he . twin (). vertex () == vert ); // true // do science here } Vertex :: adjacentVertices () Iterate over the vertices edge-connected to this vertex. for ( Vertex v : vert . adjacentVertices ()) { // do science here } Vertex :: adjacentEdges () Iterate over the edges incident on this vertex. for ( Edge e : vert . adjacentEdges ()) { // do science here } Vertex :: adjacentFaces () Iterate over the faces incident on this vertex. for ( Face f : vert . adjacentFaces ()) { // do science here } Around an edge Edge :: adjacentHalfedges () Iterate over the two halfedges incident on this edge. for ( Halfedge he : edge . adjacentHalfedges ()) { // do science here } Edge :: adjacentFaces () Iterate over the (one or two) faces incident on this edge. for ( Face f : edge . adjacentFaces ()) { // do science here } Around a face Face :: adjacentVertices () Iterate over the vertices adjacent to a face. for ( Vertex v : face . adjacentVertices ()) { // do science here } Face :: adjacentHalfedges () Iterate over the halfedges incident on a face. for ( Halfedge he : face . adjacentHalfedges ()) { // do science here } Face :: adjacentEdges () Iterate over the edges on the boundary of a face. for ( Edge e : face . adjacentEdges ()) { // do science here } Face :: adjacentFaces () Iterate over the faces adjacent to a face, across each edge. for ( Face f : face . adjacentFaces ()) { // do science here } Around a boundary loop BoundaryLoop :: adjacentVertices () Iterate over the vertices adjacent to a boundary loop. for ( Vertex v : boundaryLoop . adjacentVertices ()) { // do science here } BoundaryLoop :: adjacentHalfedges () Iterate over the (exterior) halfedges incident on a boundary loop. for ( Halfedge he : boundaryLoop . adjacentHalfedges ()) { // do science here } BoundaryLoop :: adjacentEdges () Iterate over the edges on the boundary of a boundary loop. for ( Edge e : boundaryLoop . adjacentEdges ()) { // do science here } Accessors Use these routines to access elements of the mesh by their index. Warning The indexing routines in the section are only valid when the mesh is compressed . Halfedge HalfedgeMesh :: halfedge ( size_t index ) Constructs a reference to the i\u2019th halfedge in the mesh. 0 <= index < nHalfedges () . Vertex HalfedgeMesh :: vertex ( size_t index ) Constructs a reference to the i\u2019th vertex in the mesh. 0 <= index < nVertices () . Face HalfedgeMesh :: face ( size_t index ) Constructs a reference to the i\u2019th face in the mesh. 0 <= index < nFaces () . Edge HalfedgeMesh :: edge ( size_t index ) Constructs a reference to the i\u2019th edge in the mesh. 0 <= index < nEdges () . Face HalfedgeMesh :: face ( size_t index ) Constructs a reference to the i\u2019th face in the mesh. 0 <= index < nFaces () . Face HalfedgeMesh :: boundaryLoop ( size_t index ) Constructs a reference to the i\u2019th boundary loop in the mesh. 0 <= index < nBoundaryLoops () .","title":"Navigation and Iteration"},{"location":"surface/halfedge_mesh/navigation/#collection-iterators","text":"Use these routines to iterate over all of the elements in the mesh. Note: Generally, modifying the mesh in the midst of iteration is not supported. HalfedgeMesh :: vertices () Iterate over the vertices in a mesh. for ( Vertex v : mesh . vertices ()) { // do science here } HalfedgeMesh :: halfedges () Iterate over all of the halfedges in a mesh (both real and imaginary, if the mesh has boundary). for ( Halfedge he : mesh . halfedges ()) { // do science here } HalfedgeMesh :: realHalfedges () Iterate over the real halfedges in a mesh. for ( Halfedge he : mesh . realHalfedges ()) { // do science here } Note that on a boundary edge between vertices i < --> j , this set will only include a halfedge from i --> j , but not from j --> i (or vice versa). HalfedgeMesh :: imaginaryHalfedges () Iterate over the imaginary halfedges in a mesh. for ( Halfedge he : mesh . imaginaryHalfedges ()) { // do science here } Note that on a boundary edge between vertices i < --> j , this set will only include a halfedge from i --> j , but not from j --> i (or vice versa). HalfedgeMesh :: edges () Iterate over the edges in a mesh. for ( Edge e : mesh . edges ()) { // do science here } HalfedgeMesh :: faces () Iterate over the faces in a mesh. for ( Face f : mesh . faces ()) { // do science here }","title":"Collection Iterators"},{"location":"surface/halfedge_mesh/navigation/#neighborhood-iterators","text":"Use these routines to iterate over the neighbors of a mesh element. Note: neighborhoods on \\Delta \\Delta -complexes The iterators in this section may have unexpected behavior in the advanced case of a \\Delta \\Delta -complex, when there are (e.g.) self-edges, or multiple edges between a pair of vertices. Essentially, these iterators always naively traverse the local neighborhood, even if that neighborhood might include duplicate elements. For instance, if a \\Delta \\Delta -complex has multiple edges connecting vertex va to vertex vb , then iterating va . adjacentVertices () will return vb multiple times. Of course, for ordinary triangle mesh they will behave as expected. See the Delta complex section for more information.","title":"Neighborhood Iterators"},{"location":"surface/halfedge_mesh/navigation/#around-a-vertex","text":"Vertex :: outgoingHalfedges () Iterate over the halfedges which point outward from a vertex. for ( Halfedge he : vert . outgoingHalfedges ()) { assert ( he . vertex () == vert ); // true // do science here } Vertex :: incomingHalfedges () Iterate over the halfedges which point inward at a vertex. for ( Halfedge he : vert . incomingHalfedges ()) { assert ( he . twin (). vertex () == vert ); // true // do science here } Vertex :: adjacentVertices () Iterate over the vertices edge-connected to this vertex. for ( Vertex v : vert . adjacentVertices ()) { // do science here } Vertex :: adjacentEdges () Iterate over the edges incident on this vertex. for ( Edge e : vert . adjacentEdges ()) { // do science here } Vertex :: adjacentFaces () Iterate over the faces incident on this vertex. for ( Face f : vert . adjacentFaces ()) { // do science here }","title":"Around a vertex"},{"location":"surface/halfedge_mesh/navigation/#around-an-edge","text":"Edge :: adjacentHalfedges () Iterate over the two halfedges incident on this edge. for ( Halfedge he : edge . adjacentHalfedges ()) { // do science here } Edge :: adjacentFaces () Iterate over the (one or two) faces incident on this edge. for ( Face f : edge . adjacentFaces ()) { // do science here }","title":"Around an edge"},{"location":"surface/halfedge_mesh/navigation/#around-a-face","text":"Face :: adjacentVertices () Iterate over the vertices adjacent to a face. for ( Vertex v : face . adjacentVertices ()) { // do science here } Face :: adjacentHalfedges () Iterate over the halfedges incident on a face. for ( Halfedge he : face . adjacentHalfedges ()) { // do science here } Face :: adjacentEdges () Iterate over the edges on the boundary of a face. for ( Edge e : face . adjacentEdges ()) { // do science here } Face :: adjacentFaces () Iterate over the faces adjacent to a face, across each edge. for ( Face f : face . adjacentFaces ()) { // do science here }","title":"Around a face"},{"location":"surface/halfedge_mesh/navigation/#around-a-boundary-loop","text":"BoundaryLoop :: adjacentVertices () Iterate over the vertices adjacent to a boundary loop. for ( Vertex v : boundaryLoop . adjacentVertices ()) { // do science here } BoundaryLoop :: adjacentHalfedges () Iterate over the (exterior) halfedges incident on a boundary loop. for ( Halfedge he : boundaryLoop . adjacentHalfedges ()) { // do science here } BoundaryLoop :: adjacentEdges () Iterate over the edges on the boundary of a boundary loop. for ( Edge e : boundaryLoop . adjacentEdges ()) { // do science here }","title":"Around a boundary loop"},{"location":"surface/halfedge_mesh/navigation/#accessors","text":"Use these routines to access elements of the mesh by their index. Warning The indexing routines in the section are only valid when the mesh is compressed . Halfedge HalfedgeMesh :: halfedge ( size_t index ) Constructs a reference to the i\u2019th halfedge in the mesh. 0 <= index < nHalfedges () . Vertex HalfedgeMesh :: vertex ( size_t index ) Constructs a reference to the i\u2019th vertex in the mesh. 0 <= index < nVertices () . Face HalfedgeMesh :: face ( size_t index ) Constructs a reference to the i\u2019th face in the mesh. 0 <= index < nFaces () . Edge HalfedgeMesh :: edge ( size_t index ) Constructs a reference to the i\u2019th edge in the mesh. 0 <= index < nEdges () . Face HalfedgeMesh :: face ( size_t index ) Constructs a reference to the i\u2019th face in the mesh. 0 <= index < nFaces () . Face HalfedgeMesh :: boundaryLoop ( size_t index ) Constructs a reference to the i\u2019th boundary loop in the mesh. 0 <= index < nBoundaryLoops () .","title":"Accessors"},{"location":"surface/utilities/io/","text":"Reading meshes Construct a halfedge mesh from a file on disk. # include \" geometrycentral/surface/meshio.h \" Example usage: #include \"geometrycentral/surface/meshio.h\" using namespace geometrycentral :: surface ; std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( \"spot.obj\" ); std :: tuple < std :: unique_ptr < HalfedgeMesh > , std :: unique_ptr < VertexPositionGeometry >> loadMesh ( std :: string filename , std :: string type = \"\" ) Load a mesh from file. Returns both a HalfedgeMesh representing the connectivity, and a Geometry representing the geometry. See example below to concisely unpack. If the file includes vertices which do not appear in any face, they will be stripped from the vertex listing and ignored. The type parameter determines the type of file to load. For example, type = \"ply\" will attempt to read the target file as a .ply file. If no type is given, the type will be inferred from the file name. Currently the following types are supported: obj ply (using hapPLY ) Writing meshes TODO Serializing containers Data stored in MeshData <> containers can be automatically written and loaded from file. Internally, data is stored as additional custom fields of a .ply file. Here, we\u2019re using the .ply format as a general container for structured data\u2014other software may not automatically understand the additional fields in these files. The PlyHalfedgeMeshData class is used to read and write these souped-up .ply files, and is distinct from the simple mesh-loading .ply interface above. # include \" geometrycentral/surface/ply_halfedge_mesh_data.h \" Example usage: TODO #include \"geometrycentral/surface/ply_halfedge_mesh_data.h\" using namespace geometrycentral :: surface ; // Open a file and load the mesh therein std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: unique_ptr < PlyHalfedgeMeshData > plyData ; std :: tie ( mesh , geometry ) = PlyHalfedgeMeshData :: loadMeshAndData ( \"archive.ply\" ); // Read a stored value FaceData < double > faceValues = plyData -> getFaceProperty < double > ( \"name_a\" ); // Do some science CornerData < double > cornerValues = /* something important */ EdgeData < int > edgeValues = /* something else important */ // Add these values to the reader/writer // note: alternately could create a new record like // PlyHalfedgeMeshData newData(*mesh); plyData -> addCornerProperty ( \"name_b\" , cornerValues ); plyData -> addEdgeProperty ( \"name_c\" , edgeValues ); // Write the data to file plyData -> write ( \"new_archive.ply\" ) PlyHalfedgeMeshData :: PlyHalfedgeMeshData ( HalfedgeMesh & mesh , std :: string filename , bool verbose = false ) Open a ply file, and interpret its fields as living on the existing halfedge mesh mesh . Any read properties will be returned in containers defined on mesh . PlyHalfedgeMeshData :: PlyHalfedgeMeshData ( HalfedgeMesh & mesh_ , bool verbose = false ) Construct from an existing mesh. The mesh connectivity will be included when writing the file. static std :: tuple < std :: unique_ptr < HalfedgeMesh > , std :: unique_ptr < PlyHalfedgeMeshData >> PlyHalfedgeMeshData :: loadMeshAndData ( std :: string filename , bool verbose = false ) Convenience factory function to open a .ply file and load the mesh contained within, as well as creating a PlyHalfedgeMeshData reader/writer to access any other properties stored in the file. void PlyHalfedgeMeshData :: write ( std :: string filename ) Write the object to file. The binary/ascii writing mode is determined by the PlyHalfedgeMeshData :: outputFormat option. Note that if this reader/writer was created by loading a file, and is later written using write () all fields from the initial file will be automatically written out. Writing properties These methods add properties to the PlyHalfedgeMeshData object, which will be written when write () is called. The set of scalar types supported is the same as the .ply format, including list types. For instance, a property of type double on vertices could written to a new ply file with. PlyHalfedgeMeshData data ( mesh ); VertexData < double > values = /* incredibly important data */ data . addVertexProperty ( \"important_values\" , values ); data . write ( \"my_file.ply\" ); void PlyHalfedgeMeshData :: addVertexProperty <> ( std :: string name , const VertexData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a VertexData < double > . void PlyHalfedgeMeshData :: addHalfedgeProperty <> ( std :: string name , const HalfedgeData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a HalfedgeData < double > . void PlyCornerMeshData :: addCornerProperty <> ( std :: string name , const CornerData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a CornerData < double > . void PlyHalfedgeMeshData :: addEdgeProperty <> ( std :: string name , const EdgeData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a EdgeData < double > . void PlyHalfedgeMeshData :: addFaceProperty <> ( std :: string name , const FaceData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a FaceData < double > . void PlyHalfedgeMeshData :: addBoundaryLoopProperty <> ( std :: string name , const BoundaryLoopData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a BoundaryLoopData < double > . void PlyHalfedgeMeshData :: addGeometry ( const Geometry < Euclidean >& geometry ) Add geometry to the record, which will written as double vertex coordinates properties named \u201cx\u201d, \u201cy\u201d, and \u201cz\u201d. Reading properties These methods read properties from the PlyHalfedgeMeshData object, which exist either because they were read from an opened file, or because they were previously added with the add___ () functions above. The template argument to this function will likely be necessary to resolve the expected type of the data. For instance, a property of type double on vertices could be accessed with. PlyHalfedgeMeshData data ( mesh , \"my_file.ply\" ); VertexData < double > values = data . getVertexProperty < double > ( \"important_values\" ); The automatic type promotion in hapPLY gives some flexibility in specifying the type of the read data\u2014 for instance if property \"propName\" in the example above was stored as a float , it could still be read as a double . See the documentation there for details. VertexData < T > PlyHalfedgeMeshData :: getVertexProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. HalfedgeData < T > PlyHalfedgeMeshData :: getHalfedgeProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. CornerData < T > PlyCornerMeshData :: getCornerProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. EdgeData < T > PlyHalfedgeMeshData :: getEdgeProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. FaceData < T > PlyHalfedgeMeshData :: getFaceProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. BoundaryLoopData < T > PlyHalfedgeMeshData :: getBoundaryLoopProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. std :: unique_ptr < Geometry < Euclidean >> PlyHalfedgeMeshData :: getGeometry () Build a geometry object from vertex postions stored in a file. Storing Delta-complexes Most mesh file formats store connectivity via a face-vertex list; this format used by default in all IO functions above. However, this format is insufficient for representing more general \\Delta \\Delta -complexes. To support IO for \\Delta \\Delta -complexes, connectivity can instead be encoded via halfedge adjacency indices as described in the Internals section. This representation has the additional advantage that loading halfedge meshes will be very fast, as no connectivity needs to be detected. The .ply readers automatically support reading this format. The option below enables writing .ply files in this format via the PlyHalfedgeMeshData class. bool PlyHalfedgeMeshData :: useHalfedgeAdjacency If true, writing will produce a .ply file which stores connectivity using haflfedge permutation indices rather than the usual face-vertex list. Default value: false .","title":"I/O"},{"location":"surface/utilities/io/#reading-meshes","text":"Construct a halfedge mesh from a file on disk. # include \" geometrycentral/surface/meshio.h \" Example usage: #include \"geometrycentral/surface/meshio.h\" using namespace geometrycentral :: surface ; std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: tie ( mesh , geometry ) = loadMesh ( \"spot.obj\" ); std :: tuple < std :: unique_ptr < HalfedgeMesh > , std :: unique_ptr < VertexPositionGeometry >> loadMesh ( std :: string filename , std :: string type = \"\" ) Load a mesh from file. Returns both a HalfedgeMesh representing the connectivity, and a Geometry representing the geometry. See example below to concisely unpack. If the file includes vertices which do not appear in any face, they will be stripped from the vertex listing and ignored. The type parameter determines the type of file to load. For example, type = \"ply\" will attempt to read the target file as a .ply file. If no type is given, the type will be inferred from the file name. Currently the following types are supported: obj ply (using hapPLY )","title":"Reading meshes"},{"location":"surface/utilities/io/#writing-meshes","text":"TODO","title":"Writing meshes"},{"location":"surface/utilities/io/#serializing-containers","text":"Data stored in MeshData <> containers can be automatically written and loaded from file. Internally, data is stored as additional custom fields of a .ply file. Here, we\u2019re using the .ply format as a general container for structured data\u2014other software may not automatically understand the additional fields in these files. The PlyHalfedgeMeshData class is used to read and write these souped-up .ply files, and is distinct from the simple mesh-loading .ply interface above. # include \" geometrycentral/surface/ply_halfedge_mesh_data.h \" Example usage: TODO #include \"geometrycentral/surface/ply_halfedge_mesh_data.h\" using namespace geometrycentral :: surface ; // Open a file and load the mesh therein std :: unique_ptr < HalfedgeMesh > mesh ; std :: unique_ptr < VertexPositionGeometry > geometry ; std :: unique_ptr < PlyHalfedgeMeshData > plyData ; std :: tie ( mesh , geometry ) = PlyHalfedgeMeshData :: loadMeshAndData ( \"archive.ply\" ); // Read a stored value FaceData < double > faceValues = plyData -> getFaceProperty < double > ( \"name_a\" ); // Do some science CornerData < double > cornerValues = /* something important */ EdgeData < int > edgeValues = /* something else important */ // Add these values to the reader/writer // note: alternately could create a new record like // PlyHalfedgeMeshData newData(*mesh); plyData -> addCornerProperty ( \"name_b\" , cornerValues ); plyData -> addEdgeProperty ( \"name_c\" , edgeValues ); // Write the data to file plyData -> write ( \"new_archive.ply\" ) PlyHalfedgeMeshData :: PlyHalfedgeMeshData ( HalfedgeMesh & mesh , std :: string filename , bool verbose = false ) Open a ply file, and interpret its fields as living on the existing halfedge mesh mesh . Any read properties will be returned in containers defined on mesh . PlyHalfedgeMeshData :: PlyHalfedgeMeshData ( HalfedgeMesh & mesh_ , bool verbose = false ) Construct from an existing mesh. The mesh connectivity will be included when writing the file. static std :: tuple < std :: unique_ptr < HalfedgeMesh > , std :: unique_ptr < PlyHalfedgeMeshData >> PlyHalfedgeMeshData :: loadMeshAndData ( std :: string filename , bool verbose = false ) Convenience factory function to open a .ply file and load the mesh contained within, as well as creating a PlyHalfedgeMeshData reader/writer to access any other properties stored in the file. void PlyHalfedgeMeshData :: write ( std :: string filename ) Write the object to file. The binary/ascii writing mode is determined by the PlyHalfedgeMeshData :: outputFormat option. Note that if this reader/writer was created by loading a file, and is later written using write () all fields from the initial file will be automatically written out.","title":"Serializing containers"},{"location":"surface/utilities/io/#writing-properties","text":"These methods add properties to the PlyHalfedgeMeshData object, which will be written when write () is called. The set of scalar types supported is the same as the .ply format, including list types. For instance, a property of type double on vertices could written to a new ply file with. PlyHalfedgeMeshData data ( mesh ); VertexData < double > values = /* incredibly important data */ data . addVertexProperty ( \"important_values\" , values ); data . write ( \"my_file.ply\" ); void PlyHalfedgeMeshData :: addVertexProperty <> ( std :: string name , const VertexData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a VertexData < double > . void PlyHalfedgeMeshData :: addHalfedgeProperty <> ( std :: string name , const HalfedgeData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a HalfedgeData < double > . void PlyCornerMeshData :: addCornerProperty <> ( std :: string name , const CornerData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a CornerData < double > . void PlyHalfedgeMeshData :: addEdgeProperty <> ( std :: string name , const EdgeData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a EdgeData < double > . void PlyHalfedgeMeshData :: addFaceProperty <> ( std :: string name , const FaceData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a FaceData < double > . void PlyHalfedgeMeshData :: addBoundaryLoopProperty <> ( std :: string name , const BoundaryLoopData <>& data ) Add a property for writing. name A user-defined name with which the property will be written to file. Must be unique within the file. data The data to be written, such a BoundaryLoopData < double > . void PlyHalfedgeMeshData :: addGeometry ( const Geometry < Euclidean >& geometry ) Add geometry to the record, which will written as double vertex coordinates properties named \u201cx\u201d, \u201cy\u201d, and \u201cz\u201d.","title":"Writing properties"},{"location":"surface/utilities/io/#reading-properties","text":"These methods read properties from the PlyHalfedgeMeshData object, which exist either because they were read from an opened file, or because they were previously added with the add___ () functions above. The template argument to this function will likely be necessary to resolve the expected type of the data. For instance, a property of type double on vertices could be accessed with. PlyHalfedgeMeshData data ( mesh , \"my_file.ply\" ); VertexData < double > values = data . getVertexProperty < double > ( \"important_values\" ); The automatic type promotion in hapPLY gives some flexibility in specifying the type of the read data\u2014 for instance if property \"propName\" in the example above was stored as a float , it could still be read as a double . See the documentation there for details. VertexData < T > PlyHalfedgeMeshData :: getVertexProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. HalfedgeData < T > PlyHalfedgeMeshData :: getHalfedgeProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. CornerData < T > PlyCornerMeshData :: getCornerProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. EdgeData < T > PlyHalfedgeMeshData :: getEdgeProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. FaceData < T > PlyHalfedgeMeshData :: getFaceProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. BoundaryLoopData < T > PlyHalfedgeMeshData :: getBoundaryLoopProperty < T > ( std :: string name ) Read a property from a loaded file. name A user-defined name with which the property will be read from the file. Throws if no such property exists. Return: The requested container. std :: unique_ptr < Geometry < Euclidean >> PlyHalfedgeMeshData :: getGeometry () Build a geometry object from vertex postions stored in a file.","title":"Reading properties"},{"location":"surface/utilities/io/#storing-delta-complexes","text":"Most mesh file formats store connectivity via a face-vertex list; this format used by default in all IO functions above. However, this format is insufficient for representing more general \\Delta \\Delta -complexes. To support IO for \\Delta \\Delta -complexes, connectivity can instead be encoded via halfedge adjacency indices as described in the Internals section. This representation has the additional advantage that loading halfedge meshes will be very fast, as no connectivity needs to be detected. The .ply readers automatically support reading this format. The option below enables writing .ply files in this format via the PlyHalfedgeMeshData class. bool PlyHalfedgeMeshData :: useHalfedgeAdjacency If true, writing will produce a .ply file which stores connectivity using haflfedge permutation indices rather than the usual face-vertex list. Default value: false .","title":"Storing Delta-complexes"},{"location":"surface/utilities/surface_point/","text":"A SurfacePoint is a generic location on a surface, which might be at a vertex, along an edge, or inside a face. Surface points are used throughout geometry-central for methods that input or output arbitrary locations on surfaces. # include \" geometrycentral/surface/surface_point.h \" The field SurfacePoint :: type is an enum: enum class SurfacePointType { Vertex = 0 , Edge , Face }; which indicates what kind of point this is. if the surface point is a vertex , the field SurfacePoint :: vertex indicates which vertex. Otherwise it is the null default vertex. if the surface point is along an edge , the field SurfacePoint :: edge indicates which edge. Otherwise it is the null default edge. The field SurfacePoint :: tEdge indicates the location along that edge, in the range [ 0 , 1 ] , with 0 at edge . halfedge (). vertex () . if the surface point is inside a face , the field SurfacePoint :: face indicates which face. Otherwise it is the null default face. The field SurfacePoint :: faceCoords indicates the location inside that face, as barycentric coordinates (numbered according to the iteration order of vertices about the face, as usual). Surface points have a few useful utility methods: T SurfacePoint :: interpolate ( const VertexData < T >& data ) Given data of tempalte type T defined at vertices, linearly interpolates to a value at this location. SurfacePoint SurfacePoint :: inSomeFace () All surface points (vertex, edge, face) have an equivalent point in one or many adjacent faces. For instance, a vertex could be equivalently a point in any of the incident faces, with a single 1 barycentric coordinate, or a point on an edge could be a point in either of the two adjacent faces. This function returns one of the equivalent surface points in a face (chosen arbitrarily). If this point is a face point, the output is a copy of this point. Vertex SurfacePoint :: nearestVertex () Returns the nearest vertex which is adjacent to this point. For surface points which are vertices, it will return the same vertex. For surface points which are along edges, it will return one of the two incident vertices. For surface points which are inside faces, it will return one of the three incident vertices.","title":"Surface Point"},{"location":"tutorials/load_mesh/","text":"","title":"Load mesh"},{"location":"utilities/miscellaneous/","text":"Miscellaneous utility functions. #include \"geometrycentral/utilities.h\" Constants size_t INVALID_IND Used to represent invalid indices. Defined as std :: numeric_limits < size_t > :: max () double PI Defined to be 3 . Just kidding. Angles and arithmetic T clamp ( T val , T low , T high ) Returns val clamped to lie bewteen low and high (using comparison operators). double regularizeAngle ( double theta ) Shifts an angle to lie in the range [ 0 0 , 2 \\pi 2 \\pi ]. Random numbers All random values are drawn from a generator seeded at program initialization. The generator is seeded via std :: random_device , so results will not be consistent between repeated runs of the program. double unitRand () Returns a uniformly-distributed value on [0,1] [0,1] . double randomReal () Returns a uniformly-distributed value on [0,1] [0,1] . double randomNormal ( double mean = 0.0 , double stddev = 1.0 ) Returns a normally-distributed value from the specified mean and variance. int randomInt ( int lower , int upper ) Returns a uniformly-distributed integer on the INCLUSIVE range [ lower , upper ] size_t randomIndex ( size_t size ) Returns a uniformly-distributed integer on the range [ 0 , size ) . Indices and lists std :: vector < T > applyPermutation ( const std :: vector < T >& sourceData , const std :: vector < size_t >& permOldToNew ) Apply a permutation to reorder a vector, such that output [ i ] = sourceData [ permOldToNew[i ] ] . The permutation should be an injection to [ 0 , sourceData . size ()) . The sourceData , permOldToNew , and the output should all have same size. Printing and strings std :: string to_string ( std :: vector < T > const & v ) Print the elements of vector to a string using the << operator for each element. std :: string str_printf ( const std :: string & format , Args ... args ) Print directly to a string, where format and args obey printf semantics. Memory management void safeDelete ( T *& x ) Call delete on a pointer. If the pointer is nullptr , does nothing. If it is non-null, sets to nullptr after deleting. void safeDeleteArray ( T *& x ) Like safeDelete () , but for arrays. Type names Useful for debugging templated code. Uses typeid () from < typeinfo > . std :: string typeNameString ( T & x ) Returns the name of a type as a string. std :: string typeNameString ( T * x ) Like typeNameString ( T & x ) , but for pointers.","title":"Miscellaneous"},{"location":"utilities/miscellaneous/#constants","text":"size_t INVALID_IND Used to represent invalid indices. Defined as std :: numeric_limits < size_t > :: max () double PI Defined to be 3 . Just kidding.","title":"Constants"},{"location":"utilities/miscellaneous/#angles-and-arithmetic","text":"T clamp ( T val , T low , T high ) Returns val clamped to lie bewteen low and high (using comparison operators). double regularizeAngle ( double theta ) Shifts an angle to lie in the range [ 0 0 , 2 \\pi 2 \\pi ].","title":"Angles and arithmetic"},{"location":"utilities/miscellaneous/#random-numbers","text":"All random values are drawn from a generator seeded at program initialization. The generator is seeded via std :: random_device , so results will not be consistent between repeated runs of the program. double unitRand () Returns a uniformly-distributed value on [0,1] [0,1] . double randomReal () Returns a uniformly-distributed value on [0,1] [0,1] . double randomNormal ( double mean = 0.0 , double stddev = 1.0 ) Returns a normally-distributed value from the specified mean and variance. int randomInt ( int lower , int upper ) Returns a uniformly-distributed integer on the INCLUSIVE range [ lower , upper ] size_t randomIndex ( size_t size ) Returns a uniformly-distributed integer on the range [ 0 , size ) .","title":"Random numbers"},{"location":"utilities/miscellaneous/#indices-and-lists","text":"std :: vector < T > applyPermutation ( const std :: vector < T >& sourceData , const std :: vector < size_t >& permOldToNew ) Apply a permutation to reorder a vector, such that output [ i ] = sourceData [ permOldToNew[i ] ] . The permutation should be an injection to [ 0 , sourceData . size ()) . The sourceData , permOldToNew , and the output should all have same size.","title":"Indices and lists"},{"location":"utilities/miscellaneous/#printing-and-strings","text":"std :: string to_string ( std :: vector < T > const & v ) Print the elements of vector to a string using the << operator for each element. std :: string str_printf ( const std :: string & format , Args ... args ) Print directly to a string, where format and args obey printf semantics.","title":"Printing and strings"},{"location":"utilities/miscellaneous/#memory-management","text":"void safeDelete ( T *& x ) Call delete on a pointer. If the pointer is nullptr , does nothing. If it is non-null, sets to nullptr after deleting. void safeDeleteArray ( T *& x ) Like safeDelete () , but for arrays.","title":"Memory management"},{"location":"utilities/miscellaneous/#type-names","text":"Useful for debugging templated code. Uses typeid () from < typeinfo > . std :: string typeNameString ( T & x ) Returns the name of a type as a string. std :: string typeNameString ( T * x ) Like typeNameString ( T & x ) , but for pointers.","title":"Type names"},{"location":"utilities/vector2/","text":"geometrycentral :: Vector2 is the basic 2D vector type in geometry central. Like a good turkey sandwich, it aims to be unsurprising yet satisfying. Of particular interest, Vector2 is also used to encode 2D rotations, by supporting multiplication as a complex number. See the rotations section . #include \"geometrycentral/vector2.h\" Construction Vector2 is a POD type, so you should use brace-initialization sytax: #include \"geometrycentral/vector2.h using namespace geometrycentral ; Vector2 myVec { 3.8 , 2.9 }; //create myVec = Vector2 { 1.1 , 2.2 }; // reassign Factory methods can construct a few common values: static Vector2 Vector2 :: zero () Returns the zero vector static Vector2 Vector2 :: constant ( double c ) Returns a vector with all components set to c c static Vector2 Vector2 :: infinity () Returns the infinite vector (\\infty, \\infty) (\\infty, \\infty) . static Vector2 Vector2 :: undefined () Returns the undefined vector ( NaN , NaN ) . And serve as constructors: static Vector2 Vector2 :: fromAngle ( double theta ) Returns the vector (\\cos(\\theta), \\sin(\\theta)) (\\cos(\\theta), \\sin(\\theta)) . static Vector2 Vector2 :: fromComplex ( std :: complex < double > c ) Converts a std :: complex < double > to a Vector2 . Access The two elements of the vector can be accessed as vec . x and vec . y . Alternately, the two elements can be indexed as vec [ 0 ] and vec [ 1 ] . Conversion Vector2 :: operator std :: complex < double > () Vector2 is implicitly convertible to std :: complex < double > . Vector2 :: operator << () Vector2 can be serialized. Vector2 v { 1.2 , 3.4 }; std :: cout << v << std :: endl ; // prints something like: <1.2, 3.4> Arithmetic Vector2 supports the element-wise addition, subraction, and scalar multiplication you would probably expect. Rotations and complex multiplication Our Vector2 types further obey the multiplication and division rules of complex arithmetic, and thus can be used to represent rotations. For instance, a unit 2D vector representing a rotation can be used to rotate another vector like: Vector2 v = /* your vector */ Vector2 r = Vector2 :: fromAngle ( PI / 4 ); // rotation by 45 degrees Vector2 vRot = r * v ; This is fundamentally no different from using 2x2 rotation matrices, but leads to much cleaner code (try using division to compute relative rotations!). Member operations These methods do not change the underlying Vector2 , but return a new Vector2 . Vector2 vec { 1. , 2. }; vec . rotate90 (); // does nothing vec = vec . rotate90 (); // much better Vector2 Vector2 :: normalize () Returns a unit-norm vector with the same direction. If the input is the zero vector, the result will contain NaNs. Vector2 Vector2 :: rotate ( double theta ) Rotate the vector by angle \\theta \\theta in the counter-clockwise direction. Vector2 Vector2 :: rotate90 () Rotate the vector by 90^{\\circ} 90^{\\circ} in the counter-clockwise direction. Vector2 Vector2 :: pow ( double p ) Raise the vector to a real power, in the sense of complex arithmetic. (see std::pow ) Vector2 Vector2 :: pow ( Vector2 p ) Raise the vector to a complex power, in the sense of complex arithmetic. (see std::pow ) Vector2 Vector2 :: conj () Transform the vector to its complex conjugate, negating the y component. Vector2 Vector2 :: inv () Invert the vector, in the sense of complex arithmetic. Equivalent to Vector2 { 1 ., 0 . } / v . Function operations These operations do not change the vector on which they are called. double norm ( Vector2 v ) Returns the magnitude of the vector. Also available as v . norm () . double norm2 ( Vector2 v ) Returns the squared magnitude of the vector. Also available as v . norm () . Vector2 unit ( Vector2 v ) Returns normalized copy of the vector. double arg ( Vector2 v ) Returns the argument in the sense of complex arithmetic (i.e., the angle against the x x -axis). Also available as v . arg () . double dot ( Vector2 u , Vector2 v ) Returns the dot product between two vectors. double cross ( Vector2 u , Vector2 v ) Returns the \u201ccross\u201d product between two vectors, that is u . x * v . y - u . y * v . x . Intuitively, the z z -component of the 3D cross product of vectors in the plane. Vector3 cross3 ( Vector2 u , Vector2 v ) Returns the 3D cross product of vectors in the plane. double angle ( Vector2 u , Vector2 v ) Returns the angle between two not-necessarily-unit vectors. Output in the range [0, \\pi] [0, \\pi] . Vector2 clamp ( Vector2 val , Vector2 low , Vector2 high ) Returns returns a a vector where each component has been clamped to be between the corresponding compnents of low and high . Vector2 componentwiseMin ( Vector2 u , Vector2 v ) Returns a new vector, each component of which is the minimum of that component in u and v . Vector2 componentwiseMax ( Vector2 u , Vector2 v ) Returns a new vector, each component of which is the maximum of that component in u and v . Properties bool isfinite ( Vector2 u ) Returns true if both of the components of the vector are finite. Note: this function is intentionally not camel-cased out of solidarity with std :: isfinite () . Also available as u . isFinite () . bool isDefined ( Vector2 u ) Returns true if both of the components of the vector are not NaN. Also available as u . isDefined () .","title":"Vector2"},{"location":"utilities/vector2/#construction","text":"Vector2 is a POD type, so you should use brace-initialization sytax: #include \"geometrycentral/vector2.h using namespace geometrycentral ; Vector2 myVec { 3.8 , 2.9 }; //create myVec = Vector2 { 1.1 , 2.2 }; // reassign Factory methods can construct a few common values: static Vector2 Vector2 :: zero () Returns the zero vector static Vector2 Vector2 :: constant ( double c ) Returns a vector with all components set to c c static Vector2 Vector2 :: infinity () Returns the infinite vector (\\infty, \\infty) (\\infty, \\infty) . static Vector2 Vector2 :: undefined () Returns the undefined vector ( NaN , NaN ) . And serve as constructors: static Vector2 Vector2 :: fromAngle ( double theta ) Returns the vector (\\cos(\\theta), \\sin(\\theta)) (\\cos(\\theta), \\sin(\\theta)) . static Vector2 Vector2 :: fromComplex ( std :: complex < double > c ) Converts a std :: complex < double > to a Vector2 .","title":"Construction"},{"location":"utilities/vector2/#access","text":"The two elements of the vector can be accessed as vec . x and vec . y . Alternately, the two elements can be indexed as vec [ 0 ] and vec [ 1 ] .","title":"Access"},{"location":"utilities/vector2/#conversion","text":"Vector2 :: operator std :: complex < double > () Vector2 is implicitly convertible to std :: complex < double > . Vector2 :: operator << () Vector2 can be serialized. Vector2 v { 1.2 , 3.4 }; std :: cout << v << std :: endl ; // prints something like: <1.2, 3.4>","title":"Conversion"},{"location":"utilities/vector2/#arithmetic","text":"Vector2 supports the element-wise addition, subraction, and scalar multiplication you would probably expect.","title":"Arithmetic"},{"location":"utilities/vector2/#rotations-and-complex-multiplication","text":"Our Vector2 types further obey the multiplication and division rules of complex arithmetic, and thus can be used to represent rotations. For instance, a unit 2D vector representing a rotation can be used to rotate another vector like: Vector2 v = /* your vector */ Vector2 r = Vector2 :: fromAngle ( PI / 4 ); // rotation by 45 degrees Vector2 vRot = r * v ; This is fundamentally no different from using 2x2 rotation matrices, but leads to much cleaner code (try using division to compute relative rotations!).","title":"Rotations and complex multiplication"},{"location":"utilities/vector2/#member-operations","text":"These methods do not change the underlying Vector2 , but return a new Vector2 . Vector2 vec { 1. , 2. }; vec . rotate90 (); // does nothing vec = vec . rotate90 (); // much better Vector2 Vector2 :: normalize () Returns a unit-norm vector with the same direction. If the input is the zero vector, the result will contain NaNs. Vector2 Vector2 :: rotate ( double theta ) Rotate the vector by angle \\theta \\theta in the counter-clockwise direction. Vector2 Vector2 :: rotate90 () Rotate the vector by 90^{\\circ} 90^{\\circ} in the counter-clockwise direction. Vector2 Vector2 :: pow ( double p ) Raise the vector to a real power, in the sense of complex arithmetic. (see std::pow ) Vector2 Vector2 :: pow ( Vector2 p ) Raise the vector to a complex power, in the sense of complex arithmetic. (see std::pow ) Vector2 Vector2 :: conj () Transform the vector to its complex conjugate, negating the y component. Vector2 Vector2 :: inv () Invert the vector, in the sense of complex arithmetic. Equivalent to Vector2 { 1 ., 0 . } / v .","title":"Member operations"},{"location":"utilities/vector2/#function-operations","text":"These operations do not change the vector on which they are called. double norm ( Vector2 v ) Returns the magnitude of the vector. Also available as v . norm () . double norm2 ( Vector2 v ) Returns the squared magnitude of the vector. Also available as v . norm () . Vector2 unit ( Vector2 v ) Returns normalized copy of the vector. double arg ( Vector2 v ) Returns the argument in the sense of complex arithmetic (i.e., the angle against the x x -axis). Also available as v . arg () . double dot ( Vector2 u , Vector2 v ) Returns the dot product between two vectors. double cross ( Vector2 u , Vector2 v ) Returns the \u201ccross\u201d product between two vectors, that is u . x * v . y - u . y * v . x . Intuitively, the z z -component of the 3D cross product of vectors in the plane. Vector3 cross3 ( Vector2 u , Vector2 v ) Returns the 3D cross product of vectors in the plane. double angle ( Vector2 u , Vector2 v ) Returns the angle between two not-necessarily-unit vectors. Output in the range [0, \\pi] [0, \\pi] . Vector2 clamp ( Vector2 val , Vector2 low , Vector2 high ) Returns returns a a vector where each component has been clamped to be between the corresponding compnents of low and high . Vector2 componentwiseMin ( Vector2 u , Vector2 v ) Returns a new vector, each component of which is the minimum of that component in u and v . Vector2 componentwiseMax ( Vector2 u , Vector2 v ) Returns a new vector, each component of which is the maximum of that component in u and v .","title":"Function operations"},{"location":"utilities/vector2/#properties","text":"bool isfinite ( Vector2 u ) Returns true if both of the components of the vector are finite. Note: this function is intentionally not camel-cased out of solidarity with std :: isfinite () . Also available as u . isFinite () . bool isDefined ( Vector2 u ) Returns true if both of the components of the vector are not NaN. Also available as u . isDefined () .","title":"Properties"},{"location":"utilities/vector3/","text":"geometrycentral :: Vector3 is the basic 3D vector type in geometry central. There are many like it, but this one is ours. #include \"geometrycentral/vector3.h\" Construction Vector3 is a POD type, so you should use brace-initialization sytax: #include \"geometrycentral/vector3.h using namespace geometrycentral ; Vector3 myVec { 3.8 , 2.9 , 1.1 }; //create myVec = Vector3 { 1.1 , 2.2 , 3.3 }; // reassign Factory methods can construct a few common values: static Vector3 Vector3 :: zero () Returns the zero vector static Vector3 Vector3 :: constant ( double c ) Returns a vector with all components set to c c static Vector3 Vector3 :: infinity () Returns the infinite vector (\\infty, \\infty, \\infty) (\\infty, \\infty, \\infty) . static Vector3 Vector3 :: undefined () Returns the undefined vector ( NaN , NaN , NaN ) . Access The three elements of the vector can be accessed as vec . x and vec . y and vec . z . Alternately, the elements can be indexed as vec [ 0 ] and vec [ 1 ] and vec [ 2 ] . Conversion Vector3 :: operator << () Vector3 can be serialized. Vector3 v { 1.2 , 3.4 , 5.6 }; std :: cout << v << std :: endl ; // prints something like: <1.2, 3.4, 5.6> Arithmetic Vector3 supports the element-wise addition, subtraction, and scalar multiplication you would probably expect. Member operations These methods do not change the underlying Vector3 , but return a new Vector3 . Vector3 vec { 1. , 2. , 3. }; vec . normalize (); // does nothing vec = vec . normalize (); // much better Vector3 Vector3 :: normalize () Returns a unit-norm vector pointing in the same direction. If the input is the zero vector, the result will contain NaNs. Vector3 Vector3 :: rotateAround ( Vector3 axis , double theta ) Rotate the vector by angle \\theta \\theta around axis in the right-handed direction. axis need not be a unit vector. Vector3 Vector3 :: removeComponent ( Vector3 unitDir ) Removes any component of this vector in the direction unitDir , making the result orthogonal to unitDir . As the name suggests, unitDir must be a unit vector. double Vector3 :: norm () Returns the magnitude of the vector. Also available as norm ( v ) . double Vector3 :: norm2 () Returns the squared magnitude of the vector. Also available as norm2 ( v ) . Function operations These operations do not change the vector on which they are called. double norm ( Vector3 v ) Returns the magnitude of the vector. Also available as v . norm () . double norm2 ( Vector3 v ) Returns the squared magnitude of the vector. Also available as v . norm2 () . Vector3 unit ( Vector3 v ) Returns normalized copy of the vector. double dot ( Vector3 u , Vector3 v ) Returns the dot product between two vectors. double sum ( Vector3 u ) Returns the sum of the coordinates of a vector Vector3 cross ( Vector3 u , Vector3 v ) Returns the cross product between two vectors. double angle ( Vector3 u , Vector3 v ) Returns the angle between two not-necessarily-unit vectors. Output in the range [0, \\pi] [0, \\pi] . double angleInPlane ( Vector3 u , Vector3 v , Vector3 normal ) Returns the signed angle between two not-necessarily-unit vectors, measured in the plane defined by normal (which need not be a unit vector). Output is in the range [-\\pi, \\pi] [-\\pi, \\pi] , as in atan2 . Vector3 clamp ( Vector3 val , Vector3 low , Vector3 high ) Returns returns a a vector where each component has been clamped to be between the corresponding compnents of low and high . Vector3 componentwiseMin ( Vector3 u , Vector3 v ) Returns a new vector, each component of which is the minimum of that component in u and v . Vector3 componentwiseMax ( Vector3 u , Vector3 v ) Returns a new vector, each component of which is the maximum of that component in u and v . Properties bool isfinite ( Vector3 u ) Returns true if all of the components of the vector are finite. Note: this function is intentionally not camel-cased out of solidarity with std :: isfinite () . Also available as u . isFinite () . bool isDefined ( Vector3 u ) Returns true if all of the components of the vector are not NaN. Also available as u . isDefined () .","title":"Vector3"},{"location":"utilities/vector3/#construction","text":"Vector3 is a POD type, so you should use brace-initialization sytax: #include \"geometrycentral/vector3.h using namespace geometrycentral ; Vector3 myVec { 3.8 , 2.9 , 1.1 }; //create myVec = Vector3 { 1.1 , 2.2 , 3.3 }; // reassign Factory methods can construct a few common values: static Vector3 Vector3 :: zero () Returns the zero vector static Vector3 Vector3 :: constant ( double c ) Returns a vector with all components set to c c static Vector3 Vector3 :: infinity () Returns the infinite vector (\\infty, \\infty, \\infty) (\\infty, \\infty, \\infty) . static Vector3 Vector3 :: undefined () Returns the undefined vector ( NaN , NaN , NaN ) .","title":"Construction"},{"location":"utilities/vector3/#access","text":"The three elements of the vector can be accessed as vec . x and vec . y and vec . z . Alternately, the elements can be indexed as vec [ 0 ] and vec [ 1 ] and vec [ 2 ] .","title":"Access"},{"location":"utilities/vector3/#conversion","text":"Vector3 :: operator << () Vector3 can be serialized. Vector3 v { 1.2 , 3.4 , 5.6 }; std :: cout << v << std :: endl ; // prints something like: <1.2, 3.4, 5.6>","title":"Conversion"},{"location":"utilities/vector3/#arithmetic","text":"Vector3 supports the element-wise addition, subtraction, and scalar multiplication you would probably expect.","title":"Arithmetic"},{"location":"utilities/vector3/#member-operations","text":"These methods do not change the underlying Vector3 , but return a new Vector3 . Vector3 vec { 1. , 2. , 3. }; vec . normalize (); // does nothing vec = vec . normalize (); // much better Vector3 Vector3 :: normalize () Returns a unit-norm vector pointing in the same direction. If the input is the zero vector, the result will contain NaNs. Vector3 Vector3 :: rotateAround ( Vector3 axis , double theta ) Rotate the vector by angle \\theta \\theta around axis in the right-handed direction. axis need not be a unit vector. Vector3 Vector3 :: removeComponent ( Vector3 unitDir ) Removes any component of this vector in the direction unitDir , making the result orthogonal to unitDir . As the name suggests, unitDir must be a unit vector. double Vector3 :: norm () Returns the magnitude of the vector. Also available as norm ( v ) . double Vector3 :: norm2 () Returns the squared magnitude of the vector. Also available as norm2 ( v ) .","title":"Member operations"},{"location":"utilities/vector3/#function-operations","text":"These operations do not change the vector on which they are called. double norm ( Vector3 v ) Returns the magnitude of the vector. Also available as v . norm () . double norm2 ( Vector3 v ) Returns the squared magnitude of the vector. Also available as v . norm2 () . Vector3 unit ( Vector3 v ) Returns normalized copy of the vector. double dot ( Vector3 u , Vector3 v ) Returns the dot product between two vectors. double sum ( Vector3 u ) Returns the sum of the coordinates of a vector Vector3 cross ( Vector3 u , Vector3 v ) Returns the cross product between two vectors. double angle ( Vector3 u , Vector3 v ) Returns the angle between two not-necessarily-unit vectors. Output in the range [0, \\pi] [0, \\pi] . double angleInPlane ( Vector3 u , Vector3 v , Vector3 normal ) Returns the signed angle between two not-necessarily-unit vectors, measured in the plane defined by normal (which need not be a unit vector). Output is in the range [-\\pi, \\pi] [-\\pi, \\pi] , as in atan2 . Vector3 clamp ( Vector3 val , Vector3 low , Vector3 high ) Returns returns a a vector where each component has been clamped to be between the corresponding compnents of low and high . Vector3 componentwiseMin ( Vector3 u , Vector3 v ) Returns a new vector, each component of which is the minimum of that component in u and v . Vector3 componentwiseMax ( Vector3 u , Vector3 v ) Returns a new vector, each component of which is the maximum of that component in u and v .","title":"Function operations"},{"location":"utilities/vector3/#properties","text":"bool isfinite ( Vector3 u ) Returns true if all of the components of the vector are finite. Note: this function is intentionally not camel-cased out of solidarity with std :: isfinite () . Also available as u . isFinite () . bool isDefined ( Vector3 u ) Returns true if all of the components of the vector are not NaN. Also available as u . isDefined () .","title":"Properties"}]}